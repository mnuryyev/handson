[["Map",1,2,9,10,186,187],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.16.7","content-config-digest","9fa56466fd6f4ae4","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true,\"allowedDomains\":[]},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false,\"svgo\":false},\"legacy\":{\"collections\":false}}","labs",["Map",11,12,100,101],"en/arp_spoofing",{"id":11,"data":13,"body":18,"filePath":19,"digest":20,"rendered":21},{"title":14,"description":15,"image":16,"date":17},"ARP Protocol Vulnerability and MITM Attack Implementation","In this work, we'll examine how ARP works: from request exchange and traffic analysis in Wireshark to practical implementation of a MITM attack with data interception","/images/arp_spoofing_sec/main.jpg","February 12, 2026","**ARP Spoofing** is a **Man-in-the-Middle** type attack based on the peculiarities of the ARP protocol, which lacks authentication mechanisms. The essence of the attack is that an attacker broadcasts fake ARP responses and thereby substitutes the correspondence between IP and MAC addresses in the local network. As a result, the target device starts to consider the attacking machine, for example, as its default gateway, causing all network traffic to go through the attacker's computer. This makes it possible to intercept, analyze, and if necessary, modify transmitted data.\n\nWithin this work, we'll examine this vulnerability from both theoretical and practical perspectives. We'll deploy an isolated laboratory environment based on **Kali Linux** and **Windows 10**, in which we'll step-by-step reproduce the **ARP Spoofing** attack. During the experiment, we'll demonstrate interception of unencrypted HTTP traffic using **Wireshark**.\n\n## Phase 1. Reconnaissance and Capturing Network Baseline State\n\nBefore starting the attack, it's necessary to conduct network reconnaissance and capture its initial state. This allows us to precisely determine the parameters of target nodes and later clearly show what changes occurred as a result of ARP Spoofing. First of all, we're interested in the IP addresses of interaction participants and the current state of ARP tables, since exactly these will be changed during the attack.\n\n### Step 1. Determining Target Node Parameters\n\nFor the experiment, we deployed a virtual laboratory environment in which Windows 10 operating system is used as the victim, and Kali Linux as the attacking side. Both virtual machines are connected in Bridge mode, which allows them to be in one broadcast domain and directly interact with each other and with the router. The approximate topology looks like this:\n\n![01_topology](/images/arp_spoofing_sec/01_topology.png)\n\nFirst, on the victim's side, network settings were checked to determine the system's IP address and the main gateway address. This data is necessary for conducting the MITM attack, since all external traffic from the Windows machine goes exactly through the gateway. During the check, it was established that the victim's IP address is *192.168.70.11*, and the default gateway is *192.168.70.1*.\n\n![02_ipconfig](/images/arp_spoofing_sec/02_ipconfig.png)\n\n### Step 2. Analyzing the Initial ARP Table\n\nAfter this, the initial ARP table on the Windows side was captured. This stage is necessary to preserve the correct system state before starting the attack and have the ability to compare it with results after ARP cache poisoning. Using the **arp -a** command, the current correspondence between the gateway's IP address and its MAC address was obtained:\n\n![03_arp_a_win](/images/arp_spoofing_sec/03_arp_a_win.png)\n\nFrom the output we see that the default gateway is linked with the correct router MAC address, and the entry type is designated as dynamic. This means the entry was obtained automatically and can be changed when receiving new ARP responses, which creates conditions for conducting ARP Spoofing. The captured ARP table is used later as a checkpoint.\n\n### Step 3. Checking Network Interface on the Attacker's Side\n\n![04_kali_ip_a](/images/arp_spoofing_sec/04_kali_ip_a.png)\n\nOn Kali we open the terminal and enter the command ip a. In the output we see that the active network interface is eth0, and the system's IP address is *192.168.70.12*. This means Kali is in the same network as the victim.\n\n### Step 4. Checking Target Availability\n\nOn Kali Linux we check the target machine's availability. In the terminal we execute the ping command, specifying the Windows system's IP address *192.168.70.11*.\n\n![05_ping_from_kali](/images/arp_spoofing_sec/05_ping_from_kali.png)\n\nFrom the results we see that responses from the target node arrive without losses, and the delay is minimal. This confirms a stable network connection between the attacking machine and the victim and allows moving on to the next research stages.\n\n### Step 5. Network Scanning\n\nTo get an overall picture of the network, we use the netdiscover utility. In Kali Linux it's usually already installed by default or appears after system update and standard package upgrade. If the utility is missing, we install it through the package manager (**sudo apt install netdiscover -y**).\n\nNext, we start scanning the local network. We specify the used network interface (eth0) and the network range *192.168.70.0/24*. Scanning allows determining active devices in the segment and obtaining their IP and MAC addresses.\n\n![06_netdiscover_start](/images/arp_spoofing_sec/06_netdiscover_start.png)\n\n![07_scan_finish](/images/arp_spoofing_sec/07_scan_finish.png)\n\n\nAfter a few seconds, a list of discovered nodes appears in the output. In it we find:\n\n- Router's IP address and MAC address;\n- Windows machine's IP address and MAC address.\n\nAfter obtaining the necessary information, we stop the scan with the key combination **Ctrl + C**.\n\nSuch a stage is used for realistic attack modeling, since in real conditions, before conducting ARP Spoofing, network mapping and determination of all potential targets is first performed.\n\n* * *\n\n## Phase 2. Attacking Machine Configuration\n\n### Step 6. Enabling IP Forwarding\n\nBy default, Linux family operating systems drop packets not addressed to them. If we launch the attack in such a state, the Windows machine will lose connection with the router and internet access will be interrupted, which will instantly unmask our intervention.\n\nTo remain undetected, we must force Kali Linux to work in router mode, that is, accept foreign traffic and immediately forward it to its destination. For this, the **IP Forwarding** function is activated in the Linux kernel.\n\nWe perform verification and activation through the system variable net.ipv4.ip_forward:\n\n![08_forwarding](/images/arp_spoofing_sec/08_forwarding.png)\n\n### Step 7. Installing dsniff\n\nFor implementing the attack, we need specific utilities capable of forming and sending arbitrary ARP packets to the network. In the Kali environment, there's a **dsniff** package for these purposes.\n\nThe main component we're interested in this set is the **arpspoof** utility. Its task is to automate the process of sending fake ARP responses. Instead of manually forming each frame, we delegate this to the program, and it will periodically broadcast our MAC address to the target, maintaining substituted entries in the ARP table. Installation check:\n\n![09_dsniff](/images/arp_spoofing_sec/09_dsniff.png)\n\nARP cache is not static and updates over time, meaning the router periodically reminds of its real MAC address. arpspoof solves this problem by constantly broadcasting fake ARP responses and not allowing these entries to restore, keeping traffic under our control.\n\n* * *\n\n## Phase 3. Launching the Attack\n\nAfter completing preparations, we move on to the active phase, establishing control over the communication channel between the victim and the gateway. To implement a full-fledged MITM attack, we need to organize data interception in both directions. For this, we'll use two parallel **arpspoof** processes.\n\n### Step 8. Launching Bidirectional ARP Spoofing\n\nWe open two terminal windows in Kali Linux and place them side by side. This allows simultaneously controlling the ARP substitution process both from the victim's side and from the router's side.\n\n![10_attackingpng](/images/arp_spoofing_sec/10_attackingpng.png)\n\n**Terminal 1**. We launch the attack on the Windows machine. We specify the network interface (eth0), the victim's IP address (192.168.70.11), and the gateway address (192.168.70.1), on whose behalf we'll act.\n\nAfter launch, the utility starts broadcasting fake ARP responses. Actually, we're substituting the ARP correspondence on the victim's side, linking the router's IP address with Kali Linux's MAC address. Windows accepts the received ARP responses and updates its ARP cache, after which all outgoing traffic starts being directed through the attacking machine.\n\n**Terminal 2**. Deceiving the router. To intercept not only outgoing but also incoming packets from the external network, we set up a similar process in the second terminal, but now we choose the router itself as the target.\n\nIn this command, we inform the router that the Windows machine's MAC address now corresponds to our interface. Thus, we close the loop, meaning the router sends responses from the internet to us, and we, thanks to the previously enabled **IP Forwarding**, transparently forward them to the real recipient.\n\nThe presence of a continuous flow of ARP responses in both terminals confirms that the attack is active. Now we occupy the Man-in-the-Middle position and are ready to analyze traffic passing through us.\n\n* * *\n\n## Phase 4: Attack Confirmation and Data Analysis\n\nAfter launching the active phase, we need to make sure that address substitution actually occurred and the target system accepted our fake data.\n\n### Step 9. Checking Changes in Victim's ARP Table\n\nTo verify the result, we switch to the Windows machine. In the command line we re-enter the **arp -a** command to view the current state of the ARP cache after the attack started.\n\n![11_arp_a_win](/images/arp_spoofing_sec/11_arp_a_win.png)\n\nWhen analyzing the output, we capture a critical moment: the router's IP address (192.168.70.1) and our attacking Kali machine's IP address (192.168.70.12) now have absolutely the **same physical address**.\n\nState comparison:\n\n- Before the attack: The gateway was linked with the real router MAC address (90-f6-52-a9-e3-ac).\n- After the attack: The gateway is bound to our system's MAC address (00-0c-29-07-84-66).\n\nThe Windows system no longer sees the real router directly, for it all packets going to the external network must now be sent to our MAC address.\n\n### Step 10. Configuring Filtering and Generating Traffic\n\nWe check that traffic is going through our system, and immediately configure Wireshark filters to see only the needed packets.\n\nIn the upper part of the Wireshark window, in the Filter field, we set display parameters. We need to see only HTTP requests coming from our victim or directed to it. We enter the following construction: **ip.addr == 192.168.70.11 && http**\n\n![12_wireshark_kali](/images/arp_spoofing_sec/12_wireshark_kali.png)\n\nTo check the interception, we go to the Windows machine's side and open any browser. Most modern sites use HTTPS, because of which packet contents are encrypted and unavailable for viewing. To see HTTP traffic in plain form, we use the site http://neverssl.com, which works without encryption.\n\n![13_neverssl](/images/arp_spoofing_sec/13_neverssl.png)\n\n### Step 11. Analyzing Intercepted Data\n\nAfter the victim visited the site, a list of intercepted HTTP packets appeared in the Wireshark window on Kali Linux. Now we can study the contents of any of them in detail to understand what information an attacker can obtain.\n\n![14_wireshark_http](/images/arp_spoofing_sec/14_wireshark_http.png)\n\n![15_analyzing](/images/arp_spoofing_sec/15_analyzing.png)\n\nFor analysis, we select any packet with the **GET / HTTP/1.1** method. In the lower part of the Wireshark window we expand the Hypertext Transfer Protocol section and look at the application layer contents. Exactly this data in a normal situation should be visible only to the client and web server.\n\nAs a result of analysis, we can see the following information:\n\n- Host - the target resource is determined, in this case neverssl.com.\n- User-Agent - information about the victim's system is displayed, including operating system version (Windows 10) and the used browser.\n- HTTP headers - information about system language, caching parameters, and content types that the browser accepts is available.\n\nSince traffic is transmitted without encryption, all this data is displayed in plain form. In a real scenario, in their place could be session cookies, allowing access to an account without password entry, or the logins and passwords themselves when working with HTTP authorization forms. The ARP Spoofing attack gives complete control over unencrypted network traffic and represents a serious security threat.\n\n### Step 12. Demonstrating Credential Interception\n\nTo assess the real risks of the attack, we'll conduct an experiment on intercepting user-entered data. In modern conditions, most sites use encryption, so for the purity of the experiment we'll create a local test form imitating an authorization page.\n\n![16_test_html](/images/arp_spoofing_sec/16_test_html.png)\n\nOn the Windows side, we create a simple HTML file with an input form. The main feature of this form is the use of the **POST** method and sending data via the unprotected HTTP protocol to the test service httpbin.org.\n\n### Step 13. Filter in Wireshark\n\nOn Kali, we'll change the filter in Wireshark to **http.request.method == \"POST\"** to quickly find the packet with form data.\n\n![17_start_wireshark](/images/arp_spoofing_sec/17_start_wireshark.png)\n\n### Step 14. Sending Test Credentials\n\nOn the Windows side, we fill in the created form. In the login field we entered *testuser*, and in the password field *test123*. After clicking the *Login* button, the data was sent to the network.\n\n![18_test_win](/images/arp_spoofing_sec/18_test_win.png)\n\n### Step 15. Analyzing POST Request in Wireshark\n\nWe returned to Kali Linux and among the intercepted traffic found a packet sent by the **POST** method. Unlike a regular GET request, this packet contains a message body, in which user-entered data is transmitted.\n\n![19_wireshark_result](/images/arp_spoofing_sec/19_wireshark_result.png)\n\nClicking on the packet and expanding the **HTML Form URL Encoded** section, we got full access to the form contents.\n\n* * *\n\n## Phase 5. Stopping the Attack and Network Restoration\n\n### Step 16. Restoring Legitimate ARP Entries\n\nFirst of all, we stop the work of arpspoof in both Kali Linux terminals using the Ctrl + C key combination.\n\nThis is important because with correct stopping, the utility automatically sends so-called re-arping ARP packets. The victim is transmitted the real router MAC address, and the router the real Windows machine MAC address.\n\n### Step 17. Disabling IP Forwarding\n\nAfter the network tables are restored, we need to return our system to standard state. We disable the packet forwarding function so Kali again stops working as a router.\n\n![20_restore](/images/arp_spoofing_sec/20_restore.png)\n\nLeaving IP Forwarding enabled on a working machine is unsafe and impractical. Now our system again ignores packets not addressed to it.\n\n## How to Protect\n\nProtection from ARP Spoofing works only in networks without basic security. Main methods: \n- use static ARP entries, rigidly binding the gateway's IP address to its MAC address;\n- enable Dynamic ARP Inspection on managed switches to block fake ARP packets; apply HTTPS and VPN for traffic encryption so the MITM attacker doesn't see data contents;\n- configure Port Security to limit the number of MAC addresses on a port;\n- segment the network using VLANs so ARP requests don't go beyond their segment.","src/content/labs/en/arp_spoofing.md","2f1752ac9157f1f7",{"html":22,"metadata":23},"\u003Cp>\u003Cstrong>ARP Spoofing\u003C/strong> is a \u003Cstrong>Man-in-the-Middle\u003C/strong> type attack based on the peculiarities of the ARP protocol, which lacks authentication mechanisms. The essence of the attack is that an attacker broadcasts fake ARP responses and thereby substitutes the correspondence between IP and MAC addresses in the local network. As a result, the target device starts to consider the attacking machine, for example, as its default gateway, causing all network traffic to go through the attacker’s computer. This makes it possible to intercept, analyze, and if necessary, modify transmitted data.\u003C/p>\n\u003Cp>Within this work, we’ll examine this vulnerability from both theoretical and practical perspectives. We’ll deploy an isolated laboratory environment based on \u003Cstrong>Kali Linux\u003C/strong> and \u003Cstrong>Windows 10\u003C/strong>, in which we’ll step-by-step reproduce the \u003Cstrong>ARP Spoofing\u003C/strong> attack. During the experiment, we’ll demonstrate interception of unencrypted HTTP traffic using \u003Cstrong>Wireshark\u003C/strong>.\u003C/p>\n\u003Ch2 id=\"phase-1-reconnaissance-and-capturing-network-baseline-state\">Phase 1. Reconnaissance and Capturing Network Baseline State\u003C/h2>\n\u003Cp>Before starting the attack, it’s necessary to conduct network reconnaissance and capture its initial state. This allows us to precisely determine the parameters of target nodes and later clearly show what changes occurred as a result of ARP Spoofing. First of all, we’re interested in the IP addresses of interaction participants and the current state of ARP tables, since exactly these will be changed during the attack.\u003C/p>\n\u003Ch3 id=\"step-1-determining-target-node-parameters\">Step 1. Determining Target Node Parameters\u003C/h3>\n\u003Cp>For the experiment, we deployed a virtual laboratory environment in which Windows 10 operating system is used as the victim, and Kali Linux as the attacking side. Both virtual machines are connected in Bridge mode, which allows them to be in one broadcast domain and directly interact with each other and with the router. The approximate topology looks like this:\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/01_topology.png\" alt=\"01_topology\">\u003C/p>\n\u003Cp>First, on the victim’s side, network settings were checked to determine the system’s IP address and the main gateway address. This data is necessary for conducting the MITM attack, since all external traffic from the Windows machine goes exactly through the gateway. During the check, it was established that the victim’s IP address is \u003Cem>192.168.70.11\u003C/em>, and the default gateway is \u003Cem>192.168.70.1\u003C/em>.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/02_ipconfig.png\" alt=\"02_ipconfig\">\u003C/p>\n\u003Ch3 id=\"step-2-analyzing-the-initial-arp-table\">Step 2. Analyzing the Initial ARP Table\u003C/h3>\n\u003Cp>After this, the initial ARP table on the Windows side was captured. This stage is necessary to preserve the correct system state before starting the attack and have the ability to compare it with results after ARP cache poisoning. Using the \u003Cstrong>arp -a\u003C/strong> command, the current correspondence between the gateway’s IP address and its MAC address was obtained:\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/03_arp_a_win.png\" alt=\"03_arp_a_win\">\u003C/p>\n\u003Cp>From the output we see that the default gateway is linked with the correct router MAC address, and the entry type is designated as dynamic. This means the entry was obtained automatically and can be changed when receiving new ARP responses, which creates conditions for conducting ARP Spoofing. The captured ARP table is used later as a checkpoint.\u003C/p>\n\u003Ch3 id=\"step-3-checking-network-interface-on-the-attackers-side\">Step 3. Checking Network Interface on the Attacker’s Side\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/04_kali_ip_a.png\" alt=\"04_kali_ip_a\">\u003C/p>\n\u003Cp>On Kali we open the terminal and enter the command ip a. In the output we see that the active network interface is eth0, and the system’s IP address is \u003Cem>192.168.70.12\u003C/em>. This means Kali is in the same network as the victim.\u003C/p>\n\u003Ch3 id=\"step-4-checking-target-availability\">Step 4. Checking Target Availability\u003C/h3>\n\u003Cp>On Kali Linux we check the target machine’s availability. In the terminal we execute the ping command, specifying the Windows system’s IP address \u003Cem>192.168.70.11\u003C/em>.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/05_ping_from_kali.png\" alt=\"05_ping_from_kali\">\u003C/p>\n\u003Cp>From the results we see that responses from the target node arrive without losses, and the delay is minimal. This confirms a stable network connection between the attacking machine and the victim and allows moving on to the next research stages.\u003C/p>\n\u003Ch3 id=\"step-5-network-scanning\">Step 5. Network Scanning\u003C/h3>\n\u003Cp>To get an overall picture of the network, we use the netdiscover utility. In Kali Linux it’s usually already installed by default or appears after system update and standard package upgrade. If the utility is missing, we install it through the package manager (\u003Cstrong>sudo apt install netdiscover -y\u003C/strong>).\u003C/p>\n\u003Cp>Next, we start scanning the local network. We specify the used network interface (eth0) and the network range \u003Cem>192.168.70.0/24\u003C/em>. Scanning allows determining active devices in the segment and obtaining their IP and MAC addresses.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/06_netdiscover_start.png\" alt=\"06_netdiscover_start\">\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/07_scan_finish.png\" alt=\"07_scan_finish\">\u003C/p>\n\u003Cp>After a few seconds, a list of discovered nodes appears in the output. In it we find:\u003C/p>\n\u003Cul>\n\u003Cli>Router’s IP address and MAC address;\u003C/li>\n\u003Cli>Windows machine’s IP address and MAC address.\u003C/li>\n\u003C/ul>\n\u003Cp>After obtaining the necessary information, we stop the scan with the key combination \u003Cstrong>Ctrl + C\u003C/strong>.\u003C/p>\n\u003Cp>Such a stage is used for realistic attack modeling, since in real conditions, before conducting ARP Spoofing, network mapping and determination of all potential targets is first performed.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"phase-2-attacking-machine-configuration\">Phase 2. Attacking Machine Configuration\u003C/h2>\n\u003Ch3 id=\"step-6-enabling-ip-forwarding\">Step 6. Enabling IP Forwarding\u003C/h3>\n\u003Cp>By default, Linux family operating systems drop packets not addressed to them. If we launch the attack in such a state, the Windows machine will lose connection with the router and internet access will be interrupted, which will instantly unmask our intervention.\u003C/p>\n\u003Cp>To remain undetected, we must force Kali Linux to work in router mode, that is, accept foreign traffic and immediately forward it to its destination. For this, the \u003Cstrong>IP Forwarding\u003C/strong> function is activated in the Linux kernel.\u003C/p>\n\u003Cp>We perform verification and activation through the system variable net.ipv4.ip_forward:\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/08_forwarding.png\" alt=\"08_forwarding\">\u003C/p>\n\u003Ch3 id=\"step-7-installing-dsniff\">Step 7. Installing dsniff\u003C/h3>\n\u003Cp>For implementing the attack, we need specific utilities capable of forming and sending arbitrary ARP packets to the network. In the Kali environment, there’s a \u003Cstrong>dsniff\u003C/strong> package for these purposes.\u003C/p>\n\u003Cp>The main component we’re interested in this set is the \u003Cstrong>arpspoof\u003C/strong> utility. Its task is to automate the process of sending fake ARP responses. Instead of manually forming each frame, we delegate this to the program, and it will periodically broadcast our MAC address to the target, maintaining substituted entries in the ARP table. Installation check:\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/09_dsniff.png\" alt=\"09_dsniff\">\u003C/p>\n\u003Cp>ARP cache is not static and updates over time, meaning the router periodically reminds of its real MAC address. arpspoof solves this problem by constantly broadcasting fake ARP responses and not allowing these entries to restore, keeping traffic under our control.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"phase-3-launching-the-attack\">Phase 3. Launching the Attack\u003C/h2>\n\u003Cp>After completing preparations, we move on to the active phase, establishing control over the communication channel between the victim and the gateway. To implement a full-fledged MITM attack, we need to organize data interception in both directions. For this, we’ll use two parallel \u003Cstrong>arpspoof\u003C/strong> processes.\u003C/p>\n\u003Ch3 id=\"step-8-launching-bidirectional-arp-spoofing\">Step 8. Launching Bidirectional ARP Spoofing\u003C/h3>\n\u003Cp>We open two terminal windows in Kali Linux and place them side by side. This allows simultaneously controlling the ARP substitution process both from the victim’s side and from the router’s side.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/10_attackingpng.png\" alt=\"10_attackingpng\">\u003C/p>\n\u003Cp>\u003Cstrong>Terminal 1\u003C/strong>. We launch the attack on the Windows machine. We specify the network interface (eth0), the victim’s IP address (192.168.70.11), and the gateway address (192.168.70.1), on whose behalf we’ll act.\u003C/p>\n\u003Cp>After launch, the utility starts broadcasting fake ARP responses. Actually, we’re substituting the ARP correspondence on the victim’s side, linking the router’s IP address with Kali Linux’s MAC address. Windows accepts the received ARP responses and updates its ARP cache, after which all outgoing traffic starts being directed through the attacking machine.\u003C/p>\n\u003Cp>\u003Cstrong>Terminal 2\u003C/strong>. Deceiving the router. To intercept not only outgoing but also incoming packets from the external network, we set up a similar process in the second terminal, but now we choose the router itself as the target.\u003C/p>\n\u003Cp>In this command, we inform the router that the Windows machine’s MAC address now corresponds to our interface. Thus, we close the loop, meaning the router sends responses from the internet to us, and we, thanks to the previously enabled \u003Cstrong>IP Forwarding\u003C/strong>, transparently forward them to the real recipient.\u003C/p>\n\u003Cp>The presence of a continuous flow of ARP responses in both terminals confirms that the attack is active. Now we occupy the Man-in-the-Middle position and are ready to analyze traffic passing through us.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"phase-4-attack-confirmation-and-data-analysis\">Phase 4: Attack Confirmation and Data Analysis\u003C/h2>\n\u003Cp>After launching the active phase, we need to make sure that address substitution actually occurred and the target system accepted our fake data.\u003C/p>\n\u003Ch3 id=\"step-9-checking-changes-in-victims-arp-table\">Step 9. Checking Changes in Victim’s ARP Table\u003C/h3>\n\u003Cp>To verify the result, we switch to the Windows machine. In the command line we re-enter the \u003Cstrong>arp -a\u003C/strong> command to view the current state of the ARP cache after the attack started.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/11_arp_a_win.png\" alt=\"11_arp_a_win\">\u003C/p>\n\u003Cp>When analyzing the output, we capture a critical moment: the router’s IP address (192.168.70.1) and our attacking Kali machine’s IP address (192.168.70.12) now have absolutely the \u003Cstrong>same physical address\u003C/strong>.\u003C/p>\n\u003Cp>State comparison:\u003C/p>\n\u003Cul>\n\u003Cli>Before the attack: The gateway was linked with the real router MAC address (90-f6-52-a9-e3-ac).\u003C/li>\n\u003Cli>After the attack: The gateway is bound to our system’s MAC address (00-0c-29-07-84-66).\u003C/li>\n\u003C/ul>\n\u003Cp>The Windows system no longer sees the real router directly, for it all packets going to the external network must now be sent to our MAC address.\u003C/p>\n\u003Ch3 id=\"step-10-configuring-filtering-and-generating-traffic\">Step 10. Configuring Filtering and Generating Traffic\u003C/h3>\n\u003Cp>We check that traffic is going through our system, and immediately configure Wireshark filters to see only the needed packets.\u003C/p>\n\u003Cp>In the upper part of the Wireshark window, in the Filter field, we set display parameters. We need to see only HTTP requests coming from our victim or directed to it. We enter the following construction: \u003Cstrong>ip.addr == 192.168.70.11 &#x26;&#x26; http\u003C/strong>\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/12_wireshark_kali.png\" alt=\"12_wireshark_kali\">\u003C/p>\n\u003Cp>To check the interception, we go to the Windows machine’s side and open any browser. Most modern sites use HTTPS, because of which packet contents are encrypted and unavailable for viewing. To see HTTP traffic in plain form, we use the site \u003Ca href=\"http://neverssl.com\">http://neverssl.com\u003C/a>, which works without encryption.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/13_neverssl.png\" alt=\"13_neverssl\">\u003C/p>\n\u003Ch3 id=\"step-11-analyzing-intercepted-data\">Step 11. Analyzing Intercepted Data\u003C/h3>\n\u003Cp>After the victim visited the site, a list of intercepted HTTP packets appeared in the Wireshark window on Kali Linux. Now we can study the contents of any of them in detail to understand what information an attacker can obtain.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/14_wireshark_http.png\" alt=\"14_wireshark_http\">\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/15_analyzing.png\" alt=\"15_analyzing\">\u003C/p>\n\u003Cp>For analysis, we select any packet with the \u003Cstrong>GET / HTTP/1.1\u003C/strong> method. In the lower part of the Wireshark window we expand the Hypertext Transfer Protocol section and look at the application layer contents. Exactly this data in a normal situation should be visible only to the client and web server.\u003C/p>\n\u003Cp>As a result of analysis, we can see the following information:\u003C/p>\n\u003Cul>\n\u003Cli>Host - the target resource is determined, in this case neverssl.com.\u003C/li>\n\u003Cli>User-Agent - information about the victim’s system is displayed, including operating system version (Windows 10) and the used browser.\u003C/li>\n\u003Cli>HTTP headers - information about system language, caching parameters, and content types that the browser accepts is available.\u003C/li>\n\u003C/ul>\n\u003Cp>Since traffic is transmitted without encryption, all this data is displayed in plain form. In a real scenario, in their place could be session cookies, allowing access to an account without password entry, or the logins and passwords themselves when working with HTTP authorization forms. The ARP Spoofing attack gives complete control over unencrypted network traffic and represents a serious security threat.\u003C/p>\n\u003Ch3 id=\"step-12-demonstrating-credential-interception\">Step 12. Demonstrating Credential Interception\u003C/h3>\n\u003Cp>To assess the real risks of the attack, we’ll conduct an experiment on intercepting user-entered data. In modern conditions, most sites use encryption, so for the purity of the experiment we’ll create a local test form imitating an authorization page.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/16_test_html.png\" alt=\"16_test_html\">\u003C/p>\n\u003Cp>On the Windows side, we create a simple HTML file with an input form. The main feature of this form is the use of the \u003Cstrong>POST\u003C/strong> method and sending data via the unprotected HTTP protocol to the test service httpbin.org.\u003C/p>\n\u003Ch3 id=\"step-13-filter-in-wireshark\">Step 13. Filter in Wireshark\u003C/h3>\n\u003Cp>On Kali, we’ll change the filter in Wireshark to \u003Cstrong>http.request.method == “POST”\u003C/strong> to quickly find the packet with form data.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/17_start_wireshark.png\" alt=\"17_start_wireshark\">\u003C/p>\n\u003Ch3 id=\"step-14-sending-test-credentials\">Step 14. Sending Test Credentials\u003C/h3>\n\u003Cp>On the Windows side, we fill in the created form. In the login field we entered \u003Cem>testuser\u003C/em>, and in the password field \u003Cem>test123\u003C/em>. After clicking the \u003Cem>Login\u003C/em> button, the data was sent to the network.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/18_test_win.png\" alt=\"18_test_win\">\u003C/p>\n\u003Ch3 id=\"step-15-analyzing-post-request-in-wireshark\">Step 15. Analyzing POST Request in Wireshark\u003C/h3>\n\u003Cp>We returned to Kali Linux and among the intercepted traffic found a packet sent by the \u003Cstrong>POST\u003C/strong> method. Unlike a regular GET request, this packet contains a message body, in which user-entered data is transmitted.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/19_wireshark_result.png\" alt=\"19_wireshark_result\">\u003C/p>\n\u003Cp>Clicking on the packet and expanding the \u003Cstrong>HTML Form URL Encoded\u003C/strong> section, we got full access to the form contents.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"phase-5-stopping-the-attack-and-network-restoration\">Phase 5. Stopping the Attack and Network Restoration\u003C/h2>\n\u003Ch3 id=\"step-16-restoring-legitimate-arp-entries\">Step 16. Restoring Legitimate ARP Entries\u003C/h3>\n\u003Cp>First of all, we stop the work of arpspoof in both Kali Linux terminals using the Ctrl + C key combination.\u003C/p>\n\u003Cp>This is important because with correct stopping, the utility automatically sends so-called re-arping ARP packets. The victim is transmitted the real router MAC address, and the router the real Windows machine MAC address.\u003C/p>\n\u003Ch3 id=\"step-17-disabling-ip-forwarding\">Step 17. Disabling IP Forwarding\u003C/h3>\n\u003Cp>After the network tables are restored, we need to return our system to standard state. We disable the packet forwarding function so Kali again stops working as a router.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/20_restore.png\" alt=\"20_restore\">\u003C/p>\n\u003Cp>Leaving IP Forwarding enabled on a working machine is unsafe and impractical. Now our system again ignores packets not addressed to it.\u003C/p>\n\u003Ch2 id=\"how-to-protect\">How to Protect\u003C/h2>\n\u003Cp>Protection from ARP Spoofing works only in networks without basic security. Main methods:\u003C/p>\n\u003Cul>\n\u003Cli>use static ARP entries, rigidly binding the gateway’s IP address to its MAC address;\u003C/li>\n\u003Cli>enable Dynamic ARP Inspection on managed switches to block fake ARP packets; apply HTTPS and VPN for traffic encryption so the MITM attacker doesn’t see data contents;\u003C/li>\n\u003Cli>configure Port Security to limit the number of MAC addresses on a port;\u003C/li>\n\u003Cli>segment the network using VLANs so ARP requests don’t go beyond their segment.\u003C/li>\n\u003C/ul>",{"headings":24,"localImagePaths":96,"remoteImagePaths":97,"frontmatter":98,"imagePaths":99},[25,29,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87,90,93],{"depth":26,"slug":27,"text":28},2,"phase-1-reconnaissance-and-capturing-network-baseline-state","Phase 1. Reconnaissance and Capturing Network Baseline State",{"depth":30,"slug":31,"text":32},3,"step-1-determining-target-node-parameters","Step 1. Determining Target Node Parameters",{"depth":30,"slug":34,"text":35},"step-2-analyzing-the-initial-arp-table","Step 2. Analyzing the Initial ARP Table",{"depth":30,"slug":37,"text":38},"step-3-checking-network-interface-on-the-attackers-side","Step 3. Checking Network Interface on the Attacker’s Side",{"depth":30,"slug":40,"text":41},"step-4-checking-target-availability","Step 4. Checking Target Availability",{"depth":30,"slug":43,"text":44},"step-5-network-scanning","Step 5. Network Scanning",{"depth":26,"slug":46,"text":47},"phase-2-attacking-machine-configuration","Phase 2. Attacking Machine Configuration",{"depth":30,"slug":49,"text":50},"step-6-enabling-ip-forwarding","Step 6. Enabling IP Forwarding",{"depth":30,"slug":52,"text":53},"step-7-installing-dsniff","Step 7. Installing dsniff",{"depth":26,"slug":55,"text":56},"phase-3-launching-the-attack","Phase 3. Launching the Attack",{"depth":30,"slug":58,"text":59},"step-8-launching-bidirectional-arp-spoofing","Step 8. Launching Bidirectional ARP Spoofing",{"depth":26,"slug":61,"text":62},"phase-4-attack-confirmation-and-data-analysis","Phase 4: Attack Confirmation and Data Analysis",{"depth":30,"slug":64,"text":65},"step-9-checking-changes-in-victims-arp-table","Step 9. Checking Changes in Victim’s ARP Table",{"depth":30,"slug":67,"text":68},"step-10-configuring-filtering-and-generating-traffic","Step 10. Configuring Filtering and Generating Traffic",{"depth":30,"slug":70,"text":71},"step-11-analyzing-intercepted-data","Step 11. Analyzing Intercepted Data",{"depth":30,"slug":73,"text":74},"step-12-demonstrating-credential-interception","Step 12. Demonstrating Credential Interception",{"depth":30,"slug":76,"text":77},"step-13-filter-in-wireshark","Step 13. Filter in Wireshark",{"depth":30,"slug":79,"text":80},"step-14-sending-test-credentials","Step 14. Sending Test Credentials",{"depth":30,"slug":82,"text":83},"step-15-analyzing-post-request-in-wireshark","Step 15. Analyzing POST Request in Wireshark",{"depth":26,"slug":85,"text":86},"phase-5-stopping-the-attack-and-network-restoration","Phase 5. Stopping the Attack and Network Restoration",{"depth":30,"slug":88,"text":89},"step-16-restoring-legitimate-arp-entries","Step 16. Restoring Legitimate ARP Entries",{"depth":30,"slug":91,"text":92},"step-17-disabling-ip-forwarding","Step 17. Disabling IP Forwarding",{"depth":26,"slug":94,"text":95},"how-to-protect","How to Protect",[],[],{"title":14,"description":15,"image":16,"date":17},[],"ru/arp_spoofing",{"id":100,"data":102,"body":106,"filePath":107,"digest":108,"rendered":109},{"title":103,"description":104,"image":16,"date":105},"Уязвимость протокола ARP и реализация MITM-атаки","В этой работе мы разберём, как работает ARP: от обмена запросами и анализа трафика в Wireshark до практической реализации MITM-атаки с перехватом данных","12 февраля 2026","**ARP Spoofing** — это атака типа **Man-in-the-Middle**, основанная на особенностях работы протокола ARP, в котором отсутствуют механизмы проверки подлинности. Суть атаки заключается в том, что злоумышленник рассылает поддельные ARP-ответы и тем самым подменяет соответствие между IP- и MAC-адресами в локальной сети. В результате целевое устройство начинает считать атакующую машину, например, своим шлюзом по умолчанию, из-за чего весь сетевой трафик проходит через компьютер атакующего. Это даёт возможность перехватывать, анализировать и при необходимости изменять передаваемые данные.\n\nВ рамках данной работы мы рассмотрим данную уязвимость как с теоретической, так и с практической точки зрения. Мы развернём изолированную лабораторную среду на базе **Kali Linux** и **Windows 10**, в которой поэтапно воспроизведём атаку **ARP Spoofing**. В ходе эксперимента мы продемонстрируем перехват незашифрованного HTTP-трафика с использованием **Wireshark**.\n\n## Фаза 1. Разведка и фиксация базового состояния сети\n\nПеред началом атаки необходимо провести разведку сети и зафиксировать её исходное состояние. Это позволяет точно определить параметры целевых узлов и в дальнейшем наглядно показать, какие изменения произошли в результате ARP Spoofing. В первую очередь нас интересуют IP-адреса участников взаимодействия и текущее состояние ARP-таблиц, так как именно они будут изменены в ходе атаки.\n\n### Шаг 1. Определение параметров целевых узлов\n\nДля проведения эксперимента мы развернули виртуальную лабораторную среду, в которой в роли жертвы используется операционная система Windows 10, а в роли атакующей стороны Kali Linux. Обе виртуальные машины подключены в режиме Bridge, что позволяет им находиться в одном широковещательном домене и напрямую взаимодействовать друг с другом и с маршрутизатором. Примерная топология выглядит так:\n\n![01_topology](/images/arp_spoofing_sec/01_topology.png)\n\nСначала на стороне жертвы была выполнена проверка сетевых настроек, чтобы определить IP-адрес системы и адрес основного шлюза. Эти данные необходимы для дальнейшего проведения MITM-атаки, так как весь внешний трафик Windows-машины проходит именно через шлюз. В ходе проверки было установлено, что IP-адрес жертвы *192.168.70.11*, а шлюз по умолчанию *192.168.70.1*.\n\n![02_ipconfig](/images/arp_spoofing_sec/02_ipconfig.png)\n\n### Шаг 2. Анализ исходной ARP-таблицы\n\nПосле этого была зафиксирована исходная ARP-таблица на стороне Windows. Данный этап необходим для того, чтобы сохранить корректное состояние системы до начала атаки и иметь возможность сравнить его с результатами после отравления ARP-кэша. С помощью команды **arp -a** было получено текущее соответствие между IP-адресом шлюза и его MAC-адресом:\n\n![03_arp_a_win](/images/arp_spoofing_sec/03_arp_a_win.png)\n\nИз вывода видим, что шлюз по умолчанию связан с корректным MAC-адресом маршрутизатора, а тип записи обозначен как динамический. Это означает, что запись была получена автоматически и может быть изменена при получении новых ARP-ответов, что создаёт условия для проведения ARP Spoofing. Зафиксированная ARP-таблица используется в дальнейшем как контрольная точка.\n\n### Шаг 3. Проверка сетевого интерфейса на стороне атакующего\n\n![04_kali_ip_a](/images/arp_spoofing_sec/04_kali_ip_a.png)\n\nНа Kali открываем терминал и вводим команду ip a. В выводе видно, что активным сетевым интерфейсом является eth0, а IP-адрес системы *192.168.70.12*. Это означает, что Kali находится в одной сети с жертвой.\n\n### Шаг 4. Проверка доступности цели\n\nНа Kali Linux проверяем доступность целевой машины. В терминале выполняем команду ping, указав IP-адрес Windows-системы *192.168.70.11*.\n\n![05_ping_from_kali](/images/arp_spoofing_sec/05_ping_from_kali.png)\n\nПо результатам видим, что ответы от целевого узла приходят без потерь, а задержка минимальна. Это подтверждает стабильное сетевое соединение между атакующей машиной и жертвой и позволяет переходить к следующим этапам исследования.\n\n### Шаг 5. Сканирование сети\n\nДля получения общей картины сети используем утилиту netdiscover. В Kali Linux она, как правило, уже установлена по умолчанию либо появляется после обновления системы и стандартного апгрейда пакетов. Если утилиты нет, устанавливаем её через менеджер пакетов (**sudo apt install netdiscover -y**).\n\nДалее запускаем сканирование локальной сети. Указываем используемый сетевой интерфейс (eth0) и диапазон сети *192.168.70.0/24*. Сканирование позволяет определить активные устройства в сегменте и получить их IP- и MAC-адреса.\n\n![06_netdiscover_start](/images/arp_spoofing_sec/06_netdiscover_start.png)\n\n![07_scan_finish](/images/arp_spoofing_sec/07_scan_finish.png)\n\n\nЧерез несколько секунд в выводе появляется список обнаруженных узлов. В нём находим:\n\n- IP-адрес и MAC-адрес маршрутизатора;\n- IP-адрес и MAC-адрес Windows-машины.\n\nПосле получения необходимой информации останавливаем сканирование сочетанием клавиш **Ctrl + C**.\n\nТакой этап используется для реалистичного моделирования атаки, так как в реальных условиях перед проведением ARP Spoofing сначала выполняется картирование сети и определение всех потенциальных целей.\n\n* * *\n\n## Фаза 2. Настройка атакующей машины\n\n### Шаг 6. Включение IP Forwarding\n\nПо умолчанию операционные системы семейства Linux отбрасывают пакеты, адресованные не им. Если мы запустим атаку в таком состоянии, Windows-машина потеряет связь с роутером и доступ в интернет будет прерван, что мгновенно демаскирует наше вмешательство.\n\nЧтобы остаться незамеченным, мы должны заставить Kali Linux работать в режиме маршрутизатора, то есть принимать чужой трафик и тут же пересылать его по назначению. Для этого в ядре Linux активируется функция **IP Forwarding**.\n\nВыполняем проверку и активацию через системную переменную net.ipv4.ip_forward:\n\n![08_forwarding](/images/arp_spoofing_sec/08_forwarding.png)\n\n### Шаг 7. Установка dsniff\n\nДля реализации атаки нам необходимы специфические утилиты, способные формировать и отправлять в сеть произвольные ARP-пакеты. В среде Kali для этих целей есть пакет **dsniff**.\n\nГлавный компонент, который нас интересует в этом наборе, это утилита **arpspoof**. Её задача заключается в автоматизации процесса отправки поддельных ARP-ответов. Вместо того чтобы вручную формировать каждый кадр, мы делегируем это программе, а она будет с заданной периодичностью транслировать цели наш MAC-адрес, поддерживая подменённые записи в ARP-таблице. Проверка установки:\n\n![09_dsniff](/images/arp_spoofing_sec/09_dsniff.png)\n\nARP‑кэш не статичен и со временем обновляется, т.е роутер периодически напоминает о своём настоящем MAC‑адресе. arpspoof решает эту проблему тем, что постоянно рассылает поддельные ARP‑ответы и не даёт этим записям восстановиться, удерживая трафик под нашим контролем.\n\n* * *\n\n## Фаза 3. Запуск атаки\n\nПосле завершения подготовки мы переходим к активной фазе, установке контроля над каналом связи между жертвой и шлюзом. Чтобы реализовать полноценную MITM-атаку, нам необходимо организовать перехват данных в обоих направлениях. Для этого мы будем использовать два параллельных процесса **arpspoof**.\n\n### Шаг 8. Запуск двустороннего ARP Spoofing\n\nОткрываем в Kali Linux два окна терминала и располагаем их рядом. Это позволяет одновременно контролировать процесс ARP‑подмены как со стороны жертвы, так и со стороны маршрутизатора.\n\n![10_attackingpng](/images/arp_spoofing_sec/10_attackingpng.png)\n\n**Терминал 1**. Запускаем атаку на Windows-машину. Мы указываем сетевой интерфейс (eth0), IP-адрес жертвы (192.168.70.11) и адрес шлюза (192.168.70.1), от имени которого будем выступать.\n\nПосле запуска утилита начинает транслировать поддельные ARP-ответы. Фактически мы подменяем ARP‑соответствие на стороне жертвы, связывая IP‑адрес маршрутизатора с MAC‑адресом Kali Linux. Windows принимает полученные ARP‑ответы и обновляет свой ARP‑кэш, после чего весь исходящий трафик начинает направляться через атакующую машину.\n\n**Терминал 2**. Обман маршрутизатора. Чтобы перехватывать не только исходящие, но и входящие пакеты из внешней сети, мы настраиваем аналогичный процесс во втором терминале, но целью выбираем уже сам роутер.\n\nВ этой команде мы сообщаем маршрутизатору, что MAC-адрес Windows-машины теперь соответствует нашему интерфейсу. Таким образом, мы замыкаем цикл, т.е роутер отправляет ответы из интернета нам, а мы, благодаря включённому ранее **IP Forwarding**, прозрачно пробрасываем их реальному получателю.\n\nНаличие непрерывного потока ARP-ответов в обоих терминалах подтверждает, что атака активна. Теперь мы занимаем позицию человека посередине (Man-in-the-Middle) и готовы к анализу проходящего через нас трафика.\n\n* * *\n\n## Фаза 4: Подтверждение атаки и и анализ данных\n\nПосле запуска активной фазы нам необходимо убедиться, что подмена адресов действительно произошла и целевая система приняла наши поддельные данные.\n\n### Шаг 9. Проверка изменений в ARP-таблице жертвы\n\nДля верификации результата мы переключаемся на Windows-машину. В командной строке повторно вводим команду **arp -a**, чтобы просмотреть текущее состояние ARP-кэша после начала атаки.\n\n![11_arp_a_win](/images/arp_spoofing_sec/11_arp_a_win.png)\n\nПри анализе вывода мы фиксируем критический момент: IP-адрес роутера (192.168.70.1) и IP-адрес нашей атакующей машины Kali (192.168.70.12) теперь имеют абсолютно **одинаковый физический адрес**.\n\nСравнение состояний:\n\n- До атаки: Шлюз был связан с реальным MAC-адресом маршрутизатора (90-f6-52-a9-e3-ac).\n- После атаки: Шлюз привязан к MAC-адресу нашей системы (00-0c-29-07-84-66).\n\nWindows-система больше не видит реальный роутер напрямую, для неё все пакеты, уходящие во внешнюю сеть, теперь должны отправляться на наш MAC-адрес.\n\n### Шаг 10. Настройка фильтрации и генерация трафика\n\nПроверяем, что трафик идёт через нашу систему, и сразу настраиваем фильтры Wireshark, чтобы видеть только нужные пакеты.\n\nВ верхней части окна Wireshark, в поле Filter, мы задаём параметры отображения. Нам нужно видеть только HTTP-запросы, исходящие от нашей жертвы или направленные ей. Вводим следующую конструкцию: **ip.addr == 192.168.70.11 && http**\n\n![12_wireshark_kali](/images/arp_spoofing_sec/12_wireshark_kali.png)\n\nДля проверки перехвата мы переходим на сторону Windows-машины и открываем любой браузер. Большинство современных сайтов используют HTTPS, из‑за чего содержимое пакетов зашифровано и недоступно для просмотра. Чтобы увидеть HTTP‑трафик в открытом виде, используем сайт http://neverssl.com, который работает без шифрования.\n\n![13_neverssl](/images/arp_spoofing_sec/13_neverssl.png)\n\n### Шаг 11. Анализ перехваченных данных\n\nПосле того как жертва перешла на сайт, в окне Wireshark на Kali Linux отобразился список перехваченных HTTP-пакетов. Теперь мы можем детально изучить содержимое любого из них, чтобы понять, какую информацию может получить атакующий.\n\n![14_wireshark_http](/images/arp_spoofing_sec/14_wireshark_http.png)\n\n![15_analyzing](/images/arp_spoofing_sec/15_analyzing.png)\n\nДля анализа выбираем любой пакет с методом **GET / HTTP/1.1**. В нижней части окна Wireshark раскрываем раздел Hypertext Transfer Protocol и смотрим содержимое прикладного уровня. Именно эти данные в нормальной ситуации должны быть видны только клиенту и веб‑серверу.\n\nВ результате анализа можем увидеть следующую информацию:\n\n- Host - определяется целевой ресурс, в данном случае neverssl.com.\n- User-Agent - отображается информация о системе жертвы, включая версию операционной системы (Windows 10) и используемый браузер.\n- HTTP‑заголовки - доступны сведения о языке системы, параметрах кэширования и типах контента, которые принимает браузер.\n\nПоскольку трафик передаётся без шифрования, все эти данные отображаются в открытом виде. В реальном сценарии на их месте могли находиться сессионные cookies, позволяющие получить доступ к учётной записи без ввода пароля, либо сами логины и пароли при работе с HTTP‑формами авторизации. Атака ARP Spoofing даёт полный контроль над незашифрованным сетевым трафиком и представляет серьёзную угрозу безопасности.\n\n### Шаг 12. Демонстрация перехвата учётных данных\n\nДля того чтобы оценить реальные риски атаки, мы проведем эксперимент по перехвату вводимых пользователем данных. В современных условиях большинство сайтов используют шифрование, поэтому для чистоты эксперимента мы создадим локальную тестовую форму, имитирующую страницу авторизации.\n\n![16_test_html](/images/arp_spoofing_sec/16_test_html.png)\n\nНа стороне Windows мы создаем простой HTML-файл с формой ввода. Главная особенность этой формы использование метода **POST** и отправка данных по незащищённому протоколу HTTP на тестовый сервис httpbin.org.\n\n### Шаг 13. фильтр в Wireshark\n\nна Kali, мы изменим фильтр в Wireshark на **http.request.method == \"POST\"**, чтобы быстро найти пакет с данными формы.\n\n![17_start_wireshark](/images/arp_spoofing_sec/17_start_wireshark.png)\n\n### Шаг 14. Отправка тестовых учётных данных\n\nНа стороне Windows мы заполняем созданную форму. В поле логина ввели *testuser*, а в поле пароля *test123*. После нажатия кнопки *Login* данные были отправлены в сеть.\n\n![18_test_win](/images/arp_spoofing_sec/18_test_win.png)\n\n### Шаг 15. Анализ POST-запроса в Wireshark\n\nМы вернулись на Kali Linux и среди перехваченного трафика нашли пакет, отправленный методом **POST**. В отличие от обычного GET-запроса, этот пакет содержит тело сообщения, в котором и передаются введённые пользователем данные.\n\n![19_wireshark_result](/images/arp_spoofing_sec/19_wireshark_result.png)\n\nКликнув на пакет и раскрыв секцию **HTML Form URL Encoded**, мы получили полный доступ к содержимому формы.\n\n* * *\n\n## Фаза 5. Остановка атаки и восстановление сети\n\n### Шаг 16. Восстановление легитимных ARP‑записей\n\nВ первую очередь останавливаем работу arpspoof в обоих терминалах Kali Linux, используя сочетание клавиш Ctrl + C.\n\nЭто важно, потому что при корректной остановке утилита автоматически отправляет так называемые re-arping ARP‑пакеты. Жертве передаётся реальный MAC‑адрес маршрутизатора, а маршрутизатору реальный MAC‑адрес Windows‑машины.\n\n### Шаг 17. Отключение IP Forwarding\n\nПосле того как сетевые таблицы восстановились, нам нужно вернуть нашу систему в стандартное состояние. Мы отключаем функцию пересылки пакетов, чтобы Kali снова перестала работать как маршрутизатор.\n\n![20_restore](/images/arp_spoofing_sec/20_restore.png)\n\nОставлять IP Forwarding включенным на рабочей машине небезопасно и нецелесообразно. Теперь наша система снова игнорирует пакеты, адресованные не ей.\n\n## Как защититься\n\nЗащита от ARP Spoofing работает только в сетях без базовой безопасности. Основные способы: \n- использовать статические ARP‑записи, жёстко привязывая IP‑адрес шлюза к его MAC‑адресу;\n- включить Dynamic ARP Inspection на управляемых коммутаторах, чтобы блокировать поддельные ARP‑пакеты; применять HTTPS и VPN для шифрования трафика, чтобы MITM‑атакер не видел содержимое данных;\n- настроить Port Security для ограничения числа MAC‑адресов на порту;\n- сегментировать сеть с помощью VLAN, чтобы ARP‑запросы не выходили за пределы своего сегмента.","src/content/labs/ru/arp_spoofing.md","5c424ba063c19c31",{"html":110,"metadata":111},"\u003Cp>\u003Cstrong>ARP Spoofing\u003C/strong> — это атака типа \u003Cstrong>Man-in-the-Middle\u003C/strong>, основанная на особенностях работы протокола ARP, в котором отсутствуют механизмы проверки подлинности. Суть атаки заключается в том, что злоумышленник рассылает поддельные ARP-ответы и тем самым подменяет соответствие между IP- и MAC-адресами в локальной сети. В результате целевое устройство начинает считать атакующую машину, например, своим шлюзом по умолчанию, из-за чего весь сетевой трафик проходит через компьютер атакующего. Это даёт возможность перехватывать, анализировать и при необходимости изменять передаваемые данные.\u003C/p>\n\u003Cp>В рамках данной работы мы рассмотрим данную уязвимость как с теоретической, так и с практической точки зрения. Мы развернём изолированную лабораторную среду на базе \u003Cstrong>Kali Linux\u003C/strong> и \u003Cstrong>Windows 10\u003C/strong>, в которой поэтапно воспроизведём атаку \u003Cstrong>ARP Spoofing\u003C/strong>. В ходе эксперимента мы продемонстрируем перехват незашифрованного HTTP-трафика с использованием \u003Cstrong>Wireshark\u003C/strong>.\u003C/p>\n\u003Ch2 id=\"фаза-1-разведка-и-фиксация-базового-состояния-сети\">Фаза 1. Разведка и фиксация базового состояния сети\u003C/h2>\n\u003Cp>Перед началом атаки необходимо провести разведку сети и зафиксировать её исходное состояние. Это позволяет точно определить параметры целевых узлов и в дальнейшем наглядно показать, какие изменения произошли в результате ARP Spoofing. В первую очередь нас интересуют IP-адреса участников взаимодействия и текущее состояние ARP-таблиц, так как именно они будут изменены в ходе атаки.\u003C/p>\n\u003Ch3 id=\"шаг-1-определение-параметров-целевых-узлов\">Шаг 1. Определение параметров целевых узлов\u003C/h3>\n\u003Cp>Для проведения эксперимента мы развернули виртуальную лабораторную среду, в которой в роли жертвы используется операционная система Windows 10, а в роли атакующей стороны Kali Linux. Обе виртуальные машины подключены в режиме Bridge, что позволяет им находиться в одном широковещательном домене и напрямую взаимодействовать друг с другом и с маршрутизатором. Примерная топология выглядит так:\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/01_topology.png\" alt=\"01_topology\">\u003C/p>\n\u003Cp>Сначала на стороне жертвы была выполнена проверка сетевых настроек, чтобы определить IP-адрес системы и адрес основного шлюза. Эти данные необходимы для дальнейшего проведения MITM-атаки, так как весь внешний трафик Windows-машины проходит именно через шлюз. В ходе проверки было установлено, что IP-адрес жертвы \u003Cem>192.168.70.11\u003C/em>, а шлюз по умолчанию \u003Cem>192.168.70.1\u003C/em>.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/02_ipconfig.png\" alt=\"02_ipconfig\">\u003C/p>\n\u003Ch3 id=\"шаг-2-анализ-исходной-arp-таблицы\">Шаг 2. Анализ исходной ARP-таблицы\u003C/h3>\n\u003Cp>После этого была зафиксирована исходная ARP-таблица на стороне Windows. Данный этап необходим для того, чтобы сохранить корректное состояние системы до начала атаки и иметь возможность сравнить его с результатами после отравления ARP-кэша. С помощью команды \u003Cstrong>arp -a\u003C/strong> было получено текущее соответствие между IP-адресом шлюза и его MAC-адресом:\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/03_arp_a_win.png\" alt=\"03_arp_a_win\">\u003C/p>\n\u003Cp>Из вывода видим, что шлюз по умолчанию связан с корректным MAC-адресом маршрутизатора, а тип записи обозначен как динамический. Это означает, что запись была получена автоматически и может быть изменена при получении новых ARP-ответов, что создаёт условия для проведения ARP Spoofing. Зафиксированная ARP-таблица используется в дальнейшем как контрольная точка.\u003C/p>\n\u003Ch3 id=\"шаг-3-проверка-сетевого-интерфейса-на-стороне-атакующего\">Шаг 3. Проверка сетевого интерфейса на стороне атакующего\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/04_kali_ip_a.png\" alt=\"04_kali_ip_a\">\u003C/p>\n\u003Cp>На Kali открываем терминал и вводим команду ip a. В выводе видно, что активным сетевым интерфейсом является eth0, а IP-адрес системы \u003Cem>192.168.70.12\u003C/em>. Это означает, что Kali находится в одной сети с жертвой.\u003C/p>\n\u003Ch3 id=\"шаг-4-проверка-доступности-цели\">Шаг 4. Проверка доступности цели\u003C/h3>\n\u003Cp>На Kali Linux проверяем доступность целевой машины. В терминале выполняем команду ping, указав IP-адрес Windows-системы \u003Cem>192.168.70.11\u003C/em>.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/05_ping_from_kali.png\" alt=\"05_ping_from_kali\">\u003C/p>\n\u003Cp>По результатам видим, что ответы от целевого узла приходят без потерь, а задержка минимальна. Это подтверждает стабильное сетевое соединение между атакующей машиной и жертвой и позволяет переходить к следующим этапам исследования.\u003C/p>\n\u003Ch3 id=\"шаг-5-сканирование-сети\">Шаг 5. Сканирование сети\u003C/h3>\n\u003Cp>Для получения общей картины сети используем утилиту netdiscover. В Kali Linux она, как правило, уже установлена по умолчанию либо появляется после обновления системы и стандартного апгрейда пакетов. Если утилиты нет, устанавливаем её через менеджер пакетов (\u003Cstrong>sudo apt install netdiscover -y\u003C/strong>).\u003C/p>\n\u003Cp>Далее запускаем сканирование локальной сети. Указываем используемый сетевой интерфейс (eth0) и диапазон сети \u003Cem>192.168.70.0/24\u003C/em>. Сканирование позволяет определить активные устройства в сегменте и получить их IP- и MAC-адреса.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/06_netdiscover_start.png\" alt=\"06_netdiscover_start\">\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/07_scan_finish.png\" alt=\"07_scan_finish\">\u003C/p>\n\u003Cp>Через несколько секунд в выводе появляется список обнаруженных узлов. В нём находим:\u003C/p>\n\u003Cul>\n\u003Cli>IP-адрес и MAC-адрес маршрутизатора;\u003C/li>\n\u003Cli>IP-адрес и MAC-адрес Windows-машины.\u003C/li>\n\u003C/ul>\n\u003Cp>После получения необходимой информации останавливаем сканирование сочетанием клавиш \u003Cstrong>Ctrl + C\u003C/strong>.\u003C/p>\n\u003Cp>Такой этап используется для реалистичного моделирования атаки, так как в реальных условиях перед проведением ARP Spoofing сначала выполняется картирование сети и определение всех потенциальных целей.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"фаза-2-настройка-атакующей-машины\">Фаза 2. Настройка атакующей машины\u003C/h2>\n\u003Ch3 id=\"шаг-6-включение-ip-forwarding\">Шаг 6. Включение IP Forwarding\u003C/h3>\n\u003Cp>По умолчанию операционные системы семейства Linux отбрасывают пакеты, адресованные не им. Если мы запустим атаку в таком состоянии, Windows-машина потеряет связь с роутером и доступ в интернет будет прерван, что мгновенно демаскирует наше вмешательство.\u003C/p>\n\u003Cp>Чтобы остаться незамеченным, мы должны заставить Kali Linux работать в режиме маршрутизатора, то есть принимать чужой трафик и тут же пересылать его по назначению. Для этого в ядре Linux активируется функция \u003Cstrong>IP Forwarding\u003C/strong>.\u003C/p>\n\u003Cp>Выполняем проверку и активацию через системную переменную net.ipv4.ip_forward:\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/08_forwarding.png\" alt=\"08_forwarding\">\u003C/p>\n\u003Ch3 id=\"шаг-7-установка-dsniff\">Шаг 7. Установка dsniff\u003C/h3>\n\u003Cp>Для реализации атаки нам необходимы специфические утилиты, способные формировать и отправлять в сеть произвольные ARP-пакеты. В среде Kali для этих целей есть пакет \u003Cstrong>dsniff\u003C/strong>.\u003C/p>\n\u003Cp>Главный компонент, который нас интересует в этом наборе, это утилита \u003Cstrong>arpspoof\u003C/strong>. Её задача заключается в автоматизации процесса отправки поддельных ARP-ответов. Вместо того чтобы вручную формировать каждый кадр, мы делегируем это программе, а она будет с заданной периодичностью транслировать цели наш MAC-адрес, поддерживая подменённые записи в ARP-таблице. Проверка установки:\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/09_dsniff.png\" alt=\"09_dsniff\">\u003C/p>\n\u003Cp>ARP‑кэш не статичен и со временем обновляется, т.е роутер периодически напоминает о своём настоящем MAC‑адресе. arpspoof решает эту проблему тем, что постоянно рассылает поддельные ARP‑ответы и не даёт этим записям восстановиться, удерживая трафик под нашим контролем.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"фаза-3-запуск-атаки\">Фаза 3. Запуск атаки\u003C/h2>\n\u003Cp>После завершения подготовки мы переходим к активной фазе, установке контроля над каналом связи между жертвой и шлюзом. Чтобы реализовать полноценную MITM-атаку, нам необходимо организовать перехват данных в обоих направлениях. Для этого мы будем использовать два параллельных процесса \u003Cstrong>arpspoof\u003C/strong>.\u003C/p>\n\u003Ch3 id=\"шаг-8-запуск-двустороннего-arp-spoofing\">Шаг 8. Запуск двустороннего ARP Spoofing\u003C/h3>\n\u003Cp>Открываем в Kali Linux два окна терминала и располагаем их рядом. Это позволяет одновременно контролировать процесс ARP‑подмены как со стороны жертвы, так и со стороны маршрутизатора.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/10_attackingpng.png\" alt=\"10_attackingpng\">\u003C/p>\n\u003Cp>\u003Cstrong>Терминал 1\u003C/strong>. Запускаем атаку на Windows-машину. Мы указываем сетевой интерфейс (eth0), IP-адрес жертвы (192.168.70.11) и адрес шлюза (192.168.70.1), от имени которого будем выступать.\u003C/p>\n\u003Cp>После запуска утилита начинает транслировать поддельные ARP-ответы. Фактически мы подменяем ARP‑соответствие на стороне жертвы, связывая IP‑адрес маршрутизатора с MAC‑адресом Kali Linux. Windows принимает полученные ARP‑ответы и обновляет свой ARP‑кэш, после чего весь исходящий трафик начинает направляться через атакующую машину.\u003C/p>\n\u003Cp>\u003Cstrong>Терминал 2\u003C/strong>. Обман маршрутизатора. Чтобы перехватывать не только исходящие, но и входящие пакеты из внешней сети, мы настраиваем аналогичный процесс во втором терминале, но целью выбираем уже сам роутер.\u003C/p>\n\u003Cp>В этой команде мы сообщаем маршрутизатору, что MAC-адрес Windows-машины теперь соответствует нашему интерфейсу. Таким образом, мы замыкаем цикл, т.е роутер отправляет ответы из интернета нам, а мы, благодаря включённому ранее \u003Cstrong>IP Forwarding\u003C/strong>, прозрачно пробрасываем их реальному получателю.\u003C/p>\n\u003Cp>Наличие непрерывного потока ARP-ответов в обоих терминалах подтверждает, что атака активна. Теперь мы занимаем позицию человека посередине (Man-in-the-Middle) и готовы к анализу проходящего через нас трафика.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"фаза-4-подтверждение-атаки-и-и-анализ-данных\">Фаза 4: Подтверждение атаки и и анализ данных\u003C/h2>\n\u003Cp>После запуска активной фазы нам необходимо убедиться, что подмена адресов действительно произошла и целевая система приняла наши поддельные данные.\u003C/p>\n\u003Ch3 id=\"шаг-9-проверка-изменений-в-arp-таблице-жертвы\">Шаг 9. Проверка изменений в ARP-таблице жертвы\u003C/h3>\n\u003Cp>Для верификации результата мы переключаемся на Windows-машину. В командной строке повторно вводим команду \u003Cstrong>arp -a\u003C/strong>, чтобы просмотреть текущее состояние ARP-кэша после начала атаки.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/11_arp_a_win.png\" alt=\"11_arp_a_win\">\u003C/p>\n\u003Cp>При анализе вывода мы фиксируем критический момент: IP-адрес роутера (192.168.70.1) и IP-адрес нашей атакующей машины Kali (192.168.70.12) теперь имеют абсолютно \u003Cstrong>одинаковый физический адрес\u003C/strong>.\u003C/p>\n\u003Cp>Сравнение состояний:\u003C/p>\n\u003Cul>\n\u003Cli>До атаки: Шлюз был связан с реальным MAC-адресом маршрутизатора (90-f6-52-a9-e3-ac).\u003C/li>\n\u003Cli>После атаки: Шлюз привязан к MAC-адресу нашей системы (00-0c-29-07-84-66).\u003C/li>\n\u003C/ul>\n\u003Cp>Windows-система больше не видит реальный роутер напрямую, для неё все пакеты, уходящие во внешнюю сеть, теперь должны отправляться на наш MAC-адрес.\u003C/p>\n\u003Ch3 id=\"шаг-10-настройка-фильтрации-и-генерация-трафика\">Шаг 10. Настройка фильтрации и генерация трафика\u003C/h3>\n\u003Cp>Проверяем, что трафик идёт через нашу систему, и сразу настраиваем фильтры Wireshark, чтобы видеть только нужные пакеты.\u003C/p>\n\u003Cp>В верхней части окна Wireshark, в поле Filter, мы задаём параметры отображения. Нам нужно видеть только HTTP-запросы, исходящие от нашей жертвы или направленные ей. Вводим следующую конструкцию: \u003Cstrong>ip.addr == 192.168.70.11 &#x26;&#x26; http\u003C/strong>\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/12_wireshark_kali.png\" alt=\"12_wireshark_kali\">\u003C/p>\n\u003Cp>Для проверки перехвата мы переходим на сторону Windows-машины и открываем любой браузер. Большинство современных сайтов используют HTTPS, из‑за чего содержимое пакетов зашифровано и недоступно для просмотра. Чтобы увидеть HTTP‑трафик в открытом виде, используем сайт \u003Ca href=\"http://neverssl.com\">http://neverssl.com\u003C/a>, который работает без шифрования.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/13_neverssl.png\" alt=\"13_neverssl\">\u003C/p>\n\u003Ch3 id=\"шаг-11-анализ-перехваченных-данных\">Шаг 11. Анализ перехваченных данных\u003C/h3>\n\u003Cp>После того как жертва перешла на сайт, в окне Wireshark на Kali Linux отобразился список перехваченных HTTP-пакетов. Теперь мы можем детально изучить содержимое любого из них, чтобы понять, какую информацию может получить атакующий.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/14_wireshark_http.png\" alt=\"14_wireshark_http\">\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/15_analyzing.png\" alt=\"15_analyzing\">\u003C/p>\n\u003Cp>Для анализа выбираем любой пакет с методом \u003Cstrong>GET / HTTP/1.1\u003C/strong>. В нижней части окна Wireshark раскрываем раздел Hypertext Transfer Protocol и смотрим содержимое прикладного уровня. Именно эти данные в нормальной ситуации должны быть видны только клиенту и веб‑серверу.\u003C/p>\n\u003Cp>В результате анализа можем увидеть следующую информацию:\u003C/p>\n\u003Cul>\n\u003Cli>Host - определяется целевой ресурс, в данном случае neverssl.com.\u003C/li>\n\u003Cli>User-Agent - отображается информация о системе жертвы, включая версию операционной системы (Windows 10) и используемый браузер.\u003C/li>\n\u003Cli>HTTP‑заголовки - доступны сведения о языке системы, параметрах кэширования и типах контента, которые принимает браузер.\u003C/li>\n\u003C/ul>\n\u003Cp>Поскольку трафик передаётся без шифрования, все эти данные отображаются в открытом виде. В реальном сценарии на их месте могли находиться сессионные cookies, позволяющие получить доступ к учётной записи без ввода пароля, либо сами логины и пароли при работе с HTTP‑формами авторизации. Атака ARP Spoofing даёт полный контроль над незашифрованным сетевым трафиком и представляет серьёзную угрозу безопасности.\u003C/p>\n\u003Ch3 id=\"шаг-12-демонстрация-перехвата-учётных-данных\">Шаг 12. Демонстрация перехвата учётных данных\u003C/h3>\n\u003Cp>Для того чтобы оценить реальные риски атаки, мы проведем эксперимент по перехвату вводимых пользователем данных. В современных условиях большинство сайтов используют шифрование, поэтому для чистоты эксперимента мы создадим локальную тестовую форму, имитирующую страницу авторизации.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/16_test_html.png\" alt=\"16_test_html\">\u003C/p>\n\u003Cp>На стороне Windows мы создаем простой HTML-файл с формой ввода. Главная особенность этой формы использование метода \u003Cstrong>POST\u003C/strong> и отправка данных по незащищённому протоколу HTTP на тестовый сервис httpbin.org.\u003C/p>\n\u003Ch3 id=\"шаг-13-фильтр-в-wireshark\">Шаг 13. фильтр в Wireshark\u003C/h3>\n\u003Cp>на Kali, мы изменим фильтр в Wireshark на \u003Cstrong>http.request.method == “POST”\u003C/strong>, чтобы быстро найти пакет с данными формы.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/17_start_wireshark.png\" alt=\"17_start_wireshark\">\u003C/p>\n\u003Ch3 id=\"шаг-14-отправка-тестовых-учётных-данных\">Шаг 14. Отправка тестовых учётных данных\u003C/h3>\n\u003Cp>На стороне Windows мы заполняем созданную форму. В поле логина ввели \u003Cem>testuser\u003C/em>, а в поле пароля \u003Cem>test123\u003C/em>. После нажатия кнопки \u003Cem>Login\u003C/em> данные были отправлены в сеть.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/18_test_win.png\" alt=\"18_test_win\">\u003C/p>\n\u003Ch3 id=\"шаг-15-анализ-post-запроса-в-wireshark\">Шаг 15. Анализ POST-запроса в Wireshark\u003C/h3>\n\u003Cp>Мы вернулись на Kali Linux и среди перехваченного трафика нашли пакет, отправленный методом \u003Cstrong>POST\u003C/strong>. В отличие от обычного GET-запроса, этот пакет содержит тело сообщения, в котором и передаются введённые пользователем данные.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/19_wireshark_result.png\" alt=\"19_wireshark_result\">\u003C/p>\n\u003Cp>Кликнув на пакет и раскрыв секцию \u003Cstrong>HTML Form URL Encoded\u003C/strong>, мы получили полный доступ к содержимому формы.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"фаза-5-остановка-атаки-и-восстановление-сети\">Фаза 5. Остановка атаки и восстановление сети\u003C/h2>\n\u003Ch3 id=\"шаг-16-восстановление-легитимных-arpзаписей\">Шаг 16. Восстановление легитимных ARP‑записей\u003C/h3>\n\u003Cp>В первую очередь останавливаем работу arpspoof в обоих терминалах Kali Linux, используя сочетание клавиш Ctrl + C.\u003C/p>\n\u003Cp>Это важно, потому что при корректной остановке утилита автоматически отправляет так называемые re-arping ARP‑пакеты. Жертве передаётся реальный MAC‑адрес маршрутизатора, а маршрутизатору реальный MAC‑адрес Windows‑машины.\u003C/p>\n\u003Ch3 id=\"шаг-17-отключение-ip-forwarding\">Шаг 17. Отключение IP Forwarding\u003C/h3>\n\u003Cp>После того как сетевые таблицы восстановились, нам нужно вернуть нашу систему в стандартное состояние. Мы отключаем функцию пересылки пакетов, чтобы Kali снова перестала работать как маршрутизатор.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_spoofing_sec/20_restore.png\" alt=\"20_restore\">\u003C/p>\n\u003Cp>Оставлять IP Forwarding включенным на рабочей машине небезопасно и нецелесообразно. Теперь наша система снова игнорирует пакеты, адресованные не ей.\u003C/p>\n\u003Ch2 id=\"как-защититься\">Как защититься\u003C/h2>\n\u003Cp>Защита от ARP Spoofing работает только в сетях без базовой безопасности. Основные способы:\u003C/p>\n\u003Cul>\n\u003Cli>использовать статические ARP‑записи, жёстко привязывая IP‑адрес шлюза к его MAC‑адресу;\u003C/li>\n\u003Cli>включить Dynamic ARP Inspection на управляемых коммутаторах, чтобы блокировать поддельные ARP‑пакеты; применять HTTPS и VPN для шифрования трафика, чтобы MITM‑атакер не видел содержимое данных;\u003C/li>\n\u003Cli>настроить Port Security для ограничения числа MAC‑адресов на порту;\u003C/li>\n\u003Cli>сегментировать сеть с помощью VLAN, чтобы ARP‑запросы не выходили за пределы своего сегмента.\u003C/li>\n\u003C/ul>",{"headings":112,"localImagePaths":182,"remoteImagePaths":183,"frontmatter":184,"imagePaths":185},[113,116,119,122,125,128,131,134,137,140,143,146,149,152,155,158,161,164,167,170,173,176,179],{"depth":26,"slug":114,"text":115},"фаза-1-разведка-и-фиксация-базового-состояния-сети","Фаза 1. Разведка и фиксация базового состояния сети",{"depth":30,"slug":117,"text":118},"шаг-1-определение-параметров-целевых-узлов","Шаг 1. Определение параметров целевых узлов",{"depth":30,"slug":120,"text":121},"шаг-2-анализ-исходной-arp-таблицы","Шаг 2. Анализ исходной ARP-таблицы",{"depth":30,"slug":123,"text":124},"шаг-3-проверка-сетевого-интерфейса-на-стороне-атакующего","Шаг 3. Проверка сетевого интерфейса на стороне атакующего",{"depth":30,"slug":126,"text":127},"шаг-4-проверка-доступности-цели","Шаг 4. Проверка доступности цели",{"depth":30,"slug":129,"text":130},"шаг-5-сканирование-сети","Шаг 5. Сканирование сети",{"depth":26,"slug":132,"text":133},"фаза-2-настройка-атакующей-машины","Фаза 2. Настройка атакующей машины",{"depth":30,"slug":135,"text":136},"шаг-6-включение-ip-forwarding","Шаг 6. Включение IP Forwarding",{"depth":30,"slug":138,"text":139},"шаг-7-установка-dsniff","Шаг 7. Установка dsniff",{"depth":26,"slug":141,"text":142},"фаза-3-запуск-атаки","Фаза 3. Запуск атаки",{"depth":30,"slug":144,"text":145},"шаг-8-запуск-двустороннего-arp-spoofing","Шаг 8. Запуск двустороннего ARP Spoofing",{"depth":26,"slug":147,"text":148},"фаза-4-подтверждение-атаки-и-и-анализ-данных","Фаза 4: Подтверждение атаки и и анализ данных",{"depth":30,"slug":150,"text":151},"шаг-9-проверка-изменений-в-arp-таблице-жертвы","Шаг 9. Проверка изменений в ARP-таблице жертвы",{"depth":30,"slug":153,"text":154},"шаг-10-настройка-фильтрации-и-генерация-трафика","Шаг 10. Настройка фильтрации и генерация трафика",{"depth":30,"slug":156,"text":157},"шаг-11-анализ-перехваченных-данных","Шаг 11. Анализ перехваченных данных",{"depth":30,"slug":159,"text":160},"шаг-12-демонстрация-перехвата-учётных-данных","Шаг 12. Демонстрация перехвата учётных данных",{"depth":30,"slug":162,"text":163},"шаг-13-фильтр-в-wireshark","Шаг 13. фильтр в Wireshark",{"depth":30,"slug":165,"text":166},"шаг-14-отправка-тестовых-учётных-данных","Шаг 14. Отправка тестовых учётных данных",{"depth":30,"slug":168,"text":169},"шаг-15-анализ-post-запроса-в-wireshark","Шаг 15. Анализ POST-запроса в Wireshark",{"depth":26,"slug":171,"text":172},"фаза-5-остановка-атаки-и-восстановление-сети","Фаза 5. Остановка атаки и восстановление сети",{"depth":30,"slug":174,"text":175},"шаг-16-восстановление-легитимных-arpзаписей","Шаг 16. Восстановление легитимных ARP‑записей",{"depth":30,"slug":177,"text":178},"шаг-17-отключение-ip-forwarding","Шаг 17. Отключение IP Forwarding",{"depth":26,"slug":180,"text":181},"как-защититься","Как защититься",[],[],{"title":103,"description":104,"image":16,"date":105},[],"articles",["Map",188,189,228,229,286,287,324,325,373,374,450,451],"en/arp",{"id":188,"data":190,"body":192,"filePath":193,"digest":194,"rendered":195},{"title":191},"ARP Protocol and Data Exchange in Local Networks","**ARP (Address Resolution Protocol)** is a protocol that helps devices in a local network find each other.\n\nUsually we work with IP addresses or domain names (which get converted to IP through DNS). But inside a local network, data is transmitted not by IP, but by MAC addresses. Switches only see MAC addresses and have no idea what IP is.\n\nSo before sending data, a device needs to find out: which MAC address corresponds to the needed IP. That's what ARP does.\n\nIt broadcasts a request on the network, gets a response from the needed device, and remembers the IP ↔ MAC correspondence. Thanks to this, devices can exchange data normally, even if the physical address of the recipient was unknown beforehand.\n\n\n### 1. Build the Topology\n\n![01_topology](/images/arp_net/01_topology.png)\n\nFor the lab setup in GNS3, we'll create a simple network with a Cisco router, a switch, and two virtual machines. The router will have a FastEthernet0/0 interface configured with address *192.168.1.1/24*, which will act as the gateway for all network devices. The switch connects all nodes in one subnet, providing data transmission at the data link layer.\n\n* * *\n\n### 2. Configuring IP Addresses on the Router and Client PCs\n\n![02_set_router](/images/arp_net/02_set_router.png)\n\nLet's move on to configuring the Cisco router. First, we select the needed interface, in my case FastEthernet0/0, and assign it an IP address and subnet mask. For the interface in our network, we assign *192.168.1.1/24*. After that, the interface needs to be activated with the **no shutdown** command so it starts working and passing traffic. Now the router is ready to exchange data with devices in the local network.\n\n* * *\n\n![03_set_windows](/images/arp_net/03_set_windows.png)\n\nNow let's configure the IP address on the Windows 10 client machine. To do this, we open the network adapter settings, select the needed connection, and manually specify the IP address, subnet mask, and gateway. In our example, for Windows we set IP *192.168.1.10*, subnet mask *255.255.255.0*, and for the gateway we specify the router address - *192.168.1.1*. After saving the settings, the computer will be able to exchange data with other network devices and access the local subnet.\n\n* * *\n\n![04_set_route](/images/arp_net/04_set_route.png)\n\nOn Linux, we'll configure the IP address manually through the terminal. In our case, the network interface is called **enp2s0**. To assign a static IP, we use the command **sudo ip addr add 192.168.1.11/24 dev enp2s0**. Next, we need to specify the default gateway through which the device will access the network **sudo ip route add default via 192.168.1.1**. After these actions, the enp2s0 interface gets IP address *192.168.1.11* with subnet mask *255.255.255.0*, and the router *192.168.1.1* acts as the gateway. Now the Ubuntu machine can correctly exchange data with other network devices and interact with the router.\n\n* * *\n\n### 3. Breakdown of Standard ARP Message Exchange\n\n![05_empty_arp](/images/arp_net/05_empty_arp.png)\n\nLet's move on to capturing network traffic using Wireshark. For convenience, we filter packets by ARP protocol to see only ARP messages. At the start of the capture, the ARP tables on both hosts are empty, so all requests and responses will be recorded from scratch.\n\n* * *\n\n![06_arp_d_win](/images/arp_net/06_arp_d_win.png)\n\nBefore starting the experiment, we'll clear the ARP cache on both hosts so that all entries are created anew and we can observe the process in real time.\n\nOn Windows, this is done through the command line with the **arp -d** command. This command removes all existing ARP entries. Then you can check the table status with **arp -a**.\n\nInitially the table is empty, but after running the ping command to another host, new entries will appear, reflecting the recently resolved MAC addresses\n\n* * *\n\n![07_arp_d_linux](/images/arp_net/07_arp_d_linux.png)\n\nOn Linux, clearing the ARP cache is done with the command **sudo ip neigh flush all**. This command removes all current ARP entries for all interfaces, including enp2s0 in our case. After running it, the system forgets which MAC addresses correspond to which IPs, and all subsequent connections to other network devices will initiate new ARP requests.\n\nTo make sure the table is really empty, you can use **ip neigh show**. Initially the output will be empty since the entries are deleted. After the host tries to send data to another device, new entries will appear in the table, reflecting the just-resolved MAC addresses.\n\n* * *\n\n![08_ping](/images/arp_net/08_ping.png)\n\nWe send ICMP requests to the Linux machine with IP address *192.168.1.11*, then proceed to analyze the network traffic in Wireshark.\n\n* * *\n\n![09_wireshark](/images/arp_net/09_wireshark.png)\n\nARP request and ARP response entries appeared in Wireshark.\n\n* * *\n\n#### ARP Request\n\n![10_arp_request](/images/arp_net/10_arp_request.png)\n\nWhen a device in a local network wants to send data to another device, it needs to know the recipient's MAC address. If there's no entry for this IP in the ARP cache, the system performs the following steps:\n\n- **Step 1:** Checking the ARP cache. The computer first checks its ARP table. If an entry for the needed IP is missing, it needs to find out the MAC address of the device with that IP.\n\n- **Step 2:** Forming the ARP request. The device creates an ARP packet that specifies:\n\n    - Its own MAC and IP, so the recipient knows who's asking.\n    - The target IP address - the address whose MAC needs to be found.\n    - The target MAC address is left empty (00:00:00:00:00:00), since it's not known yet.\n\n- **Step 3:**. Sending the request to all network devices (broadcast)\nThe packet is sent to address ff:ff:ff:ff:ff:ff, meaning to all computers in the local network, so the needed device will definitely receive it.\n\n- **Step 4:**. Processing the request by other devices. Each computer checks if its IP matches the target: If it matches, the device forms an ARP response and sends it back to the sender. If it doesn't match, it ignores the packet.\n\n- **Step 5**. Updating the ARP cache. After receiving the response, the sender saves the IP ↔ MAC correspondence in the ARP cache. Now subsequent data transmissions can be done directly, without a new request.\n\n**ARP Request Fields**\n\n| Field                  | Example Value       | Description                                                      |\n|-----------------------|---------------------|---------------------------------------------------------------|\n| **Hardware Type**      | Ethernet (1)         | Data link layer type (Ethernet).                             |\n| **Protocol Type**      | IPv4 (0x0800)        | Upper layer protocol we're looking for the MAC for (IPv4).      |\n| **Hardware Size**      | 6                    | MAC address length in bytes.                                   |\n| **Protocol Size**      | 4                    | IP address length in bytes.                                    |\n| **Opcode**             | Request (1)          | ARP message type: 1 — request.                               |\n| **Sender MAC Address** | 0c:e5:1d:02:00:00   | MAC address of the request sender.                                |\n| **Sender IP Address**  | 192.168.1.10         | IP address of the sender.                                        |\n| **Target MAC Address** | 00:00:00:00:00:00    | MAC address of the target (not yet known).                             |\n| **Target IP Address**  | 192.168.1.11         | IP address of the device whose MAC address needs to be found.        |\n\n* * *\n\n#### ARP Reply\n\n![11_arp_reply](/images/arp_net/11_arp_reply.png)\n\nWhen a device receives an ARP request and finds that the IP in the request matches its own, it forms an ARP reply. This message tells the request sender which MAC address corresponds to the requested IP.\n\n-   **Step 1:** Receiving the ARP request. The device receives the ARP request and checks if its IP matches the IP address in the request. If it matches, it prepares a response.\n    \n-   **Step 2:** Forming the ARP reply. The device creates an ARP packet that specifies:\n    \n    -   Its own MAC and IP — this is the address and IP of the device that's responding.\n    -   The MAC and IP of the request sender — so the response reaches exactly them.\n        \n-   **Step 3:** Sending the response directly (unicast). The ARP Reply is sent to the MAC address of the request sender, not to broadcast. The packet goes only to the needed device.\n    \n-   **Step 4:** Updating the ARP cache at the recipient. The computer that sent the request receives the response and records the IP ↔ MAC correspondence in its ARP cache.\n    \n-   **Step 5:** Further data transmission. After recording in the cache, the device can send data directly, without needing a new ARP request.\n\n**ARP Reply Fields**\n\n| Field                  | Example Value       | Description                                                      |\n|-----------------------|---------------------|---------------------------------------------------------------|\n| **Hardware Type**      | Ethernet (1)         | Data link layer type (Ethernet).                             |\n| **Protocol Type**      | IPv4 (0x0800)        | Upper layer protocol (IPv4).                              |\n| **Hardware Size**      | 6                    | MAC address length in bytes.                                   |\n| **Protocol Size**      | 4                    | IP address length in bytes.                                    |\n| **Opcode**             | Reply (2)            | ARP message type: 2 — reply.                                 |\n| **Sender MAC Address** | 0c:ef:f7:15:00:00   | MAC address of the device responding to the request.             |\n| **Sender IP Address**  | 192.168.1.11         | IP address of the device that's responding.                        |\n| **Target MAC Address** | 0c:e5:1d:02:00:00   | MAC address of the device the reply is intended for.           |\n| **Target IP Address**  | 192.168.1.10         | IP address of the device the reply is intended for.            |\n\n\n* * *\n\n### Breakdown of Standard Gratuitous ARP (G-ARP) Exchange on the Network\n\n![12_arping_linux_grad](/images/arp_net/12_arping_linux_grad.png)\n\nGratuitous ARP is a special type of ARP message that a device sends about itself, without anyone making a request. In other words, a computer or server itself tells the network: \"Here's my IP and MAC address\". Such packets don't require a response from other devices — they're broadcast so that all computers and network equipment in the local network update their ARP caches.\n\nThe main purposes of using G-ARP are as follows:\n\n1. Updating other devices' ARP caches. If the MAC address or IP changed on a device, sending G-ARP allows all network nodes to learn the current data.\n\n2. Checking if an IP address is taken. A device can send G-ARP to make sure the given IP isn't being used by another device.\n\n3. Informing the network when a device starts up. When a computer or server just powered on, G-ARP helps routers, switches, and other hosts quickly learn the correct MAC for its IP.\n\nIn Linux, sending G-ARP is easily done using the **arping** utility. The device sends an ARP Reply to the broadcast address, but doesn't wait for a response. This approach differs from a standard ARP request, when a computer looks for another host's MAC address and waits for a response.\n\nFor example, if Ubuntu sends a G-ARP for IP 192.168.1.11, it broadcasts a message on the network, announcing its MAC address. All devices in the local network that receive this packet update their ARP caches, even if they didn't request this address. Thanks to this, subsequent data transmissions can be done directly, without extra requests.\n\n![13_g_arp](/images/arp_net/13_g_arp.png)\n\n**ARP Reply Fields**\n\n| Field                  | Example Value       | Description                                                      |\n|-----------------------|---------------------|---------------------------------------------------------------|\n| **Hardware Type**      | Ethernet (1)         | Data link layer type (Ethernet).                             |\n| **Protocol Type**      | IPv4 (0x0800)        | Upper layer protocol (IPv4).                              |\n| **Hardware Size**      | 6                    | MAC address length in bytes.                                   |\n| **Protocol Size**      | 4                    | IP address length in bytes.                                    |\n| **Opcode**             | Reply (2)            | ARP message type: 2 — reply. In G-ARP, ARP Reply is used, but without a request. |\n| **Sender MAC Address** | 0c:ef:f7:15:00:00   | MAC address of the device broadcasting information about itself.   |\n| **Sender IP Address**  | 192.168.1.11         | IP address of the device broadcasting information about itself.    |\n| **Target MAC Address** | ff:ff:ff:ff:ff:ff    | Broadcast MAC address, packet is sent to everyone on the network.  |\n| **Target IP Address**  | 192.168.1.11         | IP address of the device about which information is being broadcast.       |\n\n\n* * *\n\n![14_arp_windows](/images/arp_net/14_arp_windows.png)\n\nAfter Ubuntu sent Gratuitous ARP (G-ARP) indicating its IP and MAC address, Windows received this packet and automatically updated its ARP cache.\n\n* * * \n\n### 4. Dynamic and Static ARP\n\n**Dynamic ARP** - these are entries that a device creates itself, automatically, when it needs to find out another device's MAC address by its IP. Such entries are added to the ARP table by themselves and after some time can be deleted if the address is no longer used.\n\nIn our work, an example of dynamic ARP was when Ubuntu sent Gratuitous ARP for its IP 192.168.1.11. Windows received this packet and automatically added the entry.\n\n---\n\n**Static ARP** - these are entries that are created manually and remain in the table until they're specifically deleted. They're useful for devices with which you always need stable contact, for example, servers, routers, or printers on the network.\n\nFor example, if we manually added an entry for Ubuntu on Windows: **arp -s 192.168.1.11 0c:ef:f7:15:00:00**. then this entry would become static. It won't disappear on its own and will always use this MAC for the specified IP, even if Ubuntu doesn't send packets or G-ARP.","src/content/articles/en/arp.md","19ce39f8c744ae48",{"html":196,"metadata":197},"\u003Cp>\u003Cstrong>ARP (Address Resolution Protocol)\u003C/strong> is a protocol that helps devices in a local network find each other.\u003C/p>\n\u003Cp>Usually we work with IP addresses or domain names (which get converted to IP through DNS). But inside a local network, data is transmitted not by IP, but by MAC addresses. Switches only see MAC addresses and have no idea what IP is.\u003C/p>\n\u003Cp>So before sending data, a device needs to find out: which MAC address corresponds to the needed IP. That’s what ARP does.\u003C/p>\n\u003Cp>It broadcasts a request on the network, gets a response from the needed device, and remembers the IP ↔ MAC correspondence. Thanks to this, devices can exchange data normally, even if the physical address of the recipient was unknown beforehand.\u003C/p>\n\u003Ch3 id=\"1-build-the-topology\">1. Build the Topology\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/arp_net/01_topology.png\" alt=\"01_topology\">\u003C/p>\n\u003Cp>For the lab setup in GNS3, we’ll create a simple network with a Cisco router, a switch, and two virtual machines. The router will have a FastEthernet0/0 interface configured with address \u003Cem>192.168.1.1/24\u003C/em>, which will act as the gateway for all network devices. The switch connects all nodes in one subnet, providing data transmission at the data link layer.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"2-configuring-ip-addresses-on-the-router-and-client-pcs\">2. Configuring IP Addresses on the Router and Client PCs\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/arp_net/02_set_router.png\" alt=\"02_set_router\">\u003C/p>\n\u003Cp>Let’s move on to configuring the Cisco router. First, we select the needed interface, in my case FastEthernet0/0, and assign it an IP address and subnet mask. For the interface in our network, we assign \u003Cem>192.168.1.1/24\u003C/em>. After that, the interface needs to be activated with the \u003Cstrong>no shutdown\u003C/strong> command so it starts working and passing traffic. Now the router is ready to exchange data with devices in the local network.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/arp_net/03_set_windows.png\" alt=\"03_set_windows\">\u003C/p>\n\u003Cp>Now let’s configure the IP address on the Windows 10 client machine. To do this, we open the network adapter settings, select the needed connection, and manually specify the IP address, subnet mask, and gateway. In our example, for Windows we set IP \u003Cem>192.168.1.10\u003C/em>, subnet mask \u003Cem>255.255.255.0\u003C/em>, and for the gateway we specify the router address - \u003Cem>192.168.1.1\u003C/em>. After saving the settings, the computer will be able to exchange data with other network devices and access the local subnet.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/arp_net/04_set_route.png\" alt=\"04_set_route\">\u003C/p>\n\u003Cp>On Linux, we’ll configure the IP address manually through the terminal. In our case, the network interface is called \u003Cstrong>enp2s0\u003C/strong>. To assign a static IP, we use the command \u003Cstrong>sudo ip addr add 192.168.1.11/24 dev enp2s0\u003C/strong>. Next, we need to specify the default gateway through which the device will access the network \u003Cstrong>sudo ip route add default via 192.168.1.1\u003C/strong>. After these actions, the enp2s0 interface gets IP address \u003Cem>192.168.1.11\u003C/em> with subnet mask \u003Cem>255.255.255.0\u003C/em>, and the router \u003Cem>192.168.1.1\u003C/em> acts as the gateway. Now the Ubuntu machine can correctly exchange data with other network devices and interact with the router.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"3-breakdown-of-standard-arp-message-exchange\">3. Breakdown of Standard ARP Message Exchange\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/arp_net/05_empty_arp.png\" alt=\"05_empty_arp\">\u003C/p>\n\u003Cp>Let’s move on to capturing network traffic using Wireshark. For convenience, we filter packets by ARP protocol to see only ARP messages. At the start of the capture, the ARP tables on both hosts are empty, so all requests and responses will be recorded from scratch.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/arp_net/06_arp_d_win.png\" alt=\"06_arp_d_win\">\u003C/p>\n\u003Cp>Before starting the experiment, we’ll clear the ARP cache on both hosts so that all entries are created anew and we can observe the process in real time.\u003C/p>\n\u003Cp>On Windows, this is done through the command line with the \u003Cstrong>arp -d\u003C/strong> command. This command removes all existing ARP entries. Then you can check the table status with \u003Cstrong>arp -a\u003C/strong>.\u003C/p>\n\u003Cp>Initially the table is empty, but after running the ping command to another host, new entries will appear, reflecting the recently resolved MAC addresses\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/arp_net/07_arp_d_linux.png\" alt=\"07_arp_d_linux\">\u003C/p>\n\u003Cp>On Linux, clearing the ARP cache is done with the command \u003Cstrong>sudo ip neigh flush all\u003C/strong>. This command removes all current ARP entries for all interfaces, including enp2s0 in our case. After running it, the system forgets which MAC addresses correspond to which IPs, and all subsequent connections to other network devices will initiate new ARP requests.\u003C/p>\n\u003Cp>To make sure the table is really empty, you can use \u003Cstrong>ip neigh show\u003C/strong>. Initially the output will be empty since the entries are deleted. After the host tries to send data to another device, new entries will appear in the table, reflecting the just-resolved MAC addresses.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/arp_net/08_ping.png\" alt=\"08_ping\">\u003C/p>\n\u003Cp>We send ICMP requests to the Linux machine with IP address \u003Cem>192.168.1.11\u003C/em>, then proceed to analyze the network traffic in Wireshark.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/arp_net/09_wireshark.png\" alt=\"09_wireshark\">\u003C/p>\n\u003Cp>ARP request and ARP response entries appeared in Wireshark.\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"arp-request\">ARP Request\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/arp_net/10_arp_request.png\" alt=\"10_arp_request\">\u003C/p>\n\u003Cp>When a device in a local network wants to send data to another device, it needs to know the recipient’s MAC address. If there’s no entry for this IP in the ARP cache, the system performs the following steps:\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>Step 1:\u003C/strong> Checking the ARP cache. The computer first checks its ARP table. If an entry for the needed IP is missing, it needs to find out the MAC address of the device with that IP.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Step 2:\u003C/strong> Forming the ARP request. The device creates an ARP packet that specifies:\u003C/p>\n\u003Cul>\n\u003Cli>Its own MAC and IP, so the recipient knows who’s asking.\u003C/li>\n\u003Cli>The target IP address - the address whose MAC needs to be found.\u003C/li>\n\u003Cli>The target MAC address is left empty (00:00:00:00:00:00), since it’s not known yet.\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Step 3:\u003C/strong>. Sending the request to all network devices (broadcast)\nThe packet is sent to address ff:ff:ff:ff:ff:ff, meaning to all computers in the local network, so the needed device will definitely receive it.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Step 4:\u003C/strong>. Processing the request by other devices. Each computer checks if its IP matches the target: If it matches, the device forms an ARP response and sends it back to the sender. If it doesn’t match, it ignores the packet.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Step 5\u003C/strong>. Updating the ARP cache. After receiving the response, the sender saves the IP ↔ MAC correspondence in the ARP cache. Now subsequent data transmissions can be done directly, without a new request.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>\u003Cstrong>ARP Request Fields\u003C/strong>\u003C/p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003Ctable>\u003Cthead>\u003Ctr>\u003Cth>Field\u003C/th>\u003Cth>Example Value\u003C/th>\u003Cth>Description\u003C/th>\u003C/tr>\u003C/thead>\u003Ctbody>\u003Ctr>\u003Ctd>\u003Cstrong>Hardware Type\u003C/strong>\u003C/td>\u003Ctd>Ethernet (1)\u003C/td>\u003Ctd>Data link layer type (Ethernet).\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Protocol Type\u003C/strong>\u003C/td>\u003Ctd>IPv4 (0x0800)\u003C/td>\u003Ctd>Upper layer protocol we’re looking for the MAC for (IPv4).\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Hardware Size\u003C/strong>\u003C/td>\u003Ctd>6\u003C/td>\u003Ctd>MAC address length in bytes.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Protocol Size\u003C/strong>\u003C/td>\u003Ctd>4\u003C/td>\u003Ctd>IP address length in bytes.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Opcode\u003C/strong>\u003C/td>\u003Ctd>Request (1)\u003C/td>\u003Ctd>ARP message type: 1 — request.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Sender MAC Address\u003C/strong>\u003C/td>\u003Ctd>0c:e5:1d:02:00:00\u003C/td>\u003Ctd>MAC address of the request sender.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Sender IP Address\u003C/strong>\u003C/td>\u003Ctd>192.168.1.10\u003C/td>\u003Ctd>IP address of the sender.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Target MAC Address\u003C/strong>\u003C/td>\u003Ctd>00:00:00:00:00:00\u003C/td>\u003Ctd>MAC address of the target (not yet known).\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Target IP Address\u003C/strong>\u003C/td>\u003Ctd>192.168.1.11\u003C/td>\u003Ctd>IP address of the device whose MAC address needs to be found.\u003C/td>\u003C/tr>\u003C/tbody>\u003C/table>\n\u003Chr>\n\u003Ch4 id=\"arp-reply\">ARP Reply\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/arp_net/11_arp_reply.png\" alt=\"11_arp_reply\">\u003C/p>\n\u003Cp>When a device receives an ARP request and finds that the IP in the request matches its own, it forms an ARP reply. This message tells the request sender which MAC address corresponds to the requested IP.\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>Step 1:\u003C/strong> Receiving the ARP request. The device receives the ARP request and checks if its IP matches the IP address in the request. If it matches, it prepares a response.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Step 2:\u003C/strong> Forming the ARP reply. The device creates an ARP packet that specifies:\u003C/p>\n\u003Cul>\n\u003Cli>Its own MAC and IP — this is the address and IP of the device that’s responding.\u003C/li>\n\u003Cli>The MAC and IP of the request sender — so the response reaches exactly them.\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Step 3:\u003C/strong> Sending the response directly (unicast). The ARP Reply is sent to the MAC address of the request sender, not to broadcast. The packet goes only to the needed device.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Step 4:\u003C/strong> Updating the ARP cache at the recipient. The computer that sent the request receives the response and records the IP ↔ MAC correspondence in its ARP cache.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Step 5:\u003C/strong> Further data transmission. After recording in the cache, the device can send data directly, without needing a new ARP request.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>\u003Cstrong>ARP Reply Fields\u003C/strong>\u003C/p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003Ctable>\u003Cthead>\u003Ctr>\u003Cth>Field\u003C/th>\u003Cth>Example Value\u003C/th>\u003Cth>Description\u003C/th>\u003C/tr>\u003C/thead>\u003Ctbody>\u003Ctr>\u003Ctd>\u003Cstrong>Hardware Type\u003C/strong>\u003C/td>\u003Ctd>Ethernet (1)\u003C/td>\u003Ctd>Data link layer type (Ethernet).\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Protocol Type\u003C/strong>\u003C/td>\u003Ctd>IPv4 (0x0800)\u003C/td>\u003Ctd>Upper layer protocol (IPv4).\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Hardware Size\u003C/strong>\u003C/td>\u003Ctd>6\u003C/td>\u003Ctd>MAC address length in bytes.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Protocol Size\u003C/strong>\u003C/td>\u003Ctd>4\u003C/td>\u003Ctd>IP address length in bytes.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Opcode\u003C/strong>\u003C/td>\u003Ctd>Reply (2)\u003C/td>\u003Ctd>ARP message type: 2 — reply.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Sender MAC Address\u003C/strong>\u003C/td>\u003Ctd>0c:ef:f7:15:00:00\u003C/td>\u003Ctd>MAC address of the device responding to the request.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Sender IP Address\u003C/strong>\u003C/td>\u003Ctd>192.168.1.11\u003C/td>\u003Ctd>IP address of the device that’s responding.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Target MAC Address\u003C/strong>\u003C/td>\u003Ctd>0c:e5:1d:02:00:00\u003C/td>\u003Ctd>MAC address of the device the reply is intended for.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Target IP Address\u003C/strong>\u003C/td>\u003Ctd>192.168.1.10\u003C/td>\u003Ctd>IP address of the device the reply is intended for.\u003C/td>\u003C/tr>\u003C/tbody>\u003C/table>\n\u003Chr>\n\u003Ch3 id=\"breakdown-of-standard-gratuitous-arp-g-arp-exchange-on-the-network\">Breakdown of Standard Gratuitous ARP (G-ARP) Exchange on the Network\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/arp_net/12_arping_linux_grad.png\" alt=\"12_arping_linux_grad\">\u003C/p>\n\u003Cp>Gratuitous ARP is a special type of ARP message that a device sends about itself, without anyone making a request. In other words, a computer or server itself tells the network: “Here’s my IP and MAC address”. Such packets don’t require a response from other devices — they’re broadcast so that all computers and network equipment in the local network update their ARP caches.\u003C/p>\n\u003Cp>The main purposes of using G-ARP are as follows:\u003C/p>\n\u003Col>\n\u003Cli>\n\u003Cp>Updating other devices’ ARP caches. If the MAC address or IP changed on a device, sending G-ARP allows all network nodes to learn the current data.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Checking if an IP address is taken. A device can send G-ARP to make sure the given IP isn’t being used by another device.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Informing the network when a device starts up. When a computer or server just powered on, G-ARP helps routers, switches, and other hosts quickly learn the correct MAC for its IP.\u003C/p>\n\u003C/li>\n\u003C/ol>\n\u003Cp>In Linux, sending G-ARP is easily done using the \u003Cstrong>arping\u003C/strong> utility. The device sends an ARP Reply to the broadcast address, but doesn’t wait for a response. This approach differs from a standard ARP request, when a computer looks for another host’s MAC address and waits for a response.\u003C/p>\n\u003Cp>For example, if Ubuntu sends a G-ARP for IP 192.168.1.11, it broadcasts a message on the network, announcing its MAC address. All devices in the local network that receive this packet update their ARP caches, even if they didn’t request this address. Thanks to this, subsequent data transmissions can be done directly, without extra requests.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_net/13_g_arp.png\" alt=\"13_g_arp\">\u003C/p>\n\u003Cp>\u003Cstrong>ARP Reply Fields\u003C/strong>\u003C/p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003Ctable>\u003Cthead>\u003Ctr>\u003Cth>Field\u003C/th>\u003Cth>Example Value\u003C/th>\u003Cth>Description\u003C/th>\u003C/tr>\u003C/thead>\u003Ctbody>\u003Ctr>\u003Ctd>\u003Cstrong>Hardware Type\u003C/strong>\u003C/td>\u003Ctd>Ethernet (1)\u003C/td>\u003Ctd>Data link layer type (Ethernet).\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Protocol Type\u003C/strong>\u003C/td>\u003Ctd>IPv4 (0x0800)\u003C/td>\u003Ctd>Upper layer protocol (IPv4).\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Hardware Size\u003C/strong>\u003C/td>\u003Ctd>6\u003C/td>\u003Ctd>MAC address length in bytes.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Protocol Size\u003C/strong>\u003C/td>\u003Ctd>4\u003C/td>\u003Ctd>IP address length in bytes.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Opcode\u003C/strong>\u003C/td>\u003Ctd>Reply (2)\u003C/td>\u003Ctd>ARP message type: 2 — reply. In G-ARP, ARP Reply is used, but without a request.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Sender MAC Address\u003C/strong>\u003C/td>\u003Ctd>0c:ef:f7:15:00:00\u003C/td>\u003Ctd>MAC address of the device broadcasting information about itself.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Sender IP Address\u003C/strong>\u003C/td>\u003Ctd>192.168.1.11\u003C/td>\u003Ctd>IP address of the device broadcasting information about itself.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Target MAC Address\u003C/strong>\u003C/td>\u003Ctd>ff:ff:ff:ff:ff:ff\u003C/td>\u003Ctd>Broadcast MAC address, packet is sent to everyone on the network.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Target IP Address\u003C/strong>\u003C/td>\u003Ctd>192.168.1.11\u003C/td>\u003Ctd>IP address of the device about which information is being broadcast.\u003C/td>\u003C/tr>\u003C/tbody>\u003C/table>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/arp_net/14_arp_windows.png\" alt=\"14_arp_windows\">\u003C/p>\n\u003Cp>After Ubuntu sent Gratuitous ARP (G-ARP) indicating its IP and MAC address, Windows received this packet and automatically updated its ARP cache.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"4-dynamic-and-static-arp\">4. Dynamic and Static ARP\u003C/h3>\n\u003Cp>\u003Cstrong>Dynamic ARP\u003C/strong> - these are entries that a device creates itself, automatically, when it needs to find out another device’s MAC address by its IP. Such entries are added to the ARP table by themselves and after some time can be deleted if the address is no longer used.\u003C/p>\n\u003Cp>In our work, an example of dynamic ARP was when Ubuntu sent Gratuitous ARP for its IP 192.168.1.11. Windows received this packet and automatically added the entry.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cstrong>Static ARP\u003C/strong> - these are entries that are created manually and remain in the table until they’re specifically deleted. They’re useful for devices with which you always need stable contact, for example, servers, routers, or printers on the network.\u003C/p>\n\u003Cp>For example, if we manually added an entry for Ubuntu on Windows: \u003Cstrong>arp -s 192.168.1.11 0c:ef:f7:15:00:00\u003C/strong>. then this entry would become static. It won’t disappear on its own and will always use this MAC for the specified IP, even if Ubuntu doesn’t send packets or G-ARP.\u003C/p>",{"headings":198,"localImagePaths":221,"remoteImagePaths":222,"frontmatter":223,"imagePaths":227},[199,202,205,208,212,215,218],{"depth":30,"slug":200,"text":201},"1-build-the-topology","1. Build the Topology",{"depth":30,"slug":203,"text":204},"2-configuring-ip-addresses-on-the-router-and-client-pcs","2. Configuring IP Addresses on the Router and Client PCs",{"depth":30,"slug":206,"text":207},"3-breakdown-of-standard-arp-message-exchange","3. Breakdown of Standard ARP Message Exchange",{"depth":209,"slug":210,"text":211},4,"arp-request","ARP Request",{"depth":209,"slug":213,"text":214},"arp-reply","ARP Reply",{"depth":30,"slug":216,"text":217},"breakdown-of-standard-gratuitous-arp-g-arp-exchange-on-the-network","Breakdown of Standard Gratuitous ARP (G-ARP) Exchange on the Network",{"depth":30,"slug":219,"text":220},"4-dynamic-and-static-arp","4. Dynamic and Static ARP",[],[],{"title":191,"description":224,"image":225,"date":226},"In this work, we'll take a detailed look at how ARP works, from the principles of ARP request and response exchange, through network traffic analysis using Wireshark","/images/arp_net/arp.jpg","February 9, 2026",[],"en/dhcp",{"id":228,"data":230,"body":232,"filePath":233,"digest":234,"rendered":235},{"title":231},"DHCP: Server Configuration, Relay and Traffic Analysis in Wireshark","In any network, devices need to obtain IP addresses, gateways, and DNS servers to correctly exchange data and have internet access. Of course, everything can be configured manually, but in real life this is inconvenient and often leads to errors. This is where the **DHCP (Dynamic Host Configuration Protocol)** comes in. Its task is simple - to automatically distribute all necessary network parameters to clients, including IP, subnet mask, gateway, and DNS.\n\nIn this work, we'll thoroughly examine how DHCP works, from the **DORA (Discover, Offer, Request, Acknowledge)** message exchange process, through network traffic analysis in Wireshark, to configuring a DHCP server on MikroTik and Ubuntu Server. We'll also look at additional protocol capabilities, such as DHCP Relay, which allows serving clients in other subnets.\n\nFor starters, we'll build a simple network in GNS3. It includes three clients - Windows 10, Ubuntu, and a lightweight VPCS emulator. They all connect to Switch-1, and the switch is linked to a MikroTik router. At this stage, the router will exclusively perform the role of a DHCP server, distributing IP addresses to clients within the network.\n\nThe 192.168.10.0/24 subnet is designed for 254 working hosts. The first address in the network (192.168.10.0) is reserved as the network identifier, and the last (192.168.10.255) is used for broadcast transmissions within the subnet. Accordingly, working addresses are in the range from 192.168.10.1 to 192.168.10.254.\n\n### 1. Build the Topology\n\n![01_topology](/images/dhcp_net/01_topology.png)\n\nFor starters, we'll build a simple network in GNS3. It includes three clients — Windows 10, Ubuntu, and a lightweight VPCS emulator. They all connect to Switch-1, and the switch is linked to a MikroTik router. At this stage, the router will exclusively perform the role of a DHCP server, distributing IP addresses to clients within the network.\n\nThe *192.168.10.0/24* subnet is designed for 254 working hosts. The first address in the network (192.168.10.0) is reserved as the network identifier, and the last (192.168.10.255) is used for broadcast transmissions within the subnet. Accordingly, working addresses are in the range from 192.168.10.1 to 192.168.10.254.\n\n* * *\n\n### 2. Configuring DHCP on MikroTik\n\n![02_mikrotik_admin](/images/dhcp_net/02_mikrotik_admin.png)\n\n![03_mikrotik_password](/images/dhcp_net/03_mikrotik_password.png)\n\nLet's proceed to MikroTik configuration. When launching MikroTik for the first time through the console, the device requests a login and password. By default, the login is **admin**, and there is no password (just press Enter). However, during initial setup, the system requires setting a new password, as an empty password cannot be left - this is because the new password cannot match the current one (i.e., empty) for security access. Therefore, when entering an empty password, an error will appear, and you'll need to enter a password for subsequent login.\n\n* * *\n\n![04_setting_mikrotik](/images/dhcp_net/04_setting_mikrotik.png)\n\nAfter login, the first step is to assign an IP address to the interface through which clients will be connected — in our case, ether1. The IP address is set within the 192.168.10.0/24 subnet, where \"/24\" indicates the subnet mask 255.255.255.0. The subnet mask determines which addresses are considered part of the local network and allows devices to correctly exchange data with each other. Without assigning IP and mask, clients won't be able to interact with the DHCP server.\n\nThe next step is to create an IP address pool — a range of addresses from which the DHCP server will automatically issue IPs to clients. In our case, the pool covers addresses from 192.168.10.10 to 192.168.10.100. Additionally, when configuring DHCP, a DNS server is specified, for example 8.8.8.8, so clients can correctly resolve names on the network and on the Internet. The pool and DNS specification allow centralized management of address distribution, prevent conflicts, and ensure correct operation of all devices. The lease time is set to one day, which allows automatically freeing addresses from devices that are no longer connected and reusing them for new clients.\n\nUsing a pool also simplifies network organization: addresses outside the pool can be reserved for static devices, such as servers or printers, so they don't fall under automatic DHCP assignment. Thus, the pool, subnet mask, and DNS server are key elements of DHCP configuration, ensuring correct, unique, and managed distribution of IP addresses for all clients.\n\n* * *\n\n### 3. DORA Analysis\n\n![05_dora_win](/images/dhcp_net/05_dora_win.png)\n\n* * *\n\n![06_dora_ubuntu](/images/dhcp_net/06_dora_ubuntu.png)\n\n* * *\n\n![07_dora_vpcs](/images/dhcp_net/07_dora_vpcs.png)\n\n* * *\n\n![08_ip_all](/images/dhcp_net/08_ip_all.png)\n\nAfter the DHCP server was brought up and enabled, all devices on the network automatically received their settings. Each client received an IP address that is unique within the pool defined on the server, a subnet mask to understand which addresses belong to the local network, a gateway that will allow devices to access other networks in future tasks, and a DNS server to correctly resolve domain names. In addition, other parameters necessary for normal network operation are transmitted, such as the address lease time.\n\nAll this data is transmitted via the DHCP protocol, and the process of a client obtaining an IP address can be traced through the DORA message sequence: Discover, Offer, Request, and Acknowledgment. First, the client broadcasts a request to obtain an address (Discover), the server responds with an offer of a free IP (Offer), the client confirms the address selection (Request), and the server completes the process by confirming the IP assignment (Acknowledgment). Thanks to this mechanism, devices receive all necessary parameters automatically and are ready to work on the network.\n\nNow let's move on to the DORA process itself and examine each stage in detail using one device as an example to clearly show what exactly happens between the client and server at each step.\n\n* * *\n\n![09_discover](/images/dhcp_net/09_discover.png)\n\nWhen a device connects to the network and doesn't yet have an IP address, it sends **DHCP Discover** — the first step of the DORA process. Simply put, the client informs the network that it's new and wants to receive settings for operation. Let's examine what actually happens at each level.\n\n**Data Link Layer (Ethernet II):** At this level, the packet is sent broadcast with the destination address `ff:ff:ff:ff:ff:ff`, so all devices on the local network receive the message. This is necessary because the client doesn't yet know where the DHCP server is located. The packet source is the client's MAC address, the unique identifier of its network card. Thanks to this, any DHCP server on the network will be able to determine who is making the request and respond to it.\n\n**Network Layer (IP):** The client doesn't yet have an IP address, so `0.0.0.0` is used as the source. The packet destination is `255.255.255.255` to broadcast reach all devices on the local network. This double broadcast (at both data link and network layers) guarantees that Discover will reach all DHCP servers on the subnet, even if there are several.\n\n**Transport Layer (UDP):** The client sends the packet through port 68, and DHCP servers receive it on port 67. UDP is used for connectionless transmission, which simplifies and speeds up the process. Each server on the network gets the opportunity to process the request and offer the client a free IP address.\n\n**Application Layer (DHCP):** The main request information is here. Message type — Discover, which indicates searching for a DHCP server. Transaction ID is unique for this attempt, so the client can match received responses with the sent request. IP fields are still empty, as the client has no address. DHCP options include: Message Type = Discover, Client Identifier (client's MAC), Host Name, Vendor class identifier (for example, MSFT 5.0), and Parameter Request List with a list of necessary settings — subnet mask, gateway, DNS, and other parameters. Discover informs servers about the presence of a new client and its needs, allowing the address and network settings provision process to begin.\n\nSo, **Discover** is simply the client's request to receive IP and other settings. The server doesn't distribute anything yet, it only receives information about who connected and what exactly this device needs.\n\n* * *\n\n![10_offer](/images/dhcp_net/10_offer.png)\n\nWhen the DHCP server receives Discover from the client, it responds with **DHCP Offer** — the second step of the DORA process. The server offers the client a specific IP address and necessary network parameters. The packet is sent unicast so the selected client receives the offer directly, and other servers understand that the address is taken.\n\n**Data Link Layer (Ethernet II):** At this level, the packet is addressed directly to the client's MAC address (`0e:2a:b0:14:00:00`). The source is the server's MAC address (`0c:63:76:e4:00:00`). Unlike Discover, this is not a broadcast but unicast, so the server can directly tell the client which IP it's offering.\n\n**Network Layer (IP):** The packet source is the DHCP server's IP (192.168.10.1), and the destination is the IP the server is offering to the client (192.168.10.100). At this level, the server \"offers\" the client an address that it can use once it confirms the selection.\n\n**Transport Layer (UDP):** The server uses port 67 as the source, and the client receives on port 68. UDP allows quick packet transmission without establishing a connection and guarantees that the client will receive the server's offer.\n\n**Application Layer (DHCP):** Message type — Offer, Transaction ID matches Discover so the client can match the response with the sent request. The main field — Your (Client) IP address — contains the offered address (192.168.10.100). DHCP options include Server Identifier (192.168.10.1), IP Address Lease Time, Subnet Mask, Router, DNS, and Domain Name. These parameters allow the client to know what network settings it will receive when accepting the address.\n\n**Summary:** DHCP Offer is a specific offer from the server to the client with IP and network parameters. At this stage, the client can accept the offer and move to the next step — DHCP Request, to finally secure the address.\n\n* * *\n\n![11_request](/images/dhcp_net/11_request.png)\n\nAfter the client receives an offer from the server (**Offer**), it sends **DHCP Request** — the third step of the DORA process. In this packet, the client confirms its IP choice and notifies the network that it's going to use the offered address. The packet is sent broadcast so the selected server understands that its offer is accepted, and other DHCP servers can free their offers.\n\n**Data Link Layer (Ethernet II):** The packet is addressed to all network devices (`ff:ff:ff:ff:ff:ff`), which allows the selected server to see the confirmation, and other servers to understand that their offers are rejected and addresses can return to the pool. The source is the client's MAC address (`0e:2a:b0:14:00:00`), the unique identifier of its network interface.\n\n**Network Layer (IP):** The packet source is `0.0.0.0`, as the client hasn't yet received a finally assigned IP. The destination is `255.255.255.255` to deliver the packet to all devices on the local network. This broadcast ensures that the packet reaches the selected server and all other servers, if any exist on the network.\n\n**Transport Layer (UDP):** The client uses port 68 as the source, and the server listens on port 67 as the destination. UDP allows quick packet transmission without establishing a connection, ensuring message delivery to all DHCP servers on the network.\n\n**Application Layer (DHCP):** Message type — Request, Transaction ID matches Discover and Offer, linking the entire DORA transaction. IP fields are still empty, as the address lease is not finally confirmed. DHCP options include Message Type = Request, Server Identifier = 192.168.10.1, Requested IP = 192.168.10.100, Client Identifier = client's MAC, Host Name = MSEDGEWIN10, Vendor class = MSFT 5.0, and Parameter Request List with subnet mask, gateway, DNS, and other parameters for the final ACK.\n\n**Summary:** DHCP Request notifies the network about accepting the server's offer. The client is ready to receive final confirmation, after which the IP and network settings will become valid, which will happen at the next step — DHCP Acknowledgment.\n\n* * *\n\n![12_ack](/images/dhcp_net/12_ack.png)\n\nAfter the client sends **Request**, the server confirms the final selection of IP address and network parameters using **DHCP ACK** — the fourth and final step of the DORA process. This packet officially assigns the client the IP and all network settings, after which the device can begin full-fledged work on the local network.\n\n**Data Link Layer (Ethernet II):** At this level, the packet is sent directly to the client (unicast) to MAC address `0e:2a:b0:14:00:00`. The source is the DHCP server's MAC address (`0c:63:76:e4:00:00`). Unicast is used to accurately deliver confirmation of the selected address to a specific device and exclude unnecessary broadcasting.\n\n**Network Layer (IP):** The packet source is the DHCP server's IP (192.168.10.1), and the destination is the IP now officially assigned to the client (192.168.10.100). At this level, the packet is already addressed directly to the assigned IP, which differs from previous steps where the client's IP was not yet known.\n\n**Transport Layer (UDP):** The server uses port 67 as the source, and the client receives on port 68. UDP ensures fast delivery without establishing a connection and guarantees that the client receives all network parameters for correct operation.\n\n**Application Layer (DHCP):** Message type — ACK, Transaction ID matches previous Discover, Offer, and Request packets, linking the entire DORA transaction. The Your (Client) IP address field contains the assigned IP (192.168.10.100). DHCP options include final parameters: Subnet Mask (255.255.255.0), Router (192.168.10.1), DNS server (8.8.8.8), IP Address Lease Time (1 day), Server Identifier (192.168.10.1), and end of list (Option 255). The client applies these settings to its network interface, after which it can fully work on the network, including access to external resources through the specified gateway and using DNS for domain name resolution.\n\n**Summary:** DHCP ACK completes the DORA process, officially assigning the client an IP address and network parameters. After receiving this packet, the device is ready to work on the local network with correct configuration and the ability to access other networks.\n\n* * *\n\n![13_mikrotik](/images/dhcp_net/13_mikrotik_lease_print.png)\n\nThe `ip dhcp-server lease print` command on MikroTik shows which IP addresses the DHCP server has currently issued to devices on the network. In our case, the dhcp1 server distributed addresses to three devices: Windows, Ubuntu, and VPCS.\n\nThe table shows that each device is assigned a unique IP from the pool, its MAC address and host name are indicated. The bound status means the lease is active — that is, the device is currently using this IP and can fully work on the network. For example, Windows received 192.168.10.100, Ubuntu — 192.168.10.99, and VPCS — 192.168.10.98.\n\nThe DHCP server successfully performed its work: all three devices automatically received IP, subnet mask, gateway, and other necessary network parameters. They can now exchange data on the local network and in the future use the gateway to access other subnets or the internet.\n\n* * *\n\n### 4. Analysis of Additional DHCP Messages\n\n#### Release\n\n![14_release_win](/images/dhcp_net/14_release_win.png)\n\n* * *\n\n![15_release_wireshark](/images/dhcp_net/15_release_wireshark.png)\n\n* * *\n\nWhen the `ipconfig /release` command is executed on a Windows client computer, the device tells the DHCP server that it no longer needs the leased IP address. In our example, the client sends **DHCP Release** to server 192.168.10.1, freeing address 192.168.10.100. This means the server can return this IP back to the pool of free addresses so other devices can use it.\n\nOn the client, after executing the command, the IPv4 address disappears, gateway and DNS server are no longer assigned. The client cannot exchange data beyond the local network until it receives an address through DHCP again. IPv6 addresses remain, as the command only affects IPv4.\n\nThe Release network packet is sent **unicast** directly to the server (not broadcast). The source is the client's old IP (192.168.10.100), and the destination is the server's IP (192.168.10.1). The packet specifies the message type (Release), client identifier (MAC), and server identifier so DHCP knows exactly which lease to terminate.\n\nOn the MikroTik server, after receiving this packet, the lease record for the client is immediately updated: the address returns to the available pool, and the lease status changes from `bound` to `released` (or the record is deleted from the active leases list).\n\nSimply put, **DHCP Release** is the client's way to correctly \"return\" the IP to the server, ending the use of the address. Thus, the address is no longer occupied, and the server can issue it to another device.\n\n* * *\n\n#### NAK\n\n![16_nak_wireshark](/images/dhcp_net/16_nak_wireshark.png)\n\nAfter the Windows client freed IP address 192.168.10.100 using the **ipconfig /release** command, the server returned this address to the free pool. Later, the DHCP pool was changed with the command `/ip pool set dhcp_pool ranges=192.168.10.10-192.168.10.99` and now includes only addresses **192.168.10.10–192.168.10.99**. When Windows tried to obtain IP 192.168.10.100 again, the server responded with a negative acknowledgment — **DHCP NAK**. This message tells the client that the requested address is invalid and cannot be used.\n\nDHCP NAK is broadcast to guarantee that the client receives the notification. In the message, the server indicates which IP cannot be used and its identifier so the client clearly understands this is the response from the needed server. Upon receiving NAK, the client immediately stops using the old IP and starts the process of obtaining a new address from scratch: first sends Discover, then receives Offer, confirms with Request, and receives ACK with a new IP. In our case, Windows received address **192.168.10.97**, which is included in the current pool.\n\nThe reasons why a server might send NAK are varied. The most common is that the client requested an address that is no longer in the pool or is already occupied by another device. NAK can also occur if the client tries to renew the lease of an old IP that the server no longer recognizes, or if it specified the wrong server for lease renewal. Overall, DHCP NAK is a protection mechanism that prevents IP address conflicts and guarantees that devices use only valid addresses from the current pool.\n\n* * *\n\n#### INFORM\n\nAfter a device has already received an IP address and other settings through DHCP, sometimes there's a need to request only additional network parameters from the DHCP server without changing the IP. The DHCP INFORM message is used for this. The client sends it to the server to receive, for example, current DNS servers, domain name, or other options that may change on the network without affecting its current IP.\n\nThe INFORM message is sent from the IP address already assigned to the device, and the server responds with a regular DHCP ACK containing the requested parameters. This is useful if DNS settings, gateways, or other service parameters have been updated on the network, and the client needs to receive them without requesting a new IP.\n\nUnlike Discover, Request, or Release, INFORM doesn't participate in IP address assignment but only serves to obtain information. Commands on Windows: `ipconfig /renew`, on Linux: `dhclient -1 -v -s 192.168.10.1>`\n\n* * *\n\n#### Decline\n\nThe **DHCP DECLINE** message is used by the client when it discovers that the IP address offered by the DHCP server is already occupied by another device. For example, the client received an Offer with address 192.168.10.50, but an ARP check showed that this address is already being used by another host. In this case, the client cannot safely use the IP and sends a DECLINE message to the server to notify about the conflict.\n\nAfter receiving DECLINE, the server marks this address as unavailable and no longer issues it to other clients until the administrator or server resolves the conflict issue. Thus, DHCP DECLINE prevents IP address conflicts on the network and ensures correct operation of all devices.\n\nIt's important to note that with DECLINE, the client **doesn't lose its current working IP** if it's already using some other address. This is purely a protective mechanism for handling offers from the server that could potentially cause a conflict.\n\nUsage example: Windows and Linux automatically send DECLINE if they detect an IP match on the network through ARP when checking an Offer.\n\n* * *\n\n### 5. Static IP Binding\n\n![17_fixed_ip](/images/dhcp_net/17_fixed_ip_ubuntu.png)\n\n* * *\n\n![18_fixed_ip_ubuntu_wireshark](/images/dhcp_net/18_fixed_ip_ubuntu_wireshark.png)\n\n* * *\n\n![19_fixed_ip_mikrotik](/images/dhcp_net/19_fixed_ip_mikrotik.png)\n\nIn DHCP, there's a capability to **assign a specific IP address to a particular device** using its MAC address. This mechanism is called **Static Lease** and allows guaranteeing that the selected client will always receive the same address, regardless of the dynamic pool.\n\nIn practice, this is done as follows: the administrator on MikroTik manually creates a record where they specify the IP address, client's MAC address, DHCP server name, and a comment for convenience. In our case, the Ubuntu virtual machine with MAC `0c:a2:21:ee:00:00` was assigned static IP `192.168.10.105`. The configuration command looks as follows: `/ip dhcp-server lease add address=192.168.10.105 mac-address=0c:a2:21:ee:00:00 comment=\"Ubuntu fixed IP\" server=dhcp1`\n\nAfter applying this setting, the DHCP server will never issue this IP to another device. If the client with the specified MAC tries to use a different address from the pool, the server will send NAK, and the client will be forced to request a new configuration. In our example, Ubuntu first received a refusal, and then, through the standard DORA process, correctly received its assigned address 192.168.10.105.\n\n* * *\n\n### 6. Configuring DHCP on Ubuntu\n\n![20_topology2](/images/dhcp_net/20_topology_2.png)\n\n* * *\n\n![21_disable_dhcp](/images/dhcp_net/21_disable_dhcp_mikrotik.png)\n\nWe're moving the DHCP server from MikroTik to Ubuntu. Previously, addresses were distributed by MikroTik with IP 192.168.10.1, now it will be a dedicated Ubuntu server. First, we disable DHCP on MikroTik so clients no longer receive IPs from it.\n\n* * *\n\n![22_isc_dhcp_server](/images/dhcp_net/22_isc_dhcp_server.png)\n\nFirst, you need to make sure the package itself is installed. If not, install it with the command: `sudo apt install isc-dhcp-server`. After installation, you need to tell the server which network interface to listen for client requests on. This is done in the `/etc/default/isc-dhcp-server` file. Open it and edit the line: `INTERFACESv4=\"ens3\"`. **ens3** is the name of my network interface, yours may be different.\n\n* * *\n\n![23_dhcpd](/images/dhcp_net/23_dhcpd.png)\n\nNext, we go to the main configuration file `/etc/dhcp/dhcpd.conf`. There we set network parameters: pool of issued addresses, gateway, DNS, and lease time.\nSo now the server knows which addresses to distribute to whom, through which gateway, which DNS to provide, and for how long to issue the lease.\n\n* * *\n\n![24_restart_isc](/images/dhcp_net/24_restart_isc_dhcp.png)\n\nWe assign the server a static IP **192.168.10.2/24**. Now Ubuntu Server is ready to issue IP addresses to clients. Start the service with the command `sudo systemctl start isc-dhcp-server`. To check the status: `sudo systemctl status isc-dhcp-server`\n\n* * *\n\n![25_requested_ip](/images/dhcp_net/25_requested_ip_win.png)\n\n* * *\n\n![26_requested_ip_ubuntu](/images/dhcp_net/26_requested_ip_ubuntu.png)\n\nWhen clients start communicating with the new server, here's what happens: Windows tried to take its old address 192.168.10.97 — the server confirmed it because the address was free in the new pool. But the Ubuntu client, which previously had static address 192.168.10.105 on MikroTik, can no longer obtain it, as the address is not included in the new range. The server ignores this request, and the client sends Discover again, receives Offer, makes Request, and ultimately receives a new address from the pool — 192.168.10.12.\n\n* * *\n\n![27_ubuntuserver_print](/images/dhcp_net/27_ubuntuserver_print.png)\n\nIn the end, checking the lease table shows: Windows kept its old address, Ubuntu received a new one, and vpc also received its IP from the new range.\n\n* * *\n\n### 7. Configuring DHCP Relay\n\n![28_topology_3](/images/dhcp_net/28_topology_3.png)\n\nOur network now has two subnets: the old 192.168.10.0/24 and the new 172.16.10.0/24. The DHCP server (Ubuntu Server, 192.168.10.2) currently only knows the pool for the first subnet. That is, if clients from the new subnet (PC2, PC3) send DHCP Discover, the server simply doesn't see them — broadcast packets don't cross the router.\n\nTo fix this, we use MikroTik as DHCP Relay and configure routing.\n\n* * *\n\n#### 1. Configuring Routing on MikroTik\n\n![29_route_mikroik](/images/dhcp_net/29_route_mikrotik.png)\n\nOn interface ether2, which faces the new subnet 172.16.10.0/24, we assign IP address 172.16.10.1/24. Now the router knows that packets destined for this subnet go through ether2 and can correctly route traffic between networks. Routing is also needed for the return path: when the DHCP server responds, the packet should get back to 172.16.10.0/24.\n\n* * *\n\n#### 2. Configuring DHCP Relay on MikroTik\n\n![30_dhcp_relay](/images/dhcp_net/30_dhcp_relay.png)\n\nDHCP Relay is a mechanism that allows clients from one subnet to contact a server in another subnet, even if the server is not in the same broadcast domain. Relay \"listens\" for DHCP packets on the client network interface and forwards them to the server as regular unicast packets.\n\nOn MikroTik it looks like this:\n\n`/ip dhcp-relay add name=relay1 interface=ether2 dhcp-server=192.168.10.2 local-address=172.16.10.1\n/ip dhcp-relay enable relay1`\n\n- `interface=ether2` — the interface where the new subnet and clients whose packets need to be intercepted are located.\n- `dhcp-server=192.168.10.2` — the server's IP to which requests will be forwarded.\n- `local-address=172.16.10.1` — MikroTik's IP in the client subnet, which will be indicated as the source of responses for the client. Without local-address, Offer/ACK packets returned by the server may not reach the client because the client doesn't know how to route them through another subnet.\n- `enable relay1` — activates the previously created relay named relay1.\n\n* * *\n\n![31_cant_find](/images/dhcp_net/31_cant_find_pc2.png)\n\n* * *\n\n![32_add_subnet](/images/dhcp_net/32_add_subnet.png)\n\nWhile the server only knows network 192.168.10.0/24, Relay will \"deliver\" Discover to the server, but the server won't be able to issue an address, and the client will remain without an IP. Therefore, before starting Relay, you need to add the new subnet to the DHCP server configuration (/etc/dhcp/dhcpd.conf):\n\n* * *\n\n![33_pc2_pc3](/images/dhcp_net/33_pc2_pc3.png)\n\n* * *\n\n![34_offer_pc2](/images/dhcp_net/34_offer_pc2.png)\n\nPC1 and PC2 received addresses. Let's analyze DHCP Offer for client PC2. The Ubuntu server itself wants to issue the client an address from its pool in the first subnet, but the client is located in the second subnet 172.16.10.0/24. The packet reaches the client through MikroTik, which acts as DHCP Relay. The router substitutes its local IP 172.16.10.1 as the source so the packet correctly reaches the client, who has no direct route to the server. The packet destination is IP 172.16.10.10, which the server is offering to the client. The Next Server IP Address field remains 192.168.10.2, showing that the real DHCP server is located in the first subnet. That is, the packet visually goes \"from\" MikroTik, but in fact it's an offer from the Ubuntu server, and this mechanism allows a client in an isolated subnet to receive an IP address and network parameters.\n\n* * *\n\n#### 3. How Packets Pass Through Relay (Step-by-Step Breakdown)\n\n* **Step 1: Discover from Client (PC2/PC3)**  \n    The client from subnet 172.16.10.0/24 sends DHCP Discover broadcast (`ff:ff:ff:ff:ff:ff`). It's looking for any DHCP server. But since the server is in a different subnet, the packet won't reach directly.\n\n* **Step 2: Packet Interception by MikroTik**  \n    DHCP Relay on MikroTik \"catches\" this Discover on ether2. Relay reads the packet and substitutes a new destination IP address — the DHCP server's IP (192.168.10.2). The packet is now sent as unicast from MikroTik to the server.\n\n* **Step 3: Server Receives Discover**  \n    The Ubuntu DHCP server receives the packet. Currently the server only knows the pool for 192.168.10.0/24, so it cannot issue an address for 172.16.10.0/24. Relay can optionally add option 82 (Agent Information) so the server understands which subnet the client came from and which pool to use.\n\n* **Step 4: Offer from Server**  \n    The server forms DHCP Offer for the client. If the pool for 172.16.10.0/24 is already added, the server selects a free IP from this pool and sends the packet back to the IP from which Discover came (MikroTik).\n\n* **Step 5: MikroTik Delivers Offer to Client**  \n    When the packet returns to MikroTik, it changes the source IP address to its interface in the client subnet (172.16.10.1) so the client can receive the response, and forwards the Offer to the client.\n\n* **Step 6: Request and ACK**  \n    The client responds with DHCP Request, the server confirms with DHCP ACK — the entire DORA process completely passes through Relay. The client receives IP address, gateway, and DNS, as if the server is in its subnet.","src/content/articles/en/dhcp.md","39c10e98cec61498",{"html":236,"metadata":237},"\u003Cp>In any network, devices need to obtain IP addresses, gateways, and DNS servers to correctly exchange data and have internet access. Of course, everything can be configured manually, but in real life this is inconvenient and often leads to errors. This is where the \u003Cstrong>DHCP (Dynamic Host Configuration Protocol)\u003C/strong> comes in. Its task is simple - to automatically distribute all necessary network parameters to clients, including IP, subnet mask, gateway, and DNS.\u003C/p>\n\u003Cp>In this work, we’ll thoroughly examine how DHCP works, from the \u003Cstrong>DORA (Discover, Offer, Request, Acknowledge)\u003C/strong> message exchange process, through network traffic analysis in Wireshark, to configuring a DHCP server on MikroTik and Ubuntu Server. We’ll also look at additional protocol capabilities, such as DHCP Relay, which allows serving clients in other subnets.\u003C/p>\n\u003Cp>For starters, we’ll build a simple network in GNS3. It includes three clients - Windows 10, Ubuntu, and a lightweight VPCS emulator. They all connect to Switch-1, and the switch is linked to a MikroTik router. At this stage, the router will exclusively perform the role of a DHCP server, distributing IP addresses to clients within the network.\u003C/p>\n\u003Cp>The 192.168.10.0/24 subnet is designed for 254 working hosts. The first address in the network (192.168.10.0) is reserved as the network identifier, and the last (192.168.10.255) is used for broadcast transmissions within the subnet. Accordingly, working addresses are in the range from 192.168.10.1 to 192.168.10.254.\u003C/p>\n\u003Ch3 id=\"1-build-the-topology\">1. Build the Topology\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/01_topology.png\" alt=\"01_topology\">\u003C/p>\n\u003Cp>For starters, we’ll build a simple network in GNS3. It includes three clients — Windows 10, Ubuntu, and a lightweight VPCS emulator. They all connect to Switch-1, and the switch is linked to a MikroTik router. At this stage, the router will exclusively perform the role of a DHCP server, distributing IP addresses to clients within the network.\u003C/p>\n\u003Cp>The \u003Cem>192.168.10.0/24\u003C/em> subnet is designed for 254 working hosts. The first address in the network (192.168.10.0) is reserved as the network identifier, and the last (192.168.10.255) is used for broadcast transmissions within the subnet. Accordingly, working addresses are in the range from 192.168.10.1 to 192.168.10.254.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"2-configuring-dhcp-on-mikrotik\">2. Configuring DHCP on MikroTik\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/02_mikrotik_admin.png\" alt=\"02_mikrotik_admin\">\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/03_mikrotik_password.png\" alt=\"03_mikrotik_password\">\u003C/p>\n\u003Cp>Let’s proceed to MikroTik configuration. When launching MikroTik for the first time through the console, the device requests a login and password. By default, the login is \u003Cstrong>admin\u003C/strong>, and there is no password (just press Enter). However, during initial setup, the system requires setting a new password, as an empty password cannot be left - this is because the new password cannot match the current one (i.e., empty) for security access. Therefore, when entering an empty password, an error will appear, and you’ll need to enter a password for subsequent login.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/04_setting_mikrotik.png\" alt=\"04_setting_mikrotik\">\u003C/p>\n\u003Cp>After login, the first step is to assign an IP address to the interface through which clients will be connected — in our case, ether1. The IP address is set within the 192.168.10.0/24 subnet, where “/24” indicates the subnet mask 255.255.255.0. The subnet mask determines which addresses are considered part of the local network and allows devices to correctly exchange data with each other. Without assigning IP and mask, clients won’t be able to interact with the DHCP server.\u003C/p>\n\u003Cp>The next step is to create an IP address pool — a range of addresses from which the DHCP server will automatically issue IPs to clients. In our case, the pool covers addresses from 192.168.10.10 to 192.168.10.100. Additionally, when configuring DHCP, a DNS server is specified, for example 8.8.8.8, so clients can correctly resolve names on the network and on the Internet. The pool and DNS specification allow centralized management of address distribution, prevent conflicts, and ensure correct operation of all devices. The lease time is set to one day, which allows automatically freeing addresses from devices that are no longer connected and reusing them for new clients.\u003C/p>\n\u003Cp>Using a pool also simplifies network organization: addresses outside the pool can be reserved for static devices, such as servers or printers, so they don’t fall under automatic DHCP assignment. Thus, the pool, subnet mask, and DNS server are key elements of DHCP configuration, ensuring correct, unique, and managed distribution of IP addresses for all clients.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"3-dora-analysis\">3. DORA Analysis\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/05_dora_win.png\" alt=\"05_dora_win\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/06_dora_ubuntu.png\" alt=\"06_dora_ubuntu\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/07_dora_vpcs.png\" alt=\"07_dora_vpcs\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/08_ip_all.png\" alt=\"08_ip_all\">\u003C/p>\n\u003Cp>After the DHCP server was brought up and enabled, all devices on the network automatically received their settings. Each client received an IP address that is unique within the pool defined on the server, a subnet mask to understand which addresses belong to the local network, a gateway that will allow devices to access other networks in future tasks, and a DNS server to correctly resolve domain names. In addition, other parameters necessary for normal network operation are transmitted, such as the address lease time.\u003C/p>\n\u003Cp>All this data is transmitted via the DHCP protocol, and the process of a client obtaining an IP address can be traced through the DORA message sequence: Discover, Offer, Request, and Acknowledgment. First, the client broadcasts a request to obtain an address (Discover), the server responds with an offer of a free IP (Offer), the client confirms the address selection (Request), and the server completes the process by confirming the IP assignment (Acknowledgment). Thanks to this mechanism, devices receive all necessary parameters automatically and are ready to work on the network.\u003C/p>\n\u003Cp>Now let’s move on to the DORA process itself and examine each stage in detail using one device as an example to clearly show what exactly happens between the client and server at each step.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/09_discover.png\" alt=\"09_discover\">\u003C/p>\n\u003Cp>When a device connects to the network and doesn’t yet have an IP address, it sends \u003Cstrong>DHCP Discover\u003C/strong> — the first step of the DORA process. Simply put, the client informs the network that it’s new and wants to receive settings for operation. Let’s examine what actually happens at each level.\u003C/p>\n\u003Cp>\u003Cstrong>Data Link Layer (Ethernet II):\u003C/strong> At this level, the packet is sent broadcast with the destination address \u003Ccode>ff:ff:ff:ff:ff:ff\u003C/code>, so all devices on the local network receive the message. This is necessary because the client doesn’t yet know where the DHCP server is located. The packet source is the client’s MAC address, the unique identifier of its network card. Thanks to this, any DHCP server on the network will be able to determine who is making the request and respond to it.\u003C/p>\n\u003Cp>\u003Cstrong>Network Layer (IP):\u003C/strong> The client doesn’t yet have an IP address, so \u003Ccode>0.0.0.0\u003C/code> is used as the source. The packet destination is \u003Ccode>255.255.255.255\u003C/code> to broadcast reach all devices on the local network. This double broadcast (at both data link and network layers) guarantees that Discover will reach all DHCP servers on the subnet, even if there are several.\u003C/p>\n\u003Cp>\u003Cstrong>Transport Layer (UDP):\u003C/strong> The client sends the packet through port 68, and DHCP servers receive it on port 67. UDP is used for connectionless transmission, which simplifies and speeds up the process. Each server on the network gets the opportunity to process the request and offer the client a free IP address.\u003C/p>\n\u003Cp>\u003Cstrong>Application Layer (DHCP):\u003C/strong> The main request information is here. Message type — Discover, which indicates searching for a DHCP server. Transaction ID is unique for this attempt, so the client can match received responses with the sent request. IP fields are still empty, as the client has no address. DHCP options include: Message Type = Discover, Client Identifier (client’s MAC), Host Name, Vendor class identifier (for example, MSFT 5.0), and Parameter Request List with a list of necessary settings — subnet mask, gateway, DNS, and other parameters. Discover informs servers about the presence of a new client and its needs, allowing the address and network settings provision process to begin.\u003C/p>\n\u003Cp>So, \u003Cstrong>Discover\u003C/strong> is simply the client’s request to receive IP and other settings. The server doesn’t distribute anything yet, it only receives information about who connected and what exactly this device needs.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/10_offer.png\" alt=\"10_offer\">\u003C/p>\n\u003Cp>When the DHCP server receives Discover from the client, it responds with \u003Cstrong>DHCP Offer\u003C/strong> — the second step of the DORA process. The server offers the client a specific IP address and necessary network parameters. The packet is sent unicast so the selected client receives the offer directly, and other servers understand that the address is taken.\u003C/p>\n\u003Cp>\u003Cstrong>Data Link Layer (Ethernet II):\u003C/strong> At this level, the packet is addressed directly to the client’s MAC address (\u003Ccode>0e:2a:b0:14:00:00\u003C/code>). The source is the server’s MAC address (\u003Ccode>0c:63:76:e4:00:00\u003C/code>). Unlike Discover, this is not a broadcast but unicast, so the server can directly tell the client which IP it’s offering.\u003C/p>\n\u003Cp>\u003Cstrong>Network Layer (IP):\u003C/strong> The packet source is the DHCP server’s IP (192.168.10.1), and the destination is the IP the server is offering to the client (192.168.10.100). At this level, the server “offers” the client an address that it can use once it confirms the selection.\u003C/p>\n\u003Cp>\u003Cstrong>Transport Layer (UDP):\u003C/strong> The server uses port 67 as the source, and the client receives on port 68. UDP allows quick packet transmission without establishing a connection and guarantees that the client will receive the server’s offer.\u003C/p>\n\u003Cp>\u003Cstrong>Application Layer (DHCP):\u003C/strong> Message type — Offer, Transaction ID matches Discover so the client can match the response with the sent request. The main field — Your (Client) IP address — contains the offered address (192.168.10.100). DHCP options include Server Identifier (192.168.10.1), IP Address Lease Time, Subnet Mask, Router, DNS, and Domain Name. These parameters allow the client to know what network settings it will receive when accepting the address.\u003C/p>\n\u003Cp>\u003Cstrong>Summary:\u003C/strong> DHCP Offer is a specific offer from the server to the client with IP and network parameters. At this stage, the client can accept the offer and move to the next step — DHCP Request, to finally secure the address.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/11_request.png\" alt=\"11_request\">\u003C/p>\n\u003Cp>After the client receives an offer from the server (\u003Cstrong>Offer\u003C/strong>), it sends \u003Cstrong>DHCP Request\u003C/strong> — the third step of the DORA process. In this packet, the client confirms its IP choice and notifies the network that it’s going to use the offered address. The packet is sent broadcast so the selected server understands that its offer is accepted, and other DHCP servers can free their offers.\u003C/p>\n\u003Cp>\u003Cstrong>Data Link Layer (Ethernet II):\u003C/strong> The packet is addressed to all network devices (\u003Ccode>ff:ff:ff:ff:ff:ff\u003C/code>), which allows the selected server to see the confirmation, and other servers to understand that their offers are rejected and addresses can return to the pool. The source is the client’s MAC address (\u003Ccode>0e:2a:b0:14:00:00\u003C/code>), the unique identifier of its network interface.\u003C/p>\n\u003Cp>\u003Cstrong>Network Layer (IP):\u003C/strong> The packet source is \u003Ccode>0.0.0.0\u003C/code>, as the client hasn’t yet received a finally assigned IP. The destination is \u003Ccode>255.255.255.255\u003C/code> to deliver the packet to all devices on the local network. This broadcast ensures that the packet reaches the selected server and all other servers, if any exist on the network.\u003C/p>\n\u003Cp>\u003Cstrong>Transport Layer (UDP):\u003C/strong> The client uses port 68 as the source, and the server listens on port 67 as the destination. UDP allows quick packet transmission without establishing a connection, ensuring message delivery to all DHCP servers on the network.\u003C/p>\n\u003Cp>\u003Cstrong>Application Layer (DHCP):\u003C/strong> Message type — Request, Transaction ID matches Discover and Offer, linking the entire DORA transaction. IP fields are still empty, as the address lease is not finally confirmed. DHCP options include Message Type = Request, Server Identifier = 192.168.10.1, Requested IP = 192.168.10.100, Client Identifier = client’s MAC, Host Name = MSEDGEWIN10, Vendor class = MSFT 5.0, and Parameter Request List with subnet mask, gateway, DNS, and other parameters for the final ACK.\u003C/p>\n\u003Cp>\u003Cstrong>Summary:\u003C/strong> DHCP Request notifies the network about accepting the server’s offer. The client is ready to receive final confirmation, after which the IP and network settings will become valid, which will happen at the next step — DHCP Acknowledgment.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/12_ack.png\" alt=\"12_ack\">\u003C/p>\n\u003Cp>After the client sends \u003Cstrong>Request\u003C/strong>, the server confirms the final selection of IP address and network parameters using \u003Cstrong>DHCP ACK\u003C/strong> — the fourth and final step of the DORA process. This packet officially assigns the client the IP and all network settings, after which the device can begin full-fledged work on the local network.\u003C/p>\n\u003Cp>\u003Cstrong>Data Link Layer (Ethernet II):\u003C/strong> At this level, the packet is sent directly to the client (unicast) to MAC address \u003Ccode>0e:2a:b0:14:00:00\u003C/code>. The source is the DHCP server’s MAC address (\u003Ccode>0c:63:76:e4:00:00\u003C/code>). Unicast is used to accurately deliver confirmation of the selected address to a specific device and exclude unnecessary broadcasting.\u003C/p>\n\u003Cp>\u003Cstrong>Network Layer (IP):\u003C/strong> The packet source is the DHCP server’s IP (192.168.10.1), and the destination is the IP now officially assigned to the client (192.168.10.100). At this level, the packet is already addressed directly to the assigned IP, which differs from previous steps where the client’s IP was not yet known.\u003C/p>\n\u003Cp>\u003Cstrong>Transport Layer (UDP):\u003C/strong> The server uses port 67 as the source, and the client receives on port 68. UDP ensures fast delivery without establishing a connection and guarantees that the client receives all network parameters for correct operation.\u003C/p>\n\u003Cp>\u003Cstrong>Application Layer (DHCP):\u003C/strong> Message type — ACK, Transaction ID matches previous Discover, Offer, and Request packets, linking the entire DORA transaction. The Your (Client) IP address field contains the assigned IP (192.168.10.100). DHCP options include final parameters: Subnet Mask (255.255.255.0), Router (192.168.10.1), DNS server (8.8.8.8), IP Address Lease Time (1 day), Server Identifier (192.168.10.1), and end of list (Option 255). The client applies these settings to its network interface, after which it can fully work on the network, including access to external resources through the specified gateway and using DNS for domain name resolution.\u003C/p>\n\u003Cp>\u003Cstrong>Summary:\u003C/strong> DHCP ACK completes the DORA process, officially assigning the client an IP address and network parameters. After receiving this packet, the device is ready to work on the local network with correct configuration and the ability to access other networks.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/13_mikrotik_lease_print.png\" alt=\"13_mikrotik\">\u003C/p>\n\u003Cp>The \u003Ccode>ip dhcp-server lease print\u003C/code> command on MikroTik shows which IP addresses the DHCP server has currently issued to devices on the network. In our case, the dhcp1 server distributed addresses to three devices: Windows, Ubuntu, and VPCS.\u003C/p>\n\u003Cp>The table shows that each device is assigned a unique IP from the pool, its MAC address and host name are indicated. The bound status means the lease is active — that is, the device is currently using this IP and can fully work on the network. For example, Windows received 192.168.10.100, Ubuntu — 192.168.10.99, and VPCS — 192.168.10.98.\u003C/p>\n\u003Cp>The DHCP server successfully performed its work: all three devices automatically received IP, subnet mask, gateway, and other necessary network parameters. They can now exchange data on the local network and in the future use the gateway to access other subnets or the internet.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"4-analysis-of-additional-dhcp-messages\">4. Analysis of Additional DHCP Messages\u003C/h3>\n\u003Ch4 id=\"release\">Release\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/14_release_win.png\" alt=\"14_release_win\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/15_release_wireshark.png\" alt=\"15_release_wireshark\">\u003C/p>\n\u003Chr>\n\u003Cp>When the \u003Ccode>ipconfig /release\u003C/code> command is executed on a Windows client computer, the device tells the DHCP server that it no longer needs the leased IP address. In our example, the client sends \u003Cstrong>DHCP Release\u003C/strong> to server 192.168.10.1, freeing address 192.168.10.100. This means the server can return this IP back to the pool of free addresses so other devices can use it.\u003C/p>\n\u003Cp>On the client, after executing the command, the IPv4 address disappears, gateway and DNS server are no longer assigned. The client cannot exchange data beyond the local network until it receives an address through DHCP again. IPv6 addresses remain, as the command only affects IPv4.\u003C/p>\n\u003Cp>The Release network packet is sent \u003Cstrong>unicast\u003C/strong> directly to the server (not broadcast). The source is the client’s old IP (192.168.10.100), and the destination is the server’s IP (192.168.10.1). The packet specifies the message type (Release), client identifier (MAC), and server identifier so DHCP knows exactly which lease to terminate.\u003C/p>\n\u003Cp>On the MikroTik server, after receiving this packet, the lease record for the client is immediately updated: the address returns to the available pool, and the lease status changes from \u003Ccode>bound\u003C/code> to \u003Ccode>released\u003C/code> (or the record is deleted from the active leases list).\u003C/p>\n\u003Cp>Simply put, \u003Cstrong>DHCP Release\u003C/strong> is the client’s way to correctly “return” the IP to the server, ending the use of the address. Thus, the address is no longer occupied, and the server can issue it to another device.\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"nak\">NAK\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/16_nak_wireshark.png\" alt=\"16_nak_wireshark\">\u003C/p>\n\u003Cp>After the Windows client freed IP address 192.168.10.100 using the \u003Cstrong>ipconfig /release\u003C/strong> command, the server returned this address to the free pool. Later, the DHCP pool was changed with the command \u003Ccode>/ip pool set dhcp_pool ranges=192.168.10.10-192.168.10.99\u003C/code> and now includes only addresses \u003Cstrong>192.168.10.10–192.168.10.99\u003C/strong>. When Windows tried to obtain IP 192.168.10.100 again, the server responded with a negative acknowledgment — \u003Cstrong>DHCP NAK\u003C/strong>. This message tells the client that the requested address is invalid and cannot be used.\u003C/p>\n\u003Cp>DHCP NAK is broadcast to guarantee that the client receives the notification. In the message, the server indicates which IP cannot be used and its identifier so the client clearly understands this is the response from the needed server. Upon receiving NAK, the client immediately stops using the old IP and starts the process of obtaining a new address from scratch: first sends Discover, then receives Offer, confirms with Request, and receives ACK with a new IP. In our case, Windows received address \u003Cstrong>192.168.10.97\u003C/strong>, which is included in the current pool.\u003C/p>\n\u003Cp>The reasons why a server might send NAK are varied. The most common is that the client requested an address that is no longer in the pool or is already occupied by another device. NAK can also occur if the client tries to renew the lease of an old IP that the server no longer recognizes, or if it specified the wrong server for lease renewal. Overall, DHCP NAK is a protection mechanism that prevents IP address conflicts and guarantees that devices use only valid addresses from the current pool.\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"inform\">INFORM\u003C/h4>\n\u003Cp>After a device has already received an IP address and other settings through DHCP, sometimes there’s a need to request only additional network parameters from the DHCP server without changing the IP. The DHCP INFORM message is used for this. The client sends it to the server to receive, for example, current DNS servers, domain name, or other options that may change on the network without affecting its current IP.\u003C/p>\n\u003Cp>The INFORM message is sent from the IP address already assigned to the device, and the server responds with a regular DHCP ACK containing the requested parameters. This is useful if DNS settings, gateways, or other service parameters have been updated on the network, and the client needs to receive them without requesting a new IP.\u003C/p>\n\u003Cp>Unlike Discover, Request, or Release, INFORM doesn’t participate in IP address assignment but only serves to obtain information. Commands on Windows: \u003Ccode>ipconfig /renew\u003C/code>, on Linux: \u003Ccode>dhclient -1 -v -s 192.168.10.1>\u003C/code>\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"decline\">Decline\u003C/h4>\n\u003Cp>The \u003Cstrong>DHCP DECLINE\u003C/strong> message is used by the client when it discovers that the IP address offered by the DHCP server is already occupied by another device. For example, the client received an Offer with address 192.168.10.50, but an ARP check showed that this address is already being used by another host. In this case, the client cannot safely use the IP and sends a DECLINE message to the server to notify about the conflict.\u003C/p>\n\u003Cp>After receiving DECLINE, the server marks this address as unavailable and no longer issues it to other clients until the administrator or server resolves the conflict issue. Thus, DHCP DECLINE prevents IP address conflicts on the network and ensures correct operation of all devices.\u003C/p>\n\u003Cp>It’s important to note that with DECLINE, the client \u003Cstrong>doesn’t lose its current working IP\u003C/strong> if it’s already using some other address. This is purely a protective mechanism for handling offers from the server that could potentially cause a conflict.\u003C/p>\n\u003Cp>Usage example: Windows and Linux automatically send DECLINE if they detect an IP match on the network through ARP when checking an Offer.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"5-static-ip-binding\">5. Static IP Binding\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/17_fixed_ip_ubuntu.png\" alt=\"17_fixed_ip\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/18_fixed_ip_ubuntu_wireshark.png\" alt=\"18_fixed_ip_ubuntu_wireshark\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/19_fixed_ip_mikrotik.png\" alt=\"19_fixed_ip_mikrotik\">\u003C/p>\n\u003Cp>In DHCP, there’s a capability to \u003Cstrong>assign a specific IP address to a particular device\u003C/strong> using its MAC address. This mechanism is called \u003Cstrong>Static Lease\u003C/strong> and allows guaranteeing that the selected client will always receive the same address, regardless of the dynamic pool.\u003C/p>\n\u003Cp>In practice, this is done as follows: the administrator on MikroTik manually creates a record where they specify the IP address, client’s MAC address, DHCP server name, and a comment for convenience. In our case, the Ubuntu virtual machine with MAC \u003Ccode>0c:a2:21:ee:00:00\u003C/code> was assigned static IP \u003Ccode>192.168.10.105\u003C/code>. The configuration command looks as follows: \u003Ccode>/ip dhcp-server lease add address=192.168.10.105 mac-address=0c:a2:21:ee:00:00 comment=\"Ubuntu fixed IP\" server=dhcp1\u003C/code>\u003C/p>\n\u003Cp>After applying this setting, the DHCP server will never issue this IP to another device. If the client with the specified MAC tries to use a different address from the pool, the server will send NAK, and the client will be forced to request a new configuration. In our example, Ubuntu first received a refusal, and then, through the standard DORA process, correctly received its assigned address 192.168.10.105.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"6-configuring-dhcp-on-ubuntu\">6. Configuring DHCP on Ubuntu\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/20_topology_2.png\" alt=\"20_topology2\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/21_disable_dhcp_mikrotik.png\" alt=\"21_disable_dhcp\">\u003C/p>\n\u003Cp>We’re moving the DHCP server from MikroTik to Ubuntu. Previously, addresses were distributed by MikroTik with IP 192.168.10.1, now it will be a dedicated Ubuntu server. First, we disable DHCP on MikroTik so clients no longer receive IPs from it.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/22_isc_dhcp_server.png\" alt=\"22_isc_dhcp_server\">\u003C/p>\n\u003Cp>First, you need to make sure the package itself is installed. If not, install it with the command: \u003Ccode>sudo apt install isc-dhcp-server\u003C/code>. After installation, you need to tell the server which network interface to listen for client requests on. This is done in the \u003Ccode>/etc/default/isc-dhcp-server\u003C/code> file. Open it and edit the line: \u003Ccode>INTERFACESv4=\"ens3\"\u003C/code>. \u003Cstrong>ens3\u003C/strong> is the name of my network interface, yours may be different.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/23_dhcpd.png\" alt=\"23_dhcpd\">\u003C/p>\n\u003Cp>Next, we go to the main configuration file \u003Ccode>/etc/dhcp/dhcpd.conf\u003C/code>. There we set network parameters: pool of issued addresses, gateway, DNS, and lease time.\nSo now the server knows which addresses to distribute to whom, through which gateway, which DNS to provide, and for how long to issue the lease.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/24_restart_isc_dhcp.png\" alt=\"24_restart_isc\">\u003C/p>\n\u003Cp>We assign the server a static IP \u003Cstrong>192.168.10.2/24\u003C/strong>. Now Ubuntu Server is ready to issue IP addresses to clients. Start the service with the command \u003Ccode>sudo systemctl start isc-dhcp-server\u003C/code>. To check the status: \u003Ccode>sudo systemctl status isc-dhcp-server\u003C/code>\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/25_requested_ip_win.png\" alt=\"25_requested_ip\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/26_requested_ip_ubuntu.png\" alt=\"26_requested_ip_ubuntu\">\u003C/p>\n\u003Cp>When clients start communicating with the new server, here’s what happens: Windows tried to take its old address 192.168.10.97 — the server confirmed it because the address was free in the new pool. But the Ubuntu client, which previously had static address 192.168.10.105 on MikroTik, can no longer obtain it, as the address is not included in the new range. The server ignores this request, and the client sends Discover again, receives Offer, makes Request, and ultimately receives a new address from the pool — 192.168.10.12.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/27_ubuntuserver_print.png\" alt=\"27_ubuntuserver_print\">\u003C/p>\n\u003Cp>In the end, checking the lease table shows: Windows kept its old address, Ubuntu received a new one, and vpc also received its IP from the new range.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"7-configuring-dhcp-relay\">7. Configuring DHCP Relay\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/28_topology_3.png\" alt=\"28_topology_3\">\u003C/p>\n\u003Cp>Our network now has two subnets: the old 192.168.10.0/24 and the new 172.16.10.0/24. The DHCP server (Ubuntu Server, 192.168.10.2) currently only knows the pool for the first subnet. That is, if clients from the new subnet (PC2, PC3) send DHCP Discover, the server simply doesn’t see them — broadcast packets don’t cross the router.\u003C/p>\n\u003Cp>To fix this, we use MikroTik as DHCP Relay and configure routing.\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"1-configuring-routing-on-mikrotik\">1. Configuring Routing on MikroTik\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/29_route_mikrotik.png\" alt=\"29_route_mikroik\">\u003C/p>\n\u003Cp>On interface ether2, which faces the new subnet 172.16.10.0/24, we assign IP address 172.16.10.1/24. Now the router knows that packets destined for this subnet go through ether2 and can correctly route traffic between networks. Routing is also needed for the return path: when the DHCP server responds, the packet should get back to 172.16.10.0/24.\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"2-configuring-dhcp-relay-on-mikrotik\">2. Configuring DHCP Relay on MikroTik\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/30_dhcp_relay.png\" alt=\"30_dhcp_relay\">\u003C/p>\n\u003Cp>DHCP Relay is a mechanism that allows clients from one subnet to contact a server in another subnet, even if the server is not in the same broadcast domain. Relay “listens” for DHCP packets on the client network interface and forwards them to the server as regular unicast packets.\u003C/p>\n\u003Cp>On MikroTik it looks like this:\u003C/p>\n\u003Cp>\u003Ccode>/ip dhcp-relay add name=relay1 interface=ether2 dhcp-server=192.168.10.2 local-address=172.16.10.1 /ip dhcp-relay enable relay1\u003C/code>\u003C/p>\n\u003Cul>\n\u003Cli>\u003Ccode>interface=ether2\u003C/code> — the interface where the new subnet and clients whose packets need to be intercepted are located.\u003C/li>\n\u003Cli>\u003Ccode>dhcp-server=192.168.10.2\u003C/code> — the server’s IP to which requests will be forwarded.\u003C/li>\n\u003Cli>\u003Ccode>local-address=172.16.10.1\u003C/code> — MikroTik’s IP in the client subnet, which will be indicated as the source of responses for the client. Without local-address, Offer/ACK packets returned by the server may not reach the client because the client doesn’t know how to route them through another subnet.\u003C/li>\n\u003Cli>\u003Ccode>enable relay1\u003C/code> — activates the previously created relay named relay1.\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/31_cant_find_pc2.png\" alt=\"31_cant_find\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/32_add_subnet.png\" alt=\"32_add_subnet\">\u003C/p>\n\u003Cp>While the server only knows network 192.168.10.0/24, Relay will “deliver” Discover to the server, but the server won’t be able to issue an address, and the client will remain without an IP. Therefore, before starting Relay, you need to add the new subnet to the DHCP server configuration (/etc/dhcp/dhcpd.conf):\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/33_pc2_pc3.png\" alt=\"33_pc2_pc3\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/34_offer_pc2.png\" alt=\"34_offer_pc2\">\u003C/p>\n\u003Cp>PC1 and PC2 received addresses. Let’s analyze DHCP Offer for client PC2. The Ubuntu server itself wants to issue the client an address from its pool in the first subnet, but the client is located in the second subnet 172.16.10.0/24. The packet reaches the client through MikroTik, which acts as DHCP Relay. The router substitutes its local IP 172.16.10.1 as the source so the packet correctly reaches the client, who has no direct route to the server. The packet destination is IP 172.16.10.10, which the server is offering to the client. The Next Server IP Address field remains 192.168.10.2, showing that the real DHCP server is located in the first subnet. That is, the packet visually goes “from” MikroTik, but in fact it’s an offer from the Ubuntu server, and this mechanism allows a client in an isolated subnet to receive an IP address and network parameters.\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"3-how-packets-pass-through-relay-step-by-step-breakdown\">3. How Packets Pass Through Relay (Step-by-Step Breakdown)\u003C/h4>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>Step 1: Discover from Client (PC2/PC3)\u003C/strong>\u003Cbr>\nThe client from subnet 172.16.10.0/24 sends DHCP Discover broadcast (\u003Ccode>ff:ff:ff:ff:ff:ff\u003C/code>). It’s looking for any DHCP server. But since the server is in a different subnet, the packet won’t reach directly.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Step 2: Packet Interception by MikroTik\u003C/strong>\u003Cbr>\nDHCP Relay on MikroTik “catches” this Discover on ether2. Relay reads the packet and substitutes a new destination IP address — the DHCP server’s IP (192.168.10.2). The packet is now sent as unicast from MikroTik to the server.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Step 3: Server Receives Discover\u003C/strong>\u003Cbr>\nThe Ubuntu DHCP server receives the packet. Currently the server only knows the pool for 192.168.10.0/24, so it cannot issue an address for 172.16.10.0/24. Relay can optionally add option 82 (Agent Information) so the server understands which subnet the client came from and which pool to use.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Step 4: Offer from Server\u003C/strong>\u003Cbr>\nThe server forms DHCP Offer for the client. If the pool for 172.16.10.0/24 is already added, the server selects a free IP from this pool and sends the packet back to the IP from which Discover came (MikroTik).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Step 5: MikroTik Delivers Offer to Client\u003C/strong>\u003Cbr>\nWhen the packet returns to MikroTik, it changes the source IP address to its interface in the client subnet (172.16.10.1) so the client can receive the response, and forwards the Offer to the client.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Step 6: Request and ACK\u003C/strong>\u003Cbr>\nThe client responds with DHCP Request, the server confirms with DHCP ACK — the entire DORA process completely passes through Relay. The client receives IP address, gateway, and DNS, as if the server is in its subnet.\u003C/p>\n\u003C/li>\n\u003C/ul>",{"headings":238,"localImagePaths":279,"remoteImagePaths":280,"frontmatter":281,"imagePaths":285},[239,240,243,246,249,252,255,258,261,264,267,270,273,276],{"depth":30,"slug":200,"text":201},{"depth":30,"slug":241,"text":242},"2-configuring-dhcp-on-mikrotik","2. Configuring DHCP on MikroTik",{"depth":30,"slug":244,"text":245},"3-dora-analysis","3. DORA Analysis",{"depth":30,"slug":247,"text":248},"4-analysis-of-additional-dhcp-messages","4. Analysis of Additional DHCP Messages",{"depth":209,"slug":250,"text":251},"release","Release",{"depth":209,"slug":253,"text":254},"nak","NAK",{"depth":209,"slug":256,"text":257},"inform","INFORM",{"depth":209,"slug":259,"text":260},"decline","Decline",{"depth":30,"slug":262,"text":263},"5-static-ip-binding","5. Static IP Binding",{"depth":30,"slug":265,"text":266},"6-configuring-dhcp-on-ubuntu","6. Configuring DHCP on Ubuntu",{"depth":30,"slug":268,"text":269},"7-configuring-dhcp-relay","7. Configuring DHCP Relay",{"depth":209,"slug":271,"text":272},"1-configuring-routing-on-mikrotik","1. Configuring Routing on MikroTik",{"depth":209,"slug":274,"text":275},"2-configuring-dhcp-relay-on-mikrotik","2. Configuring DHCP Relay on MikroTik",{"depth":209,"slug":277,"text":278},"3-how-packets-pass-through-relay-step-by-step-breakdown","3. How Packets Pass Through Relay (Step-by-Step Breakdown)",[],[],{"title":231,"description":282,"image":283,"date":284},"In this work, we'll thoroughly examine how DHCP works, from the DORA message exchange process (Discover, Offer, Request, Acknowledge), through network traffic analysis in Wireshark","/images/dhcp_net/dhcp_main.jpg","February 6, 2026",[],"ru/arp",{"id":286,"data":288,"body":290,"filePath":291,"digest":292,"rendered":293},{"title":289},"Протокол ARP и обмен данными в локальной сети","**ARP (Address Resolution Protocol)** - это протокол, который помогает устройствам в локальной сети находить друг друга.\n\nОбычно мы работаем с IP-адресами или доменными именами (которые через DNS превращаются в IP). Но внутри локальной сети данные передаются не по IP, а по MAC-адресам. Коммутаторы видят только MAC-адреса и понятия не имеют, что такое IP.\n\nПоэтому перед отправкой данных устройство должно узнать: какому MAC-адресу соответствует нужный IP. Этим и занимается ARP.\n\nОн рассылает запрос в сети, получает ответ от нужного устройства и запоминает соответствие IP ↔ MAC. Благодаря этому устройства могут нормально обмениваться данными, даже если физический адрес получателя был неизвестен заранее.\n\n\n### 1. Построить топологию\n\n![01_topology](/images/arp_net/01_topology.png)\n\nДля лабораторного стенда в GNS3 мы создадим простую сеть с маршрутизатором Cisco, коммутатором и двумя виртуальными машинами. На маршрутизаторе будет настроен интерфейс FastEthernet0/0 с адресом *192.168.1.1/24*, который будет выполнять роль шлюза для всех устройств сети. Коммутатор объединяет все узлы в одной подсети, обеспечивая передачу данных на канальном уровне.\n\n* * *\n\n### 2. Настройка IP-адресов на роутере и клиентских ПК\n\n![02_set_router](/images/arp_net/02_set_router.png)\n\nПереходим к настройке маршрутизатора Cisco. Сначала выбираем нужный интерфейс, в моем случае FastEthernet0/0, и задаём ему IP-адрес и маску подсети. Для интерфейса в нашей сети назначаем *192.168.1.1/24*. После этого интерфейс необходимо активировать командой **no shutdown**, чтобы он начал работать и пропускать трафик. Теперь маршрутизатор готов обмениваться данными с устройствами в локальной сети.\n\n* * *\n\n![03_set_windows](/images/arp_net/03_set_windows.png)\n\nТеперь настроим IP-адрес на клиентской машине с Windows 10. Для этого открываем параметры сетевого адаптера, выбираем нужное подключение и вручную указываем IP-адрес, маску подсети и шлюз. В нашем примере для Windows задаём IP *192.168.1.10*, маску подсети *255.255.255.0*, а в качестве шлюза указываем адрес маршрутизатора - *192.168.1.1*. После сохранения настроек компьютер сможет обмениваться данными с другими устройствами сети и выходить в локальную подсеть.\n\n* * *\n\n![04_set_route](/images/arp_net/04_set_route.png)\n\nНа Linux настройку IP-адреса будем выполнять вручную через терминал. В нашем случае сетевой интерфейс называется **enp2s0**. Чтобы назначить статический IP, используем команду **sudo ip addr add 192.168.1.11/24 dev enp2s0**. Далее необходимо указать шлюз по умолчанию, через который устройство будет выходить в сеть **sudo ip route add default via 192.168.1.1**. После этих действий интерфейс enp2s0 получает IP-адрес *192.168.1.11* с маской подсети *255.255.255.0*, а маршрутизатор *192.168.1.1* выступает в роли шлюза. Теперь Ubuntu-машина может корректно обмениваться данными с другими устройствами сети и взаимодействовать с маршрутизатором.\n\n* * *\n\n### 3. Разбор стандартного обмена ARP-сообщениями\n\n![05_empty_arp](/images/arp_net/05_empty_arp.png)\n\nПереходим к захвату сетевого трафика с помощью Wireshark. Для удобства фильтруем пакеты по протоколу ARP, чтобы видеть только сообщения ARP. В начале захвата ARP-таблицы на обоих хостах пусты, поэтому все запросы и ответы будут фиксироваться с нуля.\n\n* * *\n\n![06_arp_d_win](/images/arp_net/06_arp_d_win.png)\n\nПеред началом эксперимента будем очищать ARP-кэш на обоих хостах, чтобы все записи создавались заново и наблюдать процесс в реальном времени.\n\nНа Windows это делается через командную строку командой **arp -d**. Эта команда удаляет все существующие записи ARP. Затем можно проверить состояние таблицы с помощью **arp -a**.\n\nВ начале таблица пустая, но после выполнения команды ping на другой хост появятся новые записи, отражающие недавно разрешённые MAC-адреса\n\n* * *\n\n![07_arp_d_linux](/images/arp_net/07_arp_d_linux.png)\n\nНа Linux очистка ARP-кэша выполняется командой **sudo ip neigh flush all**. Эта команда удаляет все текущие записи ARP для всех интерфейсов, включая enp2s0 в нашем случае. После её выполнения система забывает, какие MAC-адреса соответствуют каким IP, и все последующие обращения к другим устройствам сети будут инициировать новые ARP-запросы.\n\nЧтобы убедиться, что таблица действительно пуста, можно командой **ip neigh show**. В начале вывод будет пустым, так как записи удалены. После того как хост попытается отправить данные другому устройству, в таблице появятся новые записи, отражающие только что разрешённые MAC-адреса.\n\n* * *\n\n![08_ping](/images/arp_net/08_ping.png)\n\nВыполняем отправку ICMP-запросов на Linux-машину с IP-адресом *192.168.1.11*, после чего переходим к анализу сетевого трафика в программе Wireshark.\n\n* * *\n\n![09_wireshark](/images/arp_net/09_wireshark.png)\n\nВ Wireshark появились записи ARP-запросов и ARP-ответов.\n\n* * *\n\n#### ARP Запрос\n\n![10_arp_request](/images/arp_net/10_arp_request.png)\n\nКогда устройство в локальной сети хочет отправить данные другому устройству, оно должно знать MAC-адрес получателя. Если в ARP-кэше записи для этого IP нет, система выполняет следующие шаги:\n\n- **Шаг 1:** Проверка ARP-кэша. Компьютер сначала проверяет свою таблицу ARP. Если запись для нужного IP отсутствует, нужно узнать MAC-адрес устройства с этим IP.\n\n- **Шаг 2:** Формирование ARP-запроса. Устройство создаёт ARP-пакет, в котором указывает:\n\n    - Свой MAC и IP, чтобы получатель знал, кто спрашивает.\n    - IP-адрес цели - адрес, чей MAC нужно узнать.\n    - MAC-адрес цели оставляется пустым (00:00:00:00:00:00), так как его ещё нет.\n\n- **Шаг 3:**. Отправка запроса всем устройствам сети (broadcast)\nПакет отправляется на адрес ff:ff:ff:ff:ff:ff, то есть на все компьютеры в локальной сети, чтобы нужное устройство его точно получило.\n\n- **Шаг 4:**. Обработка запроса другими устройствами. Каждый компьютер проверяет, совпадает ли его IP с целевым: Если совпадает то устройство формирует ARP-ответ и отправляет обратно отправителю. Если не совпадает то игнорирует пакет.\n\n- **Шаг 5**. Обновление ARP-кэша. После получения ответа отправитель сохраняет в ARP-кэше соответствие IP ↔ MAC. Теперь последующие передачи данных можно делать напрямую, без нового запроса.\n\n**Поля ARP-запроса**\n\n| Поле                  | Пример значения       | Описание                                                      |\n|-----------------------|---------------------|---------------------------------------------------------------|\n| **Hardware Type**      | Ethernet (1)         | Тип канального уровня (Ethernet).                             |\n| **Protocol Type**      | IPv4 (0x0800)        | Протокол верхнего уровня, для которого ищем MAC (IPv4).      |\n| **Hardware Size**      | 6                    | Длина MAC-адреса в байтах.                                   |\n| **Protocol Size**      | 4                    | Длина IP-адреса в байтах.                                    |\n| **Opcode**             | Request (1)          | Тип ARP-сообщения: 1 — запрос.                               |\n| **Sender MAC Address** | 0c:e5:1d:02:00:00   | MAC-адрес отправителя запроса.                                |\n| **Sender IP Address**  | 192.168.1.10         | IP-адрес отправителя.                                        |\n| **Target MAC Address** | 00:00:00:00:00:00    | MAC-адрес цели (ещё неизвестен).                             |\n| **Target IP Address**  | 192.168.1.11         | IP-адрес устройства, MAC-адрес которого нужно узнать.        |\n\n* * *\n\n#### ARP Ответ\n\n![11_arp_reply](/images/arp_net/11_arp_reply.png)\n\nКогда устройство получает ARP-запрос и обнаруживает, что IP в запросе совпадает с его собственным, оно формирует ARP-ответ. Это сообщение сообщает отправителю запроса, какой MAC-адрес соответствует запрашиваемому IP.\n\n-   **Шаг 1:** Получение ARP-запроса. Устройство получает ARP-запрос и проверяет, совпадает ли его IP с IP-адресом в запросе. Если совпадает, готовится ответ.\n    \n-   **Шаг 2:** Формирование ARP-ответа. Устройство создаёт ARP-пакет, в котором указывает:\n    \n    -   Свой MAC и IP — это адрес и IP устройства, которое отвечает.\n    -   MAC и IP отправителя запроса — чтобы ответ дошёл точно до него.\n        \n-   **Шаг 3:** Отправка ответа напрямую(unicast). ARP Reply отправляется на MAC-адрес отправителя запроса, а не на broadcast. Пакет идёт только нужному устройству.\n    \n-   **Шаг 4:** Обновление ARP-кэша у получателя. Компьютер, который отправил запрос, получает ответ и записывает соответствие IP ↔ MAC в свой ARP-кэш.\n    \n-   **Шаг 5:** Дальнейшая передача данных. После записи в кэш устройство может отправлять данные напрямую, без необходимости нового ARP-запроса.\n\n**Поля ARP-ответа**\n\n| Поле                  | Пример значения       | Описание                                                      |\n|-----------------------|---------------------|---------------------------------------------------------------|\n| **Hardware Type**      | Ethernet (1)         | Тип канального уровня (Ethernet).                             |\n| **Protocol Type**      | IPv4 (0x0800)        | Протокол верхнего уровня (IPv4).                              |\n| **Hardware Size**      | 6                    | Длина MAC-адреса в байтах.                                   |\n| **Protocol Size**      | 4                    | Длина IP-адреса в байтах.                                    |\n| **Opcode**             | Reply (2)            | Тип ARP-сообщения: 2 — ответ.                                 |\n| **Sender MAC Address** | 0c:ef:f7:15:00:00   | MAC-адрес устройства, которое отвечает на запрос.             |\n| **Sender IP Address**  | 192.168.1.11         | IP-адрес устройства, которое отвечает.                        |\n| **Target MAC Address** | 0c:e5:1d:02:00:00   | MAC-адрес устройства, которому предназначен ответ.           |\n| **Target IP Address**  | 192.168.1.10         | IP-адрес устройства, которому предназначен ответ.            |\n\n\n* * *\n\n### Разбор стандартного обмена Gratuitous ARP (G-ARP) в сети\n\n![12_arping_linux_grad](/images/arp_net/12_arping_linux_grad.png)\n\nGratuitous ARP — это особый вид ARP-сообщений, который устройство отправляет о себе, без того чтобы кто-то делал запрос. Иными словами, компьютер или сервер сам сообщает сети: «Вот мой IP и MAC-адрес». Такие пакеты не требуют ответа от других устройств — они рассылаются широковещательно, чтобы все компьютеры и сетевое оборудование в локальной сети обновили свои ARP-кэши.\n\nОсновные цели использования G-ARP следующие:\n\n1. Обновление ARP-кэшей других устройств. Если на устройстве поменялся MAC-адрес или IP, отправка G-ARP позволяет всем узлам сети узнать актуальные данные.\n\n2. Проверка занятости IP-адреса. Устройство может отправить G-ARP для того, чтобы убедиться, что данный IP не используется другим устройством.\n\n3. Информирование сети при запуске устройства. Когда компьютер или сервер только включился, G-ARP помогает маршрутизаторам, коммутаторам и другим хостам быстро узнать правильный MAC для его IP.\n\nВ Linux отправка G-ARP легко выполняется с помощью утилиты **arping**. При этом устройство посылает ARP Reply на широковещательный адрес, но не ждёт ответа. Такой подход отличается от стандартного ARP-запроса, когда компьютер ищет MAC-адрес другого хоста и ждёт ответа.\n\nНапример, если Ubuntu отправляет G-ARP для IP 192.168.1.11, она рассылает сообщение по сети, сообщая свой MAC-адрес. Все устройства в локальной сети, которые получают этот пакет, обновляют свои ARP-кэши, даже если они не запрашивали этот адрес. Благодаря этому последующие передачи данных можно выполнять напрямую, без лишних запросов.\n\n![13_g_arp](/images/arp_net/13_g_arp.png)\n\n**Поля ARP-ответа**\n\n| Поле                  | Пример значения       | Описание                                                      |\n|-----------------------|---------------------|---------------------------------------------------------------|\n| **Hardware Type**      | Ethernet (1)         | Тип канального уровня (Ethernet).                             |\n| **Protocol Type**      | IPv4 (0x0800)        | Протокол верхнего уровня (IPv4).                              |\n| **Hardware Size**      | 6                    | Длина MAC-адреса в байтах.                                   |\n| **Protocol Size**      | 4                    | Длина IP-адреса в байтах.                                    |\n| **Opcode**             | Reply (2)            | Тип ARP-сообщения: 2 — ответ. В G-ARP используется ARP Reply, но без запроса. |\n| **Sender MAC Address** | 0c:ef:f7:15:00:00   | MAC-адрес устройства, которое рассылает информацию о себе.   |\n| **Sender IP Address**  | 192.168.1.11         | IP-адрес устройства, которое рассылает информацию о себе.    |\n| **Target MAC Address** | ff:ff:ff:ff:ff:ff    | Широковещательный MAC-адрес, пакет рассылается всем в сети.  |\n| **Target IP Address**  | 192.168.1.11         | IP-адрес устройства, о котором рассылается информация.       |\n\n\n* * *\n\n![14_arp_windows](/images/arp_net/14_arp_windows.png)\n\nПосле того как Ubuntu отправила Gratuitous ARP (G-ARP) с указанием своего IP и MAC-адреса, Windows получила этот пакет и автоматически обновила свой ARP-кэш.\n\n* * * \n\n### 4. Динамический и статический ARP\n\n**Динамический ARP** - это записи, которые устройство создаёт само, автоматически, когда нужно узнать MAC-адрес другого устройства по его IP. Такие записи добавляются в ARP-таблицу сами и через некоторое время могут удаляться, если адрес больше не используется.\n\nВ нашей работе пример динамического ARP был, когда Ubuntu отправила Gratuitous ARP для своего IP 192.168.1.11. Windows получила этот пакет и автоматически добавила запись.\n\n---\n\n**Статический ARP** - это записи, которые создаётся вручную и которые остаются в таблице пока их специально не удалят. Они полезны для устройств, с которыми всегда нужен стабильный контакт, например, серверы, маршрутизаторы или принтеры в сети.\n\nНапример, если бы мы вручную добавили на Windows запись для Ubuntu: **arp -s 192.168.1.11 0c:ef:f7:15:00:00**. то эта запись стала бы статической. Она не исчезнет сама и всегда будет использовать этот MAC для указанного IP, даже если Ubuntu не отправляет пакеты или G-ARP.","src/content/articles/ru/arp.md","f8b5bc3807c6155f",{"html":294,"metadata":295},"\u003Cp>\u003Cstrong>ARP (Address Resolution Protocol)\u003C/strong> - это протокол, который помогает устройствам в локальной сети находить друг друга.\u003C/p>\n\u003Cp>Обычно мы работаем с IP-адресами или доменными именами (которые через DNS превращаются в IP). Но внутри локальной сети данные передаются не по IP, а по MAC-адресам. Коммутаторы видят только MAC-адреса и понятия не имеют, что такое IP.\u003C/p>\n\u003Cp>Поэтому перед отправкой данных устройство должно узнать: какому MAC-адресу соответствует нужный IP. Этим и занимается ARP.\u003C/p>\n\u003Cp>Он рассылает запрос в сети, получает ответ от нужного устройства и запоминает соответствие IP ↔ MAC. Благодаря этому устройства могут нормально обмениваться данными, даже если физический адрес получателя был неизвестен заранее.\u003C/p>\n\u003Ch3 id=\"1-построить-топологию\">1. Построить топологию\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/arp_net/01_topology.png\" alt=\"01_topology\">\u003C/p>\n\u003Cp>Для лабораторного стенда в GNS3 мы создадим простую сеть с маршрутизатором Cisco, коммутатором и двумя виртуальными машинами. На маршрутизаторе будет настроен интерфейс FastEthernet0/0 с адресом \u003Cem>192.168.1.1/24\u003C/em>, который будет выполнять роль шлюза для всех устройств сети. Коммутатор объединяет все узлы в одной подсети, обеспечивая передачу данных на канальном уровне.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"2-настройка-ip-адресов-на-роутере-и-клиентских-пк\">2. Настройка IP-адресов на роутере и клиентских ПК\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/arp_net/02_set_router.png\" alt=\"02_set_router\">\u003C/p>\n\u003Cp>Переходим к настройке маршрутизатора Cisco. Сначала выбираем нужный интерфейс, в моем случае FastEthernet0/0, и задаём ему IP-адрес и маску подсети. Для интерфейса в нашей сети назначаем \u003Cem>192.168.1.1/24\u003C/em>. После этого интерфейс необходимо активировать командой \u003Cstrong>no shutdown\u003C/strong>, чтобы он начал работать и пропускать трафик. Теперь маршрутизатор готов обмениваться данными с устройствами в локальной сети.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/arp_net/03_set_windows.png\" alt=\"03_set_windows\">\u003C/p>\n\u003Cp>Теперь настроим IP-адрес на клиентской машине с Windows 10. Для этого открываем параметры сетевого адаптера, выбираем нужное подключение и вручную указываем IP-адрес, маску подсети и шлюз. В нашем примере для Windows задаём IP \u003Cem>192.168.1.10\u003C/em>, маску подсети \u003Cem>255.255.255.0\u003C/em>, а в качестве шлюза указываем адрес маршрутизатора - \u003Cem>192.168.1.1\u003C/em>. После сохранения настроек компьютер сможет обмениваться данными с другими устройствами сети и выходить в локальную подсеть.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/arp_net/04_set_route.png\" alt=\"04_set_route\">\u003C/p>\n\u003Cp>На Linux настройку IP-адреса будем выполнять вручную через терминал. В нашем случае сетевой интерфейс называется \u003Cstrong>enp2s0\u003C/strong>. Чтобы назначить статический IP, используем команду \u003Cstrong>sudo ip addr add 192.168.1.11/24 dev enp2s0\u003C/strong>. Далее необходимо указать шлюз по умолчанию, через который устройство будет выходить в сеть \u003Cstrong>sudo ip route add default via 192.168.1.1\u003C/strong>. После этих действий интерфейс enp2s0 получает IP-адрес \u003Cem>192.168.1.11\u003C/em> с маской подсети \u003Cem>255.255.255.0\u003C/em>, а маршрутизатор \u003Cem>192.168.1.1\u003C/em> выступает в роли шлюза. Теперь Ubuntu-машина может корректно обмениваться данными с другими устройствами сети и взаимодействовать с маршрутизатором.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"3-разбор-стандартного-обмена-arp-сообщениями\">3. Разбор стандартного обмена ARP-сообщениями\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/arp_net/05_empty_arp.png\" alt=\"05_empty_arp\">\u003C/p>\n\u003Cp>Переходим к захвату сетевого трафика с помощью Wireshark. Для удобства фильтруем пакеты по протоколу ARP, чтобы видеть только сообщения ARP. В начале захвата ARP-таблицы на обоих хостах пусты, поэтому все запросы и ответы будут фиксироваться с нуля.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/arp_net/06_arp_d_win.png\" alt=\"06_arp_d_win\">\u003C/p>\n\u003Cp>Перед началом эксперимента будем очищать ARP-кэш на обоих хостах, чтобы все записи создавались заново и наблюдать процесс в реальном времени.\u003C/p>\n\u003Cp>На Windows это делается через командную строку командой \u003Cstrong>arp -d\u003C/strong>. Эта команда удаляет все существующие записи ARP. Затем можно проверить состояние таблицы с помощью \u003Cstrong>arp -a\u003C/strong>.\u003C/p>\n\u003Cp>В начале таблица пустая, но после выполнения команды ping на другой хост появятся новые записи, отражающие недавно разрешённые MAC-адреса\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/arp_net/07_arp_d_linux.png\" alt=\"07_arp_d_linux\">\u003C/p>\n\u003Cp>На Linux очистка ARP-кэша выполняется командой \u003Cstrong>sudo ip neigh flush all\u003C/strong>. Эта команда удаляет все текущие записи ARP для всех интерфейсов, включая enp2s0 в нашем случае. После её выполнения система забывает, какие MAC-адреса соответствуют каким IP, и все последующие обращения к другим устройствам сети будут инициировать новые ARP-запросы.\u003C/p>\n\u003Cp>Чтобы убедиться, что таблица действительно пуста, можно командой \u003Cstrong>ip neigh show\u003C/strong>. В начале вывод будет пустым, так как записи удалены. После того как хост попытается отправить данные другому устройству, в таблице появятся новые записи, отражающие только что разрешённые MAC-адреса.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/arp_net/08_ping.png\" alt=\"08_ping\">\u003C/p>\n\u003Cp>Выполняем отправку ICMP-запросов на Linux-машину с IP-адресом \u003Cem>192.168.1.11\u003C/em>, после чего переходим к анализу сетевого трафика в программе Wireshark.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/arp_net/09_wireshark.png\" alt=\"09_wireshark\">\u003C/p>\n\u003Cp>В Wireshark появились записи ARP-запросов и ARP-ответов.\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"arp-запрос\">ARP Запрос\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/arp_net/10_arp_request.png\" alt=\"10_arp_request\">\u003C/p>\n\u003Cp>Когда устройство в локальной сети хочет отправить данные другому устройству, оно должно знать MAC-адрес получателя. Если в ARP-кэше записи для этого IP нет, система выполняет следующие шаги:\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>Шаг 1:\u003C/strong> Проверка ARP-кэша. Компьютер сначала проверяет свою таблицу ARP. Если запись для нужного IP отсутствует, нужно узнать MAC-адрес устройства с этим IP.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Шаг 2:\u003C/strong> Формирование ARP-запроса. Устройство создаёт ARP-пакет, в котором указывает:\u003C/p>\n\u003Cul>\n\u003Cli>Свой MAC и IP, чтобы получатель знал, кто спрашивает.\u003C/li>\n\u003Cli>IP-адрес цели - адрес, чей MAC нужно узнать.\u003C/li>\n\u003Cli>MAC-адрес цели оставляется пустым (00:00:00:00:00:00), так как его ещё нет.\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Шаг 3:\u003C/strong>. Отправка запроса всем устройствам сети (broadcast)\nПакет отправляется на адрес ff:ff:ff:ff:ff:ff, то есть на все компьютеры в локальной сети, чтобы нужное устройство его точно получило.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Шаг 4:\u003C/strong>. Обработка запроса другими устройствами. Каждый компьютер проверяет, совпадает ли его IP с целевым: Если совпадает то устройство формирует ARP-ответ и отправляет обратно отправителю. Если не совпадает то игнорирует пакет.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Шаг 5\u003C/strong>. Обновление ARP-кэша. После получения ответа отправитель сохраняет в ARP-кэше соответствие IP ↔ MAC. Теперь последующие передачи данных можно делать напрямую, без нового запроса.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>\u003Cstrong>Поля ARP-запроса\u003C/strong>\u003C/p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003Ctable>\u003Cthead>\u003Ctr>\u003Cth>Поле\u003C/th>\u003Cth>Пример значения\u003C/th>\u003Cth>Описание\u003C/th>\u003C/tr>\u003C/thead>\u003Ctbody>\u003Ctr>\u003Ctd>\u003Cstrong>Hardware Type\u003C/strong>\u003C/td>\u003Ctd>Ethernet (1)\u003C/td>\u003Ctd>Тип канального уровня (Ethernet).\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Protocol Type\u003C/strong>\u003C/td>\u003Ctd>IPv4 (0x0800)\u003C/td>\u003Ctd>Протокол верхнего уровня, для которого ищем MAC (IPv4).\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Hardware Size\u003C/strong>\u003C/td>\u003Ctd>6\u003C/td>\u003Ctd>Длина MAC-адреса в байтах.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Protocol Size\u003C/strong>\u003C/td>\u003Ctd>4\u003C/td>\u003Ctd>Длина IP-адреса в байтах.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Opcode\u003C/strong>\u003C/td>\u003Ctd>Request (1)\u003C/td>\u003Ctd>Тип ARP-сообщения: 1 — запрос.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Sender MAC Address\u003C/strong>\u003C/td>\u003Ctd>0c:e5:1d:02:00:00\u003C/td>\u003Ctd>MAC-адрес отправителя запроса.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Sender IP Address\u003C/strong>\u003C/td>\u003Ctd>192.168.1.10\u003C/td>\u003Ctd>IP-адрес отправителя.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Target MAC Address\u003C/strong>\u003C/td>\u003Ctd>00:00:00:00:00:00\u003C/td>\u003Ctd>MAC-адрес цели (ещё неизвестен).\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Target IP Address\u003C/strong>\u003C/td>\u003Ctd>192.168.1.11\u003C/td>\u003Ctd>IP-адрес устройства, MAC-адрес которого нужно узнать.\u003C/td>\u003C/tr>\u003C/tbody>\u003C/table>\n\u003Chr>\n\u003Ch4 id=\"arp-ответ\">ARP Ответ\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/arp_net/11_arp_reply.png\" alt=\"11_arp_reply\">\u003C/p>\n\u003Cp>Когда устройство получает ARP-запрос и обнаруживает, что IP в запросе совпадает с его собственным, оно формирует ARP-ответ. Это сообщение сообщает отправителю запроса, какой MAC-адрес соответствует запрашиваемому IP.\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>Шаг 1:\u003C/strong> Получение ARP-запроса. Устройство получает ARP-запрос и проверяет, совпадает ли его IP с IP-адресом в запросе. Если совпадает, готовится ответ.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Шаг 2:\u003C/strong> Формирование ARP-ответа. Устройство создаёт ARP-пакет, в котором указывает:\u003C/p>\n\u003Cul>\n\u003Cli>Свой MAC и IP — это адрес и IP устройства, которое отвечает.\u003C/li>\n\u003Cli>MAC и IP отправителя запроса — чтобы ответ дошёл точно до него.\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Шаг 3:\u003C/strong> Отправка ответа напрямую(unicast). ARP Reply отправляется на MAC-адрес отправителя запроса, а не на broadcast. Пакет идёт только нужному устройству.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Шаг 4:\u003C/strong> Обновление ARP-кэша у получателя. Компьютер, который отправил запрос, получает ответ и записывает соответствие IP ↔ MAC в свой ARP-кэш.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Шаг 5:\u003C/strong> Дальнейшая передача данных. После записи в кэш устройство может отправлять данные напрямую, без необходимости нового ARP-запроса.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>\u003Cstrong>Поля ARP-ответа\u003C/strong>\u003C/p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003Ctable>\u003Cthead>\u003Ctr>\u003Cth>Поле\u003C/th>\u003Cth>Пример значения\u003C/th>\u003Cth>Описание\u003C/th>\u003C/tr>\u003C/thead>\u003Ctbody>\u003Ctr>\u003Ctd>\u003Cstrong>Hardware Type\u003C/strong>\u003C/td>\u003Ctd>Ethernet (1)\u003C/td>\u003Ctd>Тип канального уровня (Ethernet).\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Protocol Type\u003C/strong>\u003C/td>\u003Ctd>IPv4 (0x0800)\u003C/td>\u003Ctd>Протокол верхнего уровня (IPv4).\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Hardware Size\u003C/strong>\u003C/td>\u003Ctd>6\u003C/td>\u003Ctd>Длина MAC-адреса в байтах.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Protocol Size\u003C/strong>\u003C/td>\u003Ctd>4\u003C/td>\u003Ctd>Длина IP-адреса в байтах.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Opcode\u003C/strong>\u003C/td>\u003Ctd>Reply (2)\u003C/td>\u003Ctd>Тип ARP-сообщения: 2 — ответ.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Sender MAC Address\u003C/strong>\u003C/td>\u003Ctd>0c:ef:f7:15:00:00\u003C/td>\u003Ctd>MAC-адрес устройства, которое отвечает на запрос.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Sender IP Address\u003C/strong>\u003C/td>\u003Ctd>192.168.1.11\u003C/td>\u003Ctd>IP-адрес устройства, которое отвечает.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Target MAC Address\u003C/strong>\u003C/td>\u003Ctd>0c:e5:1d:02:00:00\u003C/td>\u003Ctd>MAC-адрес устройства, которому предназначен ответ.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Target IP Address\u003C/strong>\u003C/td>\u003Ctd>192.168.1.10\u003C/td>\u003Ctd>IP-адрес устройства, которому предназначен ответ.\u003C/td>\u003C/tr>\u003C/tbody>\u003C/table>\n\u003Chr>\n\u003Ch3 id=\"разбор-стандартного-обмена-gratuitous-arp-g-arp-в-сети\">Разбор стандартного обмена Gratuitous ARP (G-ARP) в сети\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/arp_net/12_arping_linux_grad.png\" alt=\"12_arping_linux_grad\">\u003C/p>\n\u003Cp>Gratuitous ARP — это особый вид ARP-сообщений, который устройство отправляет о себе, без того чтобы кто-то делал запрос. Иными словами, компьютер или сервер сам сообщает сети: «Вот мой IP и MAC-адрес». Такие пакеты не требуют ответа от других устройств — они рассылаются широковещательно, чтобы все компьютеры и сетевое оборудование в локальной сети обновили свои ARP-кэши.\u003C/p>\n\u003Cp>Основные цели использования G-ARP следующие:\u003C/p>\n\u003Col>\n\u003Cli>\n\u003Cp>Обновление ARP-кэшей других устройств. Если на устройстве поменялся MAC-адрес или IP, отправка G-ARP позволяет всем узлам сети узнать актуальные данные.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Проверка занятости IP-адреса. Устройство может отправить G-ARP для того, чтобы убедиться, что данный IP не используется другим устройством.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Информирование сети при запуске устройства. Когда компьютер или сервер только включился, G-ARP помогает маршрутизаторам, коммутаторам и другим хостам быстро узнать правильный MAC для его IP.\u003C/p>\n\u003C/li>\n\u003C/ol>\n\u003Cp>В Linux отправка G-ARP легко выполняется с помощью утилиты \u003Cstrong>arping\u003C/strong>. При этом устройство посылает ARP Reply на широковещательный адрес, но не ждёт ответа. Такой подход отличается от стандартного ARP-запроса, когда компьютер ищет MAC-адрес другого хоста и ждёт ответа.\u003C/p>\n\u003Cp>Например, если Ubuntu отправляет G-ARP для IP 192.168.1.11, она рассылает сообщение по сети, сообщая свой MAC-адрес. Все устройства в локальной сети, которые получают этот пакет, обновляют свои ARP-кэши, даже если они не запрашивали этот адрес. Благодаря этому последующие передачи данных можно выполнять напрямую, без лишних запросов.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/arp_net/13_g_arp.png\" alt=\"13_g_arp\">\u003C/p>\n\u003Cp>\u003Cstrong>Поля ARP-ответа\u003C/strong>\u003C/p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003Ctable>\u003Cthead>\u003Ctr>\u003Cth>Поле\u003C/th>\u003Cth>Пример значения\u003C/th>\u003Cth>Описание\u003C/th>\u003C/tr>\u003C/thead>\u003Ctbody>\u003Ctr>\u003Ctd>\u003Cstrong>Hardware Type\u003C/strong>\u003C/td>\u003Ctd>Ethernet (1)\u003C/td>\u003Ctd>Тип канального уровня (Ethernet).\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Protocol Type\u003C/strong>\u003C/td>\u003Ctd>IPv4 (0x0800)\u003C/td>\u003Ctd>Протокол верхнего уровня (IPv4).\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Hardware Size\u003C/strong>\u003C/td>\u003Ctd>6\u003C/td>\u003Ctd>Длина MAC-адреса в байтах.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Protocol Size\u003C/strong>\u003C/td>\u003Ctd>4\u003C/td>\u003Ctd>Длина IP-адреса в байтах.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Opcode\u003C/strong>\u003C/td>\u003Ctd>Reply (2)\u003C/td>\u003Ctd>Тип ARP-сообщения: 2 — ответ. В G-ARP используется ARP Reply, но без запроса.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Sender MAC Address\u003C/strong>\u003C/td>\u003Ctd>0c:ef:f7:15:00:00\u003C/td>\u003Ctd>MAC-адрес устройства, которое рассылает информацию о себе.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Sender IP Address\u003C/strong>\u003C/td>\u003Ctd>192.168.1.11\u003C/td>\u003Ctd>IP-адрес устройства, которое рассылает информацию о себе.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Target MAC Address\u003C/strong>\u003C/td>\u003Ctd>ff:ff:ff:ff:ff:ff\u003C/td>\u003Ctd>Широковещательный MAC-адрес, пакет рассылается всем в сети.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Target IP Address\u003C/strong>\u003C/td>\u003Ctd>192.168.1.11\u003C/td>\u003Ctd>IP-адрес устройства, о котором рассылается информация.\u003C/td>\u003C/tr>\u003C/tbody>\u003C/table>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/arp_net/14_arp_windows.png\" alt=\"14_arp_windows\">\u003C/p>\n\u003Cp>После того как Ubuntu отправила Gratuitous ARP (G-ARP) с указанием своего IP и MAC-адреса, Windows получила этот пакет и автоматически обновила свой ARP-кэш.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"4-динамический-и-статический-arp\">4. Динамический и статический ARP\u003C/h3>\n\u003Cp>\u003Cstrong>Динамический ARP\u003C/strong> - это записи, которые устройство создаёт само, автоматически, когда нужно узнать MAC-адрес другого устройства по его IP. Такие записи добавляются в ARP-таблицу сами и через некоторое время могут удаляться, если адрес больше не используется.\u003C/p>\n\u003Cp>В нашей работе пример динамического ARP был, когда Ubuntu отправила Gratuitous ARP для своего IP 192.168.1.11. Windows получила этот пакет и автоматически добавила запись.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cstrong>Статический ARP\u003C/strong> - это записи, которые создаётся вручную и которые остаются в таблице пока их специально не удалят. Они полезны для устройств, с которыми всегда нужен стабильный контакт, например, серверы, маршрутизаторы или принтеры в сети.\u003C/p>\n\u003Cp>Например, если бы мы вручную добавили на Windows запись для Ubuntu: \u003Cstrong>arp -s 192.168.1.11 0c:ef:f7:15:00:00\u003C/strong>. то эта запись стала бы статической. Она не исчезнет сама и всегда будет использовать этот MAC для указанного IP, даже если Ubuntu не отправляет пакеты или G-ARP.\u003C/p>",{"headings":296,"localImagePaths":318,"remoteImagePaths":319,"frontmatter":320,"imagePaths":323},[297,300,303,306,309,312,315],{"depth":30,"slug":298,"text":299},"1-построить-топологию","1. Построить топологию",{"depth":30,"slug":301,"text":302},"2-настройка-ip-адресов-на-роутере-и-клиентских-пк","2. Настройка IP-адресов на роутере и клиентских ПК",{"depth":30,"slug":304,"text":305},"3-разбор-стандартного-обмена-arp-сообщениями","3. Разбор стандартного обмена ARP-сообщениями",{"depth":209,"slug":307,"text":308},"arp-запрос","ARP Запрос",{"depth":209,"slug":310,"text":311},"arp-ответ","ARP Ответ",{"depth":30,"slug":313,"text":314},"разбор-стандартного-обмена-gratuitous-arp-g-arp-в-сети","Разбор стандартного обмена Gratuitous ARP (G-ARP) в сети",{"depth":30,"slug":316,"text":317},"4-динамический-и-статический-arp","4. Динамический и статический ARP",[],[],{"title":289,"description":321,"image":225,"date":322},"В этой работе мы подробно разберём, как работает ARP, от принципов обмена ARP-запросами и ответами, через анализ сетевого трафика с помощью Wireshark","9 февраля 2026",[],"ru/dhcp",{"id":324,"data":326,"body":328,"filePath":329,"digest":330,"rendered":331},{"title":327},"DHCP: настройка серверов, Relay и анализ трафика в Wireshark","В любой сети устройства должны получать IP-адреса, шлюзы и DNS-серверы, чтобы корректно обмениваться данными и иметь доступ в Интернет. Конечно, можно настраивать всё вручную, но в реальной жизни это неудобно и часто приводит к ошибкам. На помощь приходит протокол **DHCP (Dynamic Host Configuration Protocol)**. Его задача проста - автоматически раздавать клиентам все необходимые сетевые параметры, включая IP, маску подсети, шлюз и DNS.\n\nВ этой работе мы подробно разберём, как работает DHCP, от процесса обмена сообщениями **DORA (Discover, Offer, Request, Acknowledge)**, через анализ сетевого трафика в Wireshark, до настройки DHCP-сервера на MikroTik и Ubuntu-Server. Мы также рассмотрим дополнительные возможности протокола, такие как DHCP Relay, который позволяет обслуживать клиентов в других подсетях.\n\n\n### 1. Построить топологию\n\n![01_topology](/images/dhcp_net/01_topology.png)\n\nДля начала соберём в GNS3 простую сеть. В неё входят три клиента — Windows 10, Ubuntu и лёгкий эмулятор VPCS. Все они подключаются к коммутатору Switch-1, а коммутатор связан с маршрутизатором MikroTik. На данном этапе маршрутизатор будет выполнять исключительно роль DHCP-сервера, раздавая IP-адреса клиентам внутри сети.\n\nПодсеть *192.168.10.0/24* рассчитана на 254 рабочих хоста. Первый адрес в сети (192.168.10.0) зарезервирован как сетевой идентификатор, а последний (192.168.10.255) используется для широковещательных рассылок внутри подсети. Соответственно, рабочие адреса находятся в диапазоне от 192.168.10.1 до 192.168.10.254.\n\n* * *\n\n### 2. Настройка DHCP на MikroTik\n\n![02_mikrotik_admin](/images/dhcp_net/02_mikrotik_admin.png)\n\n![03_mikrotik_password](/images/dhcp_net/03_mikrotik_password.png)\n\nПереходим к настройке MikroTik. При первом запуске MikroTik через консоль, устройство запрашивает логин и пароль для входа. По умолчанию логин - **admin**, а пароль отсутствует (просто нажимаем Enter). Однако при первой настройке система обязательно требует задать новый пароль, так как пустой пароль оставить нельзя - это связано с тем, что новый пароль не может совпадать с текущим (то есть пустым) для безопасности доступа. Поэтому при вводе пустого пароля появится ошибка, и потребуется ввести пароль для последующего входа.\n\n* * *\n\n![04_setting_mikrotik](/images/dhcp_net/04_setting_mikrotik.png)\n\nПосле входа первым шагом назначаем IP-адрес интерфейсу, через который будут подключены клиенты — в нашем случае ether1. IP-адрес задаётся в рамках подсети 192.168.10.0/24, где «/24» указывает на маску подсети 255.255.255.0. Маска подсети определяет, какие адреса считаются частью локальной сети и позволяет устройствам корректно обмениваться данными между собой. Без назначения IP и маски клиенты не смогут взаимодействовать с сервером DHCP.\n\nСледующим шагом создаём пул IP-адресов — диапазон адресов, из которого DHCP-сервер будет автоматически выдавать IP клиентам. В нашем случае пул охватывает адреса от 192.168.10.10 до 192.168.10.100. Кроме того, при настройке DHCP указывается DNS-сервер, например 8.8.8.8, чтобы клиенты могли корректно разрешать имена в сети и в Интернете. Пул и указание DNS позволяют централизованно управлять распределением адресов, предотвращать конфликты и обеспечивать корректную работу всех устройств. Время аренды (lease) устанавливается на один день, что позволяет автоматически освобождать адреса от устройств, которые больше не подключены, и повторно использовать их для новых клиентов.\n\nИспользование пула также упрощает организацию сети: адреса вне пула можно резервировать для статических устройств, таких как серверы или принтеры, чтобы они не попадали под автоматическую выдачу DHCP. Таким образом, пул, маска подсети и DNS-сервер являются ключевыми элементами настройки DHCP, обеспечивая корректное, уникальное и управляемое распределение IP-адресов для всех клиентов.\n\n* * *\n\n### 3. Анализ DORA\n\n![05_dora_win](/images/dhcp_net/05_dora_win.png)\n\n* * *\n\n![06_dora_ubuntu](/images/dhcp_net/06_dora_ubuntu.png)\n\n* * *\n\n![07_dora_vpcs](/images/dhcp_net/07_dora_vpcs.png)\n\n* * *\n\n![08_ip_all](/images/dhcp_net/08_ip_all.png)\n\nПосле того как DHCP-сервер был поднят и включён, все устройства в сети автоматически получили свои настройки. Каждый клиент получил IP-адрес, который уникален в пределах пула, заданного на сервере, маску подсети, чтобы понимать, какие адреса относятся к локальной сети, шлюз, который в будущих задачах позволит устройствам выходить в другие сети, и DNS-сервер, чтобы корректно разрешать доменные имена. Кроме того, передаются и другие параметры, необходимые для нормальной работы сети, например время аренды адреса.\n\nВсе эти данные передаются по протоколу DHCP, и процесс получения IP-адреса клиентом можно проследить через последовательность сообщений DORA: Discover, Offer, Request и Acknowledgment. Сначала клиент рассылает запрос на получение адреса (Discover), сервер отвечает предложением свободного IP (Offer), клиент подтверждает выбор адреса (Request), а сервер завершает процесс, подтверждая выдачу IP (Acknowledgment). Благодаря этому механизму устройства получают все необходимые параметры автоматически и готовы к работе в сети.\n\nТеперь переходим к самому процессу DORA и разберём каждый его этап подробно на примере одного устройства, чтобы наглядно показать, что именно происходит между клиентом и сервером на каждом шаге.\n\n* * *\n\n![09_discover](/images/dhcp_net/09_discover.png)\n\nКогда устройство подключается к сети и ещё не имеет IP-адреса, оно отправляет **DHCP Discover** — первый шаг процесса DORA. Проще говоря, клиент сообщает сети, что он новый и хочет получить настройки для работы. Разберём, что при этом реально происходит на каждом уровне.\n\n**Канальный уровень (Ethernet II):** На этом уровне пакет отправляется широковещательно с адресом назначения `ff:ff:ff:ff:ff:ff`, чтобы все устройства в локальной сети получили сообщение. Это необходимо, так как клиент ещё не знает, где находится DHCP-сервер. Источник пакета — MAC-адрес клиента, уникальный идентификатор его сетевой карты. Благодаря этому любой DHCP-сервер в сети сможет определить, кто делает запрос и ответить на него.\n\n**Сетевой уровень (IP):** Клиент ещё не имеет IP-адреса, поэтому в качестве источника используется `0.0.0.0`. Назначение пакета — `255.255.255.255`, чтобы широковещательно достичь всех устройств локальной сети. Эта двойная широковещательная рассылка (на канальном и сетевом уровнях) гарантирует, что Discover дойдет до всех DHCP-серверов в подсети, даже если их несколько.\n\n**Транспортный уровень (UDP):** Клиент отправляет пакет через порт 68, а DHCP-серверы принимают его на порту 67. UDP используется для передачи без установки соединения, что упрощает и ускоряет процесс. Каждый сервер в сети получает возможность обработать запрос и предложить клиенту свободный IP-адрес.\n\n**Прикладной уровень (DHCP):** Основная информация запроса находится здесь. Тип сообщения — Discover, что обозначает поиск DHCP-сервера. Transaction ID уникален для этой попытки, чтобы клиент смог сопоставить полученные ответы с отправленным запросом. IP-поля ещё пусты, так как клиент не имеет адреса. Опции DHCP включают: Message Type = Discover, Client Identifier (MAC клиента), Host Name, Vendor class identifier (например, MSFT 5.0) и Parameter Request List с перечнем необходимых настроек — маска подсети, шлюз, DNS и другие параметры. Discover информирует серверы о присутствии нового клиента и его потребностях, позволяя начать процесс предоставления адреса и сетевых настроек.    \n\nИтак, **Discover** — это просто запрос клиента на получение IP и других настроек. Сервер пока ещё ничего не раздаёт, он только получает информацию о том, кто подключился и что именно нужно этому устройству.\n\n* * *\n\n![10_offer](/images/dhcp_net/10_offer.png)\n\nКогда DHCP-сервер получает Discover от клиента, он отвечает **DHCP Offer** — вторым шагом процесса DORA. Сервер предлагает клиенту конкретный IP-адрес и необходимые параметры сети. Пакет отправляется unicast, чтобы выбранный клиент получил предложение напрямую, а остальным серверам было понятно, что адрес занят.\n\n**Канальный уровень (Ethernet II):** На этом уровне пакет адресован напрямую MAC-адресу клиента (`0e:2a:b0:14:00:00`). Источник — MAC-адрес сервера (`0c:63:76:e4:00:00`). В отличие от Discover, это не широковещание, а unicast, поэтому сервер может напрямую сообщить клиенту, какой IP он предлагает.\n\n**Сетевой уровень (IP):** Источник пакета — IP сервера DHCP (192.168.10.1), а назначение — IP, который сервер предлагает клиенту (192.168.10.100). На этом уровне сервер «предлагает» клиенту адрес, который тот сможет использовать, как только подтвердит выбор.\n\n**Транспортный уровень (UDP):** Сервер использует порт 67 как источник, а клиент принимает на порту 68. UDP позволяет передать пакет быстро, без установления соединения, и гарантирует, что клиент получит предложение сервера.\n\n**Прикладной уровень (DHCP):** Тип сообщения — Offer, Transaction ID совпадает с Discover, чтобы клиент смог сопоставить ответ с отправленным запросом. Основное поле — Your (Client) IP address — содержит предлагаемый адрес (192.168.10.100). Опции DHCP включают Server Identifier (192.168.10.1), IP Address Lease Time, Subnet Mask, Router, DNS и Domain Name. Эти параметры позволяют клиенту узнать, какие настройки сети он получит при принятии адреса.\n\n**Итог:** DHCP Offer — это конкретное предложение от сервера клиенту с IP и сетевыми параметрами. На этом этапе клиент может принять предложение и перейти к следующему шагу — DHCP Request, чтобы окончательно закрепить адрес.\n\n* * *\n\n![11_request](/images/dhcp_net/11_request.png)\n\nПосле того как клиент получил предложение от сервера (**Offer**), он отправляет **DHCP Request** — третий шаг процесса DORA. В этом пакете клиент подтверждает свой выбор IP и уведомляет сеть о том, что собирается использовать предложенный адрес. При этом пакет отправляется широковещательно, чтобы выбранный сервер понял, что его оффер принят, а остальные DHCP-серверы могли освободить свои предложения.\n\n**Канальный уровень (Ethernet II):** Пакет адресован всем устройствам сети (`ff:ff:ff:ff:ff:ff`), что позволяет выбранному серверу увидеть подтверждение, а остальным серверам — понять, что их предложения отклонены и адреса могут вернуться в пул. Источник — MAC-адрес клиента (`0e:2a:b0:14:00:00`), уникальный идентификатор его сетевого интерфейса.\n\n**Сетевой уровень (IP):** Источник пакета — `0.0.0.0`, так как клиент ещё не получил окончательно назначенный IP. Назначение — `255.255.255.255` для доставки пакета всем устройствам локальной сети. Эта широковещательная рассылка гарантирует, что пакет достигнет выбранного сервера и всех остальных серверов, если они есть в сети.\n\n**Транспортный уровень (UDP):** Клиент использует порт 68 как источник, а сервер слушает порт 67 как пункт назначения. UDP позволяет передать пакет быстро и без установки соединения, обеспечивая доставку сообщения всем DHCP-серверам в сети.\n\n**Прикладной уровень (DHCP):** Тип сообщения — Request, Transaction ID совпадает с Discover и Offer, связывая всю транзакцию DORA. IP-поля ещё пусты, так как аренда адреса не подтверждена окончательно. Опции DHCP включают Message Type = Request, Server Identifier = 192.168.10.1, Requested IP = 192.168.10.100, Client Identifier = MAC клиента, Host Name = MSEDGEWIN10, Vendor class = MSFT 5.0, а также Parameter Request List с маской подсети, шлюзом, DNS и другими параметрами для финального ACK.\n\n**Итог:** DHCP Request уведомляет сеть о принятии предложения сервера. Клиент готов получить окончательное подтверждение, после чего IP и настройки сети станут действительными, что произойдет на следующем шаге — DHCP Acknowledgment.\n\n\n* * *\n\n![12_ack](/images/dhcp_net/12_ack.png)\n\nПосле того как клиент отправил **Request**, сервер подтверждает окончательный выбор IP-адреса и сетевых параметров с помощью **DHCP ACK** — четвертого и последнего шага процесса DORA. Этот пакет официально закрепляет за клиентом IP и все настройки сети, после чего устройство может начать полноценную работу в локальной сети.\n\n**Канальный уровень (Ethernet II):** На этом уровне пакет отправляется напрямую клиенту (unicast) на MAC-адрес `0e:2a:b0:14:00:00`. Источник — MAC-адрес DHCP-сервера (`0c:63:76:e4:00:00`). Unicast используется, чтобы точно доставить подтверждение выбранного адреса конкретному устройству и исключить ненужное широковещание.\n\n**Сетевой уровень (IP):** Источник пакета — IP сервера DHCP (192.168.10.1), а назначение — IP, который теперь официально закреплен за клиентом (192.168.10.100). На этом уровне пакет уже адресован непосредственно назначенному IP, что отличается от предыдущих шагов, где IP клиента ещё не был известен.\n\n**Транспортный уровень (UDP):** Сервер использует порт 67 как источник, а клиент принимает на порту 68. UDP обеспечивает быструю доставку без установки соединения и гарантирует, что клиент получит все параметры сети для корректной работы.\n\n**Прикладной уровень (DHCP):** Тип сообщения — ACK, Transaction ID совпадает с предыдущими пакетами Discover, Offer и Request, связывая всю транзакцию DORA. Поле Your (Client) IP address содержит назначенный IP (192.168.10.100). Опции DHCP включают окончательные параметры: Subnet Mask (255.255.255.0), Router (192.168.10.1), DNS-сервер (8.8.8.8), IP Address Lease Time (1 день), Server Identifier (192.168.10.1) и окончание списка (Option 255). Клиент применяет эти настройки к своему сетевому интерфейсу, после чего может полноценно работать в сети, включая доступ к внешним ресурсам через указанный шлюз и использование DNS для разрешения доменных имен.\n\n**Итог:** DHCP ACK завершает процесс DORA, официально назначая клиенту IP-адрес и сетевые параметры. После получения этого пакета устройство готово к работе в локальной сети с корректной конфигурацией и возможностью выхода в другие сети.\n\n* * *\n\n![13_mikrotik](/images/dhcp_net/13_mikrotik_lease_print.png)\n\nКоманда `ip dhcp-server lease print` на MikroTik показывает, какие IP-адреса сервер DHCP в данный момент выдал устройствам в сети. В нашем случае сервер dhcp1 раздал адреса трём устройствам: Windows, Ubuntu и VPCS.\n\nВ таблице видно, что каждому устройству присвоен уникальный IP из пула, указан его MAC-адрес и имя хоста. Статус bound означает, что аренда активна — то есть устройство сейчас использует этот IP и может полноценно работать в сети. Например, Windows получил 192.168.10.100, Ubuntu — 192.168.10.99, а VPCS — 192.168.10.98.\n\nDHCP-сервер успешно выполнил свою работу: все три устройства автоматически получили IP, маску подсети, шлюз и другие необходимые сетевые параметры. Они теперь могут обмениваться данными в локальной сети и в будущем использовать шлюз для выхода в другие подсети или интернет.\n\n* * *\n\n### 4. Анализ дополнительных сообщений DHCP\n\n#### Release\n\n![14_release_win](/images/dhcp_net/14_release_win.png)\n\n* * *\n\n![15_release_wireshark](/images/dhcp_net/15_release_wireshark.png)\n\n* * *\n\nКогда на клиентском компьютере Windows выполняется команда `ipconfig /release`, устройство сообщает DHCP-серверу, что больше не нуждается в арендованном IP-адресе. В нашем примере клиент отправляет **DHCP Release** серверу 192.168.10.1, освобождая адрес 192.168.10.100. Это значит, что сервер может вернуть этот IP обратно в пул свободных адресов, чтобы другие устройства могли его использовать.\n\nНа клиенте после выполнения команды IPv4-адрес исчезает, шлюз и DNS-сервер больше не назначены. Клиент не может обмениваться данными за пределами локальной сети, пока снова не получит адрес через DHCP. IPv6-адреса остаются, так как команда касается только IPv4.\n\nСетевой пакет Release отправляется **unicast** прямо на сервер (не широковещательно). Источник — старый IP клиента (192.168.10.100), а назначение — IP сервера (192.168.10.1). В пакете указаны тип сообщения (Release), идентификатор клиента (MAC) и идентификатор сервера, чтобы DHCP точно понял, какую аренду нужно завершить.\n\nНа сервере MikroTik после получения этого пакета запись об аренде для клиента немедленно обновляется: адрес возвращается в пул доступных, а статус аренды меняется с `bound` на `released` (или запись удаляется из списка активных арен).\n\nПроще говоря, **DHCP Release** — это способ клиента корректно «вернуть» IP серверу, завершив использование адреса. Так адрес больше не занят, сервер может выдать его другому устройству.\n\n* * *\n\n#### NAK\n\n![16_nak_wireshark](/images/dhcp_net/16_nak_wireshark.png)\n\nПосле того как клиент Windows освободил IP-адрес 192.168.10.100 с помощью команды **ipconfig /release**, сервер вернул этот адрес в пул свободных. Позже пул DHCP был изменён командой `/ip pool set dhcp_pool ranges=192.168.10.10-192.168.10.99` и теперь включает только адреса **192.168.10.10–192.168.10.99**. Когда Windows попытался снова получить IP 192.168.10.100, сервер ответил отрицательным подтверждением — **DHCP NAK**. Это сообщение говорит клиенту, что запрошенный адрес недействителен и использовать его нельзя.\n\nDHCP NAK рассылается широковещательно, чтобы гарантировать, что клиент получит уведомление. В сообщении сервер указывает, какой IP не может быть использован, и свой идентификатор, чтобы клиент точно понимал, что это ответ нужного сервера. Получив NAK, клиент сразу перестаёт использовать старый IP и запускает процесс получения нового адреса с нуля: сначала отправляет Discover, потом получает Offer, подтверждает Request и получает ACK с новым IP. В нашем случае Windows получил адрес **192.168.10.97**, который входит в текущий пул.\n\nПричины, по которым сервер может отправить NAK, разнообразны. Самая частая — клиент запросил адрес, который больше не входит в пул или уже занят другим устройством. Также NAK может возникнуть, если клиент пытается продлить аренду старого IP, который сервер больше не признаёт, или если указал неверный сервер для продления аренды. В целом, DHCP NAK — это механизм защиты, который предотвращает конфликты IP-адресов и гарантирует, что устройства используют только допустимые адреса из текущего пула.\n\n* * *\n\n#### INFORM\n\nПосле того как устройство уже получило IP-адрес и другие настройки через DHCP, иногда возникает необходимость запросить у DHCP-сервера только дополнительные параметры сети, не меняя при этом IP. Для этого используется сообщение DHCP INFORM. Клиент отправляет его на сервер, чтобы получить, например, актуальные DNS-серверы, доменное имя или другие опции, которые могут изменяться в сети, не затрагивая его текущий IP.\n\nСообщение INFORM отправляется с IP-адреса, который уже назначен устройству, и сервер отвечает обычным DHCP ACK, содержащим запрошенные параметры. Это полезно, если в сети обновились настройки DNS, шлюзы или другие сервисные параметры, и клиенту нужно их получить без запроса нового IP.\n\nВ отличие от Discover, Request или Release, INFORM не участвует в выдаче IP-адреса, а служит только для получения информации. Команды на Windows `ipconfig /renew`, на Linux `dhclient -1 -v -s 192.168.10.1>`\n\n* * *\n\n#### Decline\n\nСообщение **DHCP DECLINE** используется клиентом, когда он обнаруживает, что IP-адрес, предложенный DHCP-сервером, уже занят другим устройством. Например, клиент получил Offer с адресом 192.168.10.50, но проверка ARP показала, что этот адрес уже используется другим хостом. В этом случае клиент не может безопасно использовать IP и отправляет серверу сообщение DECLINE, чтобы уведомить о конфликте.\n\nПосле получения DECLINE сервер помечает этот адрес как недоступный и больше не выдаёт его другим клиентам, пока администратор или сервер не решат вопрос конфликта. Таким образом, DHCP DECLINE предотвращает конфликты IP-адресов в сети и обеспечивает корректную работу всех устройств.\n\nВажно отметить, что при DECLINE клиент **не теряет текущий рабочий IP**, если он уже использует какой-то другой адрес. Это чисто защитный механизм для обработки предложений от сервера, которые потенциально могут вызвать конфликт.\n\nПример использования: Windows и Linux автоматически отправляют DECLINE, если при проверке Offer обнаруживают совпадение IP в сети через ARP.\n\n* * *\n\n### 5. Статическая привязка IP\n\n![17_fixed_ip](/images/dhcp_net/17_fixed_ip_ubuntu.png)\n\n* * *\n\n![18_fixed_ip_ubuntu_wireshark](/images/dhcp_net/18_fixed_ip_ubuntu_wireshark.png)\n\n* * *\n\n![19_fixed_ip_mikrotik](/images/dhcp_net/19_fixed_ip_mikrotik.png)\n\nВ DHCP существует возможность **закрепить конкретный IP-адрес за определённым устройством**, используя его MAC-адрес. Этот механизм называется **Static Lease** (статическая аренда) и позволяет гарантировать, что выбранный клиент всегда будет получать один и тот же адрес, независимо от динамического пула.\n\nНа практике это делается так: администратор на MikroTik вручную создаёт запись, где указывает IP-адрес, MAC-адрес клиента, имя сервера DHCP и комментарий для удобства. В нашем случае виртуальной машине Ubuntu с MAC `0c:a2:21:ee:00:00` был назначен статический IP `192.168.10.105`. Команда для настройки выглядит следующим образом: `/ip dhcp-server lease add address=192.168.10.105 mac-address=0c:a2:21:ee:00:00 comment=\"Ubuntu fixed IP\" server=dhcp1`\n\nПосле применения этой настройки DHCP-сервер больше никогда не выдаст этот IP другому устройству. Если клиент с указанным MAC пытается использовать другой адрес из пула, сервер отправит NAK, и клиент будет вынужден запросить новую конфигурацию. В нашем примере Ubuntu сначала получила отказ, а затем, через стандартный процесс DORA, корректно получила закреплённый за ней адрес 192.168.10.105.\n\n* * *\n\n### 6. Настройка DHCP на Ubuntu\n\n![20_topology2](/images/dhcp_net/20_topology_2.png)\n\n* * *\n\n![21_disable_dhcp](/images/dhcp_net/21_disable_dhcp_mikrotik.png)\n\nМы переносим DHCP-сервер с MikroTik на Ubuntu. Раньше адреса раздавал MikroTik с IP 192.168.10.1, теперь это будет выделенный сервер Ubuntu. Сначала отключаем DHCP на MikroTik, чтобы клиенты больше не получали от него IP.\n\n* * *\n\n![22_isc_dhcp_server](/images/dhcp_net/22_isc_dhcp_server.png)\n\nСначала нужно убедиться, что сам пакет установлен. Если нет, ставим его командой: `sudo apt install isc-dhcp-server`. После установки нужно сказать серверу, на каком сетевом интерфейсе слушать запросы клиентов. Это делается в файле `/etc/default/isc-dhcp-server`. Открываем его и правим строку: `INTERFACESv4=\"ens3\"`. **ens3** — это имя моего сетевого интерфейса, у вас оно может быть другим.\n\n* * *\n\n![23_dhcpd](/images/dhcp_net/23_dhcpd.png)\n\nДальше идём в основной конфигурационный файл `/etc/dhcp/dhcpd.conf`. Там задаём параметры сети: пул выдаваемых адресов, шлюз, DNS и время аренды.\nТо есть сервер теперь знает, кому и какие адреса раздавать, через какой шлюз, какой DNS давать и на сколько времени выдавать аренду.\n\n* * *\n\n![24_restart_isc](/images/dhcp_net/24_restart_isc_dhcp.png)\n\nСерверу назначаем статический IP **192.168.10.2/24**. Теперь Ubuntu Server готова выдавать IP-адреса клиентам. Запускаем службу командой `sudo systemctl start isc-dhcp-server` Для проверки статуса `sudo systemctl status isc-dhcp-server`\n\n* * *\n\n![25_requested_ip](/images/dhcp_net/25_requested_ip_win.png)\n\n* * *\n\n![26_requested_ip_ubuntu](/images/dhcp_net/26_requested_ip_ubuntu.png)\n\nКогда клиенты начинают общаться с новым сервером, происходит вот что: Windows пытался взять старый адрес 192.168.10.97 — сервер его подтвердил, потому что адрес был свободен в новом пуле. А вот Ubuntu-клиент, который раньше имел статический адрес 192.168.10.105 на MikroTik, больше не может его получить, так как адрес не входит в новый диапазон. Сервер игнорирует этот запрос, и клиент заново отправляет Discover, получает Offer, делает Request и в итоге получает новый адрес из пула — 192.168.10.12.\n\n* * *\n\n![27_ubuntuserver_print](/images/dhcp_net/27_ubuntuserver_print.png)\n\nВ итоге, проверка таблицы аренд показывает: Windows сохранил свой старый адрес, Ubuntu получила новый, а vpc тоже получил свой IP из нового диапазона.\n\n* * *\n\n### 7. Настройка DHCP Relay\n\n![28_topology_3](/images/dhcp_net/28_topology_3.png)\n\nВ нашей сети теперь две подсети: старая 192.168.10.0/24 и новая 172.16.10.0/24. DHCP-сервер (Ubuntu Server, 192.168.10.2) пока знает только пул для первой подсети. То есть, если клиенты из новой подсети (PC2, PC3) отправляют DHCP Discover, сервер их просто не видит — широковещательные пакеты не переходит через маршрутизатор.\n\nЧтобы это исправить, мы используем MikroTik в роли DHCP Relay и настраиваем маршрутизацию.\n\n* * *\n\n#### 1. Настройка маршрутизации на MikroTik\n\n![29_route_mikroik](/images/dhcp_net/29_route_mikrotik.png)\n\nНа интерфейс ether2, который смотрит в новую подсеть 172.16.10.0/24, назначаем IP-адрес 172.16.10.1/24. Теперь маршрутизатор знает, что пакеты, предназначенные для этой подсети, идут через ether2, и может корректно маршрутизировать трафик между сетями. Также маршрутизация нужна для обратного пути: когда DHCP-сервер ответит, пакет должен попасть обратно в 172.16.10.0/24.\n\n* * *\n\n#### 2. Настройка DHCP Relay на MikroTik \n\n![30_dhcp_relay](/images/dhcp_net/30_dhcp_relay.png)\n\nDHCP Relay — это механизм, который позволяет клиентам из одной подсети обращаться к серверу в другой подсети, даже если сервер не находится в той же широковещательной области. Relay «слушает» DHCP-пакеты на интерфейсе клиентской сети и пересылает их серверу как обычные unicast-пакеты.\n\nНа MikroTik выглядет так:\n\n`/ip dhcp-relay add name=relay1 interface=ether2 dhcp-server=192.168.10.2 local-address=172.16.10.1\n/ip dhcp-relay enable relay1`\n\n- `interface=ether2` — интерфейс, на котором находится новая подсеть и клиенты, чьи пакеты нужно перехватывать.\n- `dhcp-server=192.168.10.2` — IP сервера, которому будут пересылаться запросы.\n- `local-address=172.16.10.1` — IP MikroTik в клиентской подсети, который будет указан как источник ответов для клиента. Без local-address пакеты Offer/ACK, возвращаемые сервером, могут не доходить до клиента, потому что клиент не умеет маршрутизировать их через другую подсеть.\n- `enable relay1` — активирует ранее созданный ретранслятор с именем relay1.\n\n* * *\n\n![31_cant_find](/images/dhcp_net/31_cant_find_pc2.png)\n\n* * *\n\n![32_add_subnet](/images/dhcp_net/32_add_subnet.png)\n\nПока сервер знает только сеть 192.168.10.0/24, Relay «доставит» Discover до сервера, но сервер не сможет выдать адрес, и клиент останется без IP. Поэтому перед запуском Relay нужно добавить новую подсеть в конфигурацию DHCP-сервера (/etc/dhcp/dhcpd.conf):\n\n* * *\n\n![33_pc2_pc3](/images/dhcp_net/33_pc2_pc3.png)\n\n* * *\n\n![34_offer_pc2](/images/dhcp_net/34_offer_pc2.png)\n\nPC1 и PC2 получили адреса. Анализируем DHCP Offer для клиента PC2. Сам сервер Ubuntu хочет выдать клиенту адрес из своего пула в первой подсети, но клиент находится во второй подсети 172.16.10.0/24. Пакет до клиента доходит через MikroTik, который выступает как DHCP Relay. Маршрутизатор подставляет в качестве источника свой локальный IP 172.16.10.1, чтобы пакет корректно дошёл до клиента, у которого нет прямого маршрута к серверу. Назначение пакета — IP 172.16.10.10, который сервер предлагает клиенту. В поле Next Server IP Address остаётся 192.168.10.2, показывая, что реальный DHCP-сервер находится в первой подсети. То есть пакет визуально идёт «от» MikroTik, но фактически это предложение от Ubuntu-сервера, и такой механизм позволяет клиенту в изолированной подсети получить IP-адрес и сетевые параметры.\n\n* * *\n\n#### 3. Как пакеты проходят через Relay (разбор по шагам)\n\n*   **Шаг 1: Discover от клиента (PC2/PC3)**  \n    Клиент из подсети 172.16.10.0/24 отправляет DHCP Discover широковещательно (`ff:ff:ff:ff:ff:ff`). Он ищет любой DHCP-сервер. Но так как сервер находится в другой подсети, пакет не дойдёт напрямую.\n    \n*   **Шаг 2: Перехват пакета MikroTik**  \n    DHCP Relay на MikroTik «ловит» этот Discover на ether2. Relay читает пакет и подставляет в него новый IP-адрес назначения — IP DHCP-сервера (192.168.10.2). Пакет теперь отправляется как unicast от MikroTik к серверу.\n    \n*   **Шаг 3: Сервер получает Discover**  \n    DHCP-сервер Ubuntu получает пакет. Пока что сервер знает только пул для 192.168.10.0/24, поэтому он не может выдать адрес для 172.16.10.0/24. Relay при желании может добавить опцию 82 (Agent Information), чтобы сервер понял, из какой подсети пришёл клиент и какой пул использовать.\n    \n*   **Шаг 4: Offer от сервера**  \n    Сервер формирует DHCP Offer для клиента. Если пул для 172.16.10.0/24 уже добавлен, сервер выбирает свободный IP из этого пула и отправляет пакет обратно на IP, с которого пришёл Discover (MikroTik).\n    \n*   **Шаг 5: MikroTik доставляет Offer клиенту**  \n    Когда пакет возвращается на MikroTik, он меняет IP-адрес источника на свой интерфейс в клиентской подсети (172.16.10.1), чтобы клиент мог принять ответ, и пересылает Offer клиенту.\n    \n*   **Шаг 6: Request и ACK**  \n    Клиент отвечает DHCP Request, сервер подтверждает DHCP ACK — весь процесс DORA полностью проходит через Relay. Клиент получает IP-адрес, шлюз и DNS, как будто сервер находится в его подсети.","src/content/articles/ru/dhcp.md","898b650716137f7f",{"html":332,"metadata":333},"\u003Cp>В любой сети устройства должны получать IP-адреса, шлюзы и DNS-серверы, чтобы корректно обмениваться данными и иметь доступ в Интернет. Конечно, можно настраивать всё вручную, но в реальной жизни это неудобно и часто приводит к ошибкам. На помощь приходит протокол \u003Cstrong>DHCP (Dynamic Host Configuration Protocol)\u003C/strong>. Его задача проста - автоматически раздавать клиентам все необходимые сетевые параметры, включая IP, маску подсети, шлюз и DNS.\u003C/p>\n\u003Cp>В этой работе мы подробно разберём, как работает DHCP, от процесса обмена сообщениями \u003Cstrong>DORA (Discover, Offer, Request, Acknowledge)\u003C/strong>, через анализ сетевого трафика в Wireshark, до настройки DHCP-сервера на MikroTik и Ubuntu-Server. Мы также рассмотрим дополнительные возможности протокола, такие как DHCP Relay, который позволяет обслуживать клиентов в других подсетях.\u003C/p>\n\u003Ch3 id=\"1-построить-топологию\">1. Построить топологию\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/01_topology.png\" alt=\"01_topology\">\u003C/p>\n\u003Cp>Для начала соберём в GNS3 простую сеть. В неё входят три клиента — Windows 10, Ubuntu и лёгкий эмулятор VPCS. Все они подключаются к коммутатору Switch-1, а коммутатор связан с маршрутизатором MikroTik. На данном этапе маршрутизатор будет выполнять исключительно роль DHCP-сервера, раздавая IP-адреса клиентам внутри сети.\u003C/p>\n\u003Cp>Подсеть \u003Cem>192.168.10.0/24\u003C/em> рассчитана на 254 рабочих хоста. Первый адрес в сети (192.168.10.0) зарезервирован как сетевой идентификатор, а последний (192.168.10.255) используется для широковещательных рассылок внутри подсети. Соответственно, рабочие адреса находятся в диапазоне от 192.168.10.1 до 192.168.10.254.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"2-настройка-dhcp-на-mikrotik\">2. Настройка DHCP на MikroTik\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/02_mikrotik_admin.png\" alt=\"02_mikrotik_admin\">\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/03_mikrotik_password.png\" alt=\"03_mikrotik_password\">\u003C/p>\n\u003Cp>Переходим к настройке MikroTik. При первом запуске MikroTik через консоль, устройство запрашивает логин и пароль для входа. По умолчанию логин - \u003Cstrong>admin\u003C/strong>, а пароль отсутствует (просто нажимаем Enter). Однако при первой настройке система обязательно требует задать новый пароль, так как пустой пароль оставить нельзя - это связано с тем, что новый пароль не может совпадать с текущим (то есть пустым) для безопасности доступа. Поэтому при вводе пустого пароля появится ошибка, и потребуется ввести пароль для последующего входа.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/04_setting_mikrotik.png\" alt=\"04_setting_mikrotik\">\u003C/p>\n\u003Cp>После входа первым шагом назначаем IP-адрес интерфейсу, через который будут подключены клиенты — в нашем случае ether1. IP-адрес задаётся в рамках подсети 192.168.10.0/24, где «/24» указывает на маску подсети 255.255.255.0. Маска подсети определяет, какие адреса считаются частью локальной сети и позволяет устройствам корректно обмениваться данными между собой. Без назначения IP и маски клиенты не смогут взаимодействовать с сервером DHCP.\u003C/p>\n\u003Cp>Следующим шагом создаём пул IP-адресов — диапазон адресов, из которого DHCP-сервер будет автоматически выдавать IP клиентам. В нашем случае пул охватывает адреса от 192.168.10.10 до 192.168.10.100. Кроме того, при настройке DHCP указывается DNS-сервер, например 8.8.8.8, чтобы клиенты могли корректно разрешать имена в сети и в Интернете. Пул и указание DNS позволяют централизованно управлять распределением адресов, предотвращать конфликты и обеспечивать корректную работу всех устройств. Время аренды (lease) устанавливается на один день, что позволяет автоматически освобождать адреса от устройств, которые больше не подключены, и повторно использовать их для новых клиентов.\u003C/p>\n\u003Cp>Использование пула также упрощает организацию сети: адреса вне пула можно резервировать для статических устройств, таких как серверы или принтеры, чтобы они не попадали под автоматическую выдачу DHCP. Таким образом, пул, маска подсети и DNS-сервер являются ключевыми элементами настройки DHCP, обеспечивая корректное, уникальное и управляемое распределение IP-адресов для всех клиентов.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"3-анализ-dora\">3. Анализ DORA\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/05_dora_win.png\" alt=\"05_dora_win\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/06_dora_ubuntu.png\" alt=\"06_dora_ubuntu\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/07_dora_vpcs.png\" alt=\"07_dora_vpcs\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/08_ip_all.png\" alt=\"08_ip_all\">\u003C/p>\n\u003Cp>После того как DHCP-сервер был поднят и включён, все устройства в сети автоматически получили свои настройки. Каждый клиент получил IP-адрес, который уникален в пределах пула, заданного на сервере, маску подсети, чтобы понимать, какие адреса относятся к локальной сети, шлюз, который в будущих задачах позволит устройствам выходить в другие сети, и DNS-сервер, чтобы корректно разрешать доменные имена. Кроме того, передаются и другие параметры, необходимые для нормальной работы сети, например время аренды адреса.\u003C/p>\n\u003Cp>Все эти данные передаются по протоколу DHCP, и процесс получения IP-адреса клиентом можно проследить через последовательность сообщений DORA: Discover, Offer, Request и Acknowledgment. Сначала клиент рассылает запрос на получение адреса (Discover), сервер отвечает предложением свободного IP (Offer), клиент подтверждает выбор адреса (Request), а сервер завершает процесс, подтверждая выдачу IP (Acknowledgment). Благодаря этому механизму устройства получают все необходимые параметры автоматически и готовы к работе в сети.\u003C/p>\n\u003Cp>Теперь переходим к самому процессу DORA и разберём каждый его этап подробно на примере одного устройства, чтобы наглядно показать, что именно происходит между клиентом и сервером на каждом шаге.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/09_discover.png\" alt=\"09_discover\">\u003C/p>\n\u003Cp>Когда устройство подключается к сети и ещё не имеет IP-адреса, оно отправляет \u003Cstrong>DHCP Discover\u003C/strong> — первый шаг процесса DORA. Проще говоря, клиент сообщает сети, что он новый и хочет получить настройки для работы. Разберём, что при этом реально происходит на каждом уровне.\u003C/p>\n\u003Cp>\u003Cstrong>Канальный уровень (Ethernet II):\u003C/strong> На этом уровне пакет отправляется широковещательно с адресом назначения \u003Ccode>ff:ff:ff:ff:ff:ff\u003C/code>, чтобы все устройства в локальной сети получили сообщение. Это необходимо, так как клиент ещё не знает, где находится DHCP-сервер. Источник пакета — MAC-адрес клиента, уникальный идентификатор его сетевой карты. Благодаря этому любой DHCP-сервер в сети сможет определить, кто делает запрос и ответить на него.\u003C/p>\n\u003Cp>\u003Cstrong>Сетевой уровень (IP):\u003C/strong> Клиент ещё не имеет IP-адреса, поэтому в качестве источника используется \u003Ccode>0.0.0.0\u003C/code>. Назначение пакета — \u003Ccode>255.255.255.255\u003C/code>, чтобы широковещательно достичь всех устройств локальной сети. Эта двойная широковещательная рассылка (на канальном и сетевом уровнях) гарантирует, что Discover дойдет до всех DHCP-серверов в подсети, даже если их несколько.\u003C/p>\n\u003Cp>\u003Cstrong>Транспортный уровень (UDP):\u003C/strong> Клиент отправляет пакет через порт 68, а DHCP-серверы принимают его на порту 67. UDP используется для передачи без установки соединения, что упрощает и ускоряет процесс. Каждый сервер в сети получает возможность обработать запрос и предложить клиенту свободный IP-адрес.\u003C/p>\n\u003Cp>\u003Cstrong>Прикладной уровень (DHCP):\u003C/strong> Основная информация запроса находится здесь. Тип сообщения — Discover, что обозначает поиск DHCP-сервера. Transaction ID уникален для этой попытки, чтобы клиент смог сопоставить полученные ответы с отправленным запросом. IP-поля ещё пусты, так как клиент не имеет адреса. Опции DHCP включают: Message Type = Discover, Client Identifier (MAC клиента), Host Name, Vendor class identifier (например, MSFT 5.0) и Parameter Request List с перечнем необходимых настроек — маска подсети, шлюз, DNS и другие параметры. Discover информирует серверы о присутствии нового клиента и его потребностях, позволяя начать процесс предоставления адреса и сетевых настроек.\u003C/p>\n\u003Cp>Итак, \u003Cstrong>Discover\u003C/strong> — это просто запрос клиента на получение IP и других настроек. Сервер пока ещё ничего не раздаёт, он только получает информацию о том, кто подключился и что именно нужно этому устройству.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/10_offer.png\" alt=\"10_offer\">\u003C/p>\n\u003Cp>Когда DHCP-сервер получает Discover от клиента, он отвечает \u003Cstrong>DHCP Offer\u003C/strong> — вторым шагом процесса DORA. Сервер предлагает клиенту конкретный IP-адрес и необходимые параметры сети. Пакет отправляется unicast, чтобы выбранный клиент получил предложение напрямую, а остальным серверам было понятно, что адрес занят.\u003C/p>\n\u003Cp>\u003Cstrong>Канальный уровень (Ethernet II):\u003C/strong> На этом уровне пакет адресован напрямую MAC-адресу клиента (\u003Ccode>0e:2a:b0:14:00:00\u003C/code>). Источник — MAC-адрес сервера (\u003Ccode>0c:63:76:e4:00:00\u003C/code>). В отличие от Discover, это не широковещание, а unicast, поэтому сервер может напрямую сообщить клиенту, какой IP он предлагает.\u003C/p>\n\u003Cp>\u003Cstrong>Сетевой уровень (IP):\u003C/strong> Источник пакета — IP сервера DHCP (192.168.10.1), а назначение — IP, который сервер предлагает клиенту (192.168.10.100). На этом уровне сервер «предлагает» клиенту адрес, который тот сможет использовать, как только подтвердит выбор.\u003C/p>\n\u003Cp>\u003Cstrong>Транспортный уровень (UDP):\u003C/strong> Сервер использует порт 67 как источник, а клиент принимает на порту 68. UDP позволяет передать пакет быстро, без установления соединения, и гарантирует, что клиент получит предложение сервера.\u003C/p>\n\u003Cp>\u003Cstrong>Прикладной уровень (DHCP):\u003C/strong> Тип сообщения — Offer, Transaction ID совпадает с Discover, чтобы клиент смог сопоставить ответ с отправленным запросом. Основное поле — Your (Client) IP address — содержит предлагаемый адрес (192.168.10.100). Опции DHCP включают Server Identifier (192.168.10.1), IP Address Lease Time, Subnet Mask, Router, DNS и Domain Name. Эти параметры позволяют клиенту узнать, какие настройки сети он получит при принятии адреса.\u003C/p>\n\u003Cp>\u003Cstrong>Итог:\u003C/strong> DHCP Offer — это конкретное предложение от сервера клиенту с IP и сетевыми параметрами. На этом этапе клиент может принять предложение и перейти к следующему шагу — DHCP Request, чтобы окончательно закрепить адрес.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/11_request.png\" alt=\"11_request\">\u003C/p>\n\u003Cp>После того как клиент получил предложение от сервера (\u003Cstrong>Offer\u003C/strong>), он отправляет \u003Cstrong>DHCP Request\u003C/strong> — третий шаг процесса DORA. В этом пакете клиент подтверждает свой выбор IP и уведомляет сеть о том, что собирается использовать предложенный адрес. При этом пакет отправляется широковещательно, чтобы выбранный сервер понял, что его оффер принят, а остальные DHCP-серверы могли освободить свои предложения.\u003C/p>\n\u003Cp>\u003Cstrong>Канальный уровень (Ethernet II):\u003C/strong> Пакет адресован всем устройствам сети (\u003Ccode>ff:ff:ff:ff:ff:ff\u003C/code>), что позволяет выбранному серверу увидеть подтверждение, а остальным серверам — понять, что их предложения отклонены и адреса могут вернуться в пул. Источник — MAC-адрес клиента (\u003Ccode>0e:2a:b0:14:00:00\u003C/code>), уникальный идентификатор его сетевого интерфейса.\u003C/p>\n\u003Cp>\u003Cstrong>Сетевой уровень (IP):\u003C/strong> Источник пакета — \u003Ccode>0.0.0.0\u003C/code>, так как клиент ещё не получил окончательно назначенный IP. Назначение — \u003Ccode>255.255.255.255\u003C/code> для доставки пакета всем устройствам локальной сети. Эта широковещательная рассылка гарантирует, что пакет достигнет выбранного сервера и всех остальных серверов, если они есть в сети.\u003C/p>\n\u003Cp>\u003Cstrong>Транспортный уровень (UDP):\u003C/strong> Клиент использует порт 68 как источник, а сервер слушает порт 67 как пункт назначения. UDP позволяет передать пакет быстро и без установки соединения, обеспечивая доставку сообщения всем DHCP-серверам в сети.\u003C/p>\n\u003Cp>\u003Cstrong>Прикладной уровень (DHCP):\u003C/strong> Тип сообщения — Request, Transaction ID совпадает с Discover и Offer, связывая всю транзакцию DORA. IP-поля ещё пусты, так как аренда адреса не подтверждена окончательно. Опции DHCP включают Message Type = Request, Server Identifier = 192.168.10.1, Requested IP = 192.168.10.100, Client Identifier = MAC клиента, Host Name = MSEDGEWIN10, Vendor class = MSFT 5.0, а также Parameter Request List с маской подсети, шлюзом, DNS и другими параметрами для финального ACK.\u003C/p>\n\u003Cp>\u003Cstrong>Итог:\u003C/strong> DHCP Request уведомляет сеть о принятии предложения сервера. Клиент готов получить окончательное подтверждение, после чего IP и настройки сети станут действительными, что произойдет на следующем шаге — DHCP Acknowledgment.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/12_ack.png\" alt=\"12_ack\">\u003C/p>\n\u003Cp>После того как клиент отправил \u003Cstrong>Request\u003C/strong>, сервер подтверждает окончательный выбор IP-адреса и сетевых параметров с помощью \u003Cstrong>DHCP ACK\u003C/strong> — четвертого и последнего шага процесса DORA. Этот пакет официально закрепляет за клиентом IP и все настройки сети, после чего устройство может начать полноценную работу в локальной сети.\u003C/p>\n\u003Cp>\u003Cstrong>Канальный уровень (Ethernet II):\u003C/strong> На этом уровне пакет отправляется напрямую клиенту (unicast) на MAC-адрес \u003Ccode>0e:2a:b0:14:00:00\u003C/code>. Источник — MAC-адрес DHCP-сервера (\u003Ccode>0c:63:76:e4:00:00\u003C/code>). Unicast используется, чтобы точно доставить подтверждение выбранного адреса конкретному устройству и исключить ненужное широковещание.\u003C/p>\n\u003Cp>\u003Cstrong>Сетевой уровень (IP):\u003C/strong> Источник пакета — IP сервера DHCP (192.168.10.1), а назначение — IP, который теперь официально закреплен за клиентом (192.168.10.100). На этом уровне пакет уже адресован непосредственно назначенному IP, что отличается от предыдущих шагов, где IP клиента ещё не был известен.\u003C/p>\n\u003Cp>\u003Cstrong>Транспортный уровень (UDP):\u003C/strong> Сервер использует порт 67 как источник, а клиент принимает на порту 68. UDP обеспечивает быструю доставку без установки соединения и гарантирует, что клиент получит все параметры сети для корректной работы.\u003C/p>\n\u003Cp>\u003Cstrong>Прикладной уровень (DHCP):\u003C/strong> Тип сообщения — ACK, Transaction ID совпадает с предыдущими пакетами Discover, Offer и Request, связывая всю транзакцию DORA. Поле Your (Client) IP address содержит назначенный IP (192.168.10.100). Опции DHCP включают окончательные параметры: Subnet Mask (255.255.255.0), Router (192.168.10.1), DNS-сервер (8.8.8.8), IP Address Lease Time (1 день), Server Identifier (192.168.10.1) и окончание списка (Option 255). Клиент применяет эти настройки к своему сетевому интерфейсу, после чего может полноценно работать в сети, включая доступ к внешним ресурсам через указанный шлюз и использование DNS для разрешения доменных имен.\u003C/p>\n\u003Cp>\u003Cstrong>Итог:\u003C/strong> DHCP ACK завершает процесс DORA, официально назначая клиенту IP-адрес и сетевые параметры. После получения этого пакета устройство готово к работе в локальной сети с корректной конфигурацией и возможностью выхода в другие сети.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/13_mikrotik_lease_print.png\" alt=\"13_mikrotik\">\u003C/p>\n\u003Cp>Команда \u003Ccode>ip dhcp-server lease print\u003C/code> на MikroTik показывает, какие IP-адреса сервер DHCP в данный момент выдал устройствам в сети. В нашем случае сервер dhcp1 раздал адреса трём устройствам: Windows, Ubuntu и VPCS.\u003C/p>\n\u003Cp>В таблице видно, что каждому устройству присвоен уникальный IP из пула, указан его MAC-адрес и имя хоста. Статус bound означает, что аренда активна — то есть устройство сейчас использует этот IP и может полноценно работать в сети. Например, Windows получил 192.168.10.100, Ubuntu — 192.168.10.99, а VPCS — 192.168.10.98.\u003C/p>\n\u003Cp>DHCP-сервер успешно выполнил свою работу: все три устройства автоматически получили IP, маску подсети, шлюз и другие необходимые сетевые параметры. Они теперь могут обмениваться данными в локальной сети и в будущем использовать шлюз для выхода в другие подсети или интернет.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"4-анализ-дополнительных-сообщений-dhcp\">4. Анализ дополнительных сообщений DHCP\u003C/h3>\n\u003Ch4 id=\"release\">Release\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/14_release_win.png\" alt=\"14_release_win\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/15_release_wireshark.png\" alt=\"15_release_wireshark\">\u003C/p>\n\u003Chr>\n\u003Cp>Когда на клиентском компьютере Windows выполняется команда \u003Ccode>ipconfig /release\u003C/code>, устройство сообщает DHCP-серверу, что больше не нуждается в арендованном IP-адресе. В нашем примере клиент отправляет \u003Cstrong>DHCP Release\u003C/strong> серверу 192.168.10.1, освобождая адрес 192.168.10.100. Это значит, что сервер может вернуть этот IP обратно в пул свободных адресов, чтобы другие устройства могли его использовать.\u003C/p>\n\u003Cp>На клиенте после выполнения команды IPv4-адрес исчезает, шлюз и DNS-сервер больше не назначены. Клиент не может обмениваться данными за пределами локальной сети, пока снова не получит адрес через DHCP. IPv6-адреса остаются, так как команда касается только IPv4.\u003C/p>\n\u003Cp>Сетевой пакет Release отправляется \u003Cstrong>unicast\u003C/strong> прямо на сервер (не широковещательно). Источник — старый IP клиента (192.168.10.100), а назначение — IP сервера (192.168.10.1). В пакете указаны тип сообщения (Release), идентификатор клиента (MAC) и идентификатор сервера, чтобы DHCP точно понял, какую аренду нужно завершить.\u003C/p>\n\u003Cp>На сервере MikroTik после получения этого пакета запись об аренде для клиента немедленно обновляется: адрес возвращается в пул доступных, а статус аренды меняется с \u003Ccode>bound\u003C/code> на \u003Ccode>released\u003C/code> (или запись удаляется из списка активных арен).\u003C/p>\n\u003Cp>Проще говоря, \u003Cstrong>DHCP Release\u003C/strong> — это способ клиента корректно «вернуть» IP серверу, завершив использование адреса. Так адрес больше не занят, сервер может выдать его другому устройству.\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"nak\">NAK\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/16_nak_wireshark.png\" alt=\"16_nak_wireshark\">\u003C/p>\n\u003Cp>После того как клиент Windows освободил IP-адрес 192.168.10.100 с помощью команды \u003Cstrong>ipconfig /release\u003C/strong>, сервер вернул этот адрес в пул свободных. Позже пул DHCP был изменён командой \u003Ccode>/ip pool set dhcp_pool ranges=192.168.10.10-192.168.10.99\u003C/code> и теперь включает только адреса \u003Cstrong>192.168.10.10–192.168.10.99\u003C/strong>. Когда Windows попытался снова получить IP 192.168.10.100, сервер ответил отрицательным подтверждением — \u003Cstrong>DHCP NAK\u003C/strong>. Это сообщение говорит клиенту, что запрошенный адрес недействителен и использовать его нельзя.\u003C/p>\n\u003Cp>DHCP NAK рассылается широковещательно, чтобы гарантировать, что клиент получит уведомление. В сообщении сервер указывает, какой IP не может быть использован, и свой идентификатор, чтобы клиент точно понимал, что это ответ нужного сервера. Получив NAK, клиент сразу перестаёт использовать старый IP и запускает процесс получения нового адреса с нуля: сначала отправляет Discover, потом получает Offer, подтверждает Request и получает ACK с новым IP. В нашем случае Windows получил адрес \u003Cstrong>192.168.10.97\u003C/strong>, который входит в текущий пул.\u003C/p>\n\u003Cp>Причины, по которым сервер может отправить NAK, разнообразны. Самая частая — клиент запросил адрес, который больше не входит в пул или уже занят другим устройством. Также NAK может возникнуть, если клиент пытается продлить аренду старого IP, который сервер больше не признаёт, или если указал неверный сервер для продления аренды. В целом, DHCP NAK — это механизм защиты, который предотвращает конфликты IP-адресов и гарантирует, что устройства используют только допустимые адреса из текущего пула.\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"inform\">INFORM\u003C/h4>\n\u003Cp>После того как устройство уже получило IP-адрес и другие настройки через DHCP, иногда возникает необходимость запросить у DHCP-сервера только дополнительные параметры сети, не меняя при этом IP. Для этого используется сообщение DHCP INFORM. Клиент отправляет его на сервер, чтобы получить, например, актуальные DNS-серверы, доменное имя или другие опции, которые могут изменяться в сети, не затрагивая его текущий IP.\u003C/p>\n\u003Cp>Сообщение INFORM отправляется с IP-адреса, который уже назначен устройству, и сервер отвечает обычным DHCP ACK, содержащим запрошенные параметры. Это полезно, если в сети обновились настройки DNS, шлюзы или другие сервисные параметры, и клиенту нужно их получить без запроса нового IP.\u003C/p>\n\u003Cp>В отличие от Discover, Request или Release, INFORM не участвует в выдаче IP-адреса, а служит только для получения информации. Команды на Windows \u003Ccode>ipconfig /renew\u003C/code>, на Linux \u003Ccode>dhclient -1 -v -s 192.168.10.1>\u003C/code>\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"decline\">Decline\u003C/h4>\n\u003Cp>Сообщение \u003Cstrong>DHCP DECLINE\u003C/strong> используется клиентом, когда он обнаруживает, что IP-адрес, предложенный DHCP-сервером, уже занят другим устройством. Например, клиент получил Offer с адресом 192.168.10.50, но проверка ARP показала, что этот адрес уже используется другим хостом. В этом случае клиент не может безопасно использовать IP и отправляет серверу сообщение DECLINE, чтобы уведомить о конфликте.\u003C/p>\n\u003Cp>После получения DECLINE сервер помечает этот адрес как недоступный и больше не выдаёт его другим клиентам, пока администратор или сервер не решат вопрос конфликта. Таким образом, DHCP DECLINE предотвращает конфликты IP-адресов в сети и обеспечивает корректную работу всех устройств.\u003C/p>\n\u003Cp>Важно отметить, что при DECLINE клиент \u003Cstrong>не теряет текущий рабочий IP\u003C/strong>, если он уже использует какой-то другой адрес. Это чисто защитный механизм для обработки предложений от сервера, которые потенциально могут вызвать конфликт.\u003C/p>\n\u003Cp>Пример использования: Windows и Linux автоматически отправляют DECLINE, если при проверке Offer обнаруживают совпадение IP в сети через ARP.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"5-статическая-привязка-ip\">5. Статическая привязка IP\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/17_fixed_ip_ubuntu.png\" alt=\"17_fixed_ip\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/18_fixed_ip_ubuntu_wireshark.png\" alt=\"18_fixed_ip_ubuntu_wireshark\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/19_fixed_ip_mikrotik.png\" alt=\"19_fixed_ip_mikrotik\">\u003C/p>\n\u003Cp>В DHCP существует возможность \u003Cstrong>закрепить конкретный IP-адрес за определённым устройством\u003C/strong>, используя его MAC-адрес. Этот механизм называется \u003Cstrong>Static Lease\u003C/strong> (статическая аренда) и позволяет гарантировать, что выбранный клиент всегда будет получать один и тот же адрес, независимо от динамического пула.\u003C/p>\n\u003Cp>На практике это делается так: администратор на MikroTik вручную создаёт запись, где указывает IP-адрес, MAC-адрес клиента, имя сервера DHCP и комментарий для удобства. В нашем случае виртуальной машине Ubuntu с MAC \u003Ccode>0c:a2:21:ee:00:00\u003C/code> был назначен статический IP \u003Ccode>192.168.10.105\u003C/code>. Команда для настройки выглядит следующим образом: \u003Ccode>/ip dhcp-server lease add address=192.168.10.105 mac-address=0c:a2:21:ee:00:00 comment=\"Ubuntu fixed IP\" server=dhcp1\u003C/code>\u003C/p>\n\u003Cp>После применения этой настройки DHCP-сервер больше никогда не выдаст этот IP другому устройству. Если клиент с указанным MAC пытается использовать другой адрес из пула, сервер отправит NAK, и клиент будет вынужден запросить новую конфигурацию. В нашем примере Ubuntu сначала получила отказ, а затем, через стандартный процесс DORA, корректно получила закреплённый за ней адрес 192.168.10.105.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"6-настройка-dhcp-на-ubuntu\">6. Настройка DHCP на Ubuntu\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/20_topology_2.png\" alt=\"20_topology2\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/21_disable_dhcp_mikrotik.png\" alt=\"21_disable_dhcp\">\u003C/p>\n\u003Cp>Мы переносим DHCP-сервер с MikroTik на Ubuntu. Раньше адреса раздавал MikroTik с IP 192.168.10.1, теперь это будет выделенный сервер Ubuntu. Сначала отключаем DHCP на MikroTik, чтобы клиенты больше не получали от него IP.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/22_isc_dhcp_server.png\" alt=\"22_isc_dhcp_server\">\u003C/p>\n\u003Cp>Сначала нужно убедиться, что сам пакет установлен. Если нет, ставим его командой: \u003Ccode>sudo apt install isc-dhcp-server\u003C/code>. После установки нужно сказать серверу, на каком сетевом интерфейсе слушать запросы клиентов. Это делается в файле \u003Ccode>/etc/default/isc-dhcp-server\u003C/code>. Открываем его и правим строку: \u003Ccode>INTERFACESv4=\"ens3\"\u003C/code>. \u003Cstrong>ens3\u003C/strong> — это имя моего сетевого интерфейса, у вас оно может быть другим.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/23_dhcpd.png\" alt=\"23_dhcpd\">\u003C/p>\n\u003Cp>Дальше идём в основной конфигурационный файл \u003Ccode>/etc/dhcp/dhcpd.conf\u003C/code>. Там задаём параметры сети: пул выдаваемых адресов, шлюз, DNS и время аренды.\nТо есть сервер теперь знает, кому и какие адреса раздавать, через какой шлюз, какой DNS давать и на сколько времени выдавать аренду.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/24_restart_isc_dhcp.png\" alt=\"24_restart_isc\">\u003C/p>\n\u003Cp>Серверу назначаем статический IP \u003Cstrong>192.168.10.2/24\u003C/strong>. Теперь Ubuntu Server готова выдавать IP-адреса клиентам. Запускаем службу командой \u003Ccode>sudo systemctl start isc-dhcp-server\u003C/code> Для проверки статуса \u003Ccode>sudo systemctl status isc-dhcp-server\u003C/code>\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/25_requested_ip_win.png\" alt=\"25_requested_ip\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/26_requested_ip_ubuntu.png\" alt=\"26_requested_ip_ubuntu\">\u003C/p>\n\u003Cp>Когда клиенты начинают общаться с новым сервером, происходит вот что: Windows пытался взять старый адрес 192.168.10.97 — сервер его подтвердил, потому что адрес был свободен в новом пуле. А вот Ubuntu-клиент, который раньше имел статический адрес 192.168.10.105 на MikroTik, больше не может его получить, так как адрес не входит в новый диапазон. Сервер игнорирует этот запрос, и клиент заново отправляет Discover, получает Offer, делает Request и в итоге получает новый адрес из пула — 192.168.10.12.\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/27_ubuntuserver_print.png\" alt=\"27_ubuntuserver_print\">\u003C/p>\n\u003Cp>В итоге, проверка таблицы аренд показывает: Windows сохранил свой старый адрес, Ubuntu получила новый, а vpc тоже получил свой IP из нового диапазона.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"7-настройка-dhcp-relay\">7. Настройка DHCP Relay\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/28_topology_3.png\" alt=\"28_topology_3\">\u003C/p>\n\u003Cp>В нашей сети теперь две подсети: старая 192.168.10.0/24 и новая 172.16.10.0/24. DHCP-сервер (Ubuntu Server, 192.168.10.2) пока знает только пул для первой подсети. То есть, если клиенты из новой подсети (PC2, PC3) отправляют DHCP Discover, сервер их просто не видит — широковещательные пакеты не переходит через маршрутизатор.\u003C/p>\n\u003Cp>Чтобы это исправить, мы используем MikroTik в роли DHCP Relay и настраиваем маршрутизацию.\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"1-настройка-маршрутизации-на-mikrotik\">1. Настройка маршрутизации на MikroTik\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/29_route_mikrotik.png\" alt=\"29_route_mikroik\">\u003C/p>\n\u003Cp>На интерфейс ether2, который смотрит в новую подсеть 172.16.10.0/24, назначаем IP-адрес 172.16.10.1/24. Теперь маршрутизатор знает, что пакеты, предназначенные для этой подсети, идут через ether2, и может корректно маршрутизировать трафик между сетями. Также маршрутизация нужна для обратного пути: когда DHCP-сервер ответит, пакет должен попасть обратно в 172.16.10.0/24.\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"2-настройка-dhcp-relay-на-mikrotik\">2. Настройка DHCP Relay на MikroTik\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/30_dhcp_relay.png\" alt=\"30_dhcp_relay\">\u003C/p>\n\u003Cp>DHCP Relay — это механизм, который позволяет клиентам из одной подсети обращаться к серверу в другой подсети, даже если сервер не находится в той же широковещательной области. Relay «слушает» DHCP-пакеты на интерфейсе клиентской сети и пересылает их серверу как обычные unicast-пакеты.\u003C/p>\n\u003Cp>На MikroTik выглядет так:\u003C/p>\n\u003Cp>\u003Ccode>/ip dhcp-relay add name=relay1 interface=ether2 dhcp-server=192.168.10.2 local-address=172.16.10.1 /ip dhcp-relay enable relay1\u003C/code>\u003C/p>\n\u003Cul>\n\u003Cli>\u003Ccode>interface=ether2\u003C/code> — интерфейс, на котором находится новая подсеть и клиенты, чьи пакеты нужно перехватывать.\u003C/li>\n\u003Cli>\u003Ccode>dhcp-server=192.168.10.2\u003C/code> — IP сервера, которому будут пересылаться запросы.\u003C/li>\n\u003Cli>\u003Ccode>local-address=172.16.10.1\u003C/code> — IP MikroTik в клиентской подсети, который будет указан как источник ответов для клиента. Без local-address пакеты Offer/ACK, возвращаемые сервером, могут не доходить до клиента, потому что клиент не умеет маршрутизировать их через другую подсеть.\u003C/li>\n\u003Cli>\u003Ccode>enable relay1\u003C/code> — активирует ранее созданный ретранслятор с именем relay1.\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/31_cant_find_pc2.png\" alt=\"31_cant_find\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/32_add_subnet.png\" alt=\"32_add_subnet\">\u003C/p>\n\u003Cp>Пока сервер знает только сеть 192.168.10.0/24, Relay «доставит» Discover до сервера, но сервер не сможет выдать адрес, и клиент останется без IP. Поэтому перед запуском Relay нужно добавить новую подсеть в конфигурацию DHCP-сервера (/etc/dhcp/dhcpd.conf):\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/33_pc2_pc3.png\" alt=\"33_pc2_pc3\">\u003C/p>\n\u003Chr>\n\u003Cp>\u003Cimg src=\"/images/dhcp_net/34_offer_pc2.png\" alt=\"34_offer_pc2\">\u003C/p>\n\u003Cp>PC1 и PC2 получили адреса. Анализируем DHCP Offer для клиента PC2. Сам сервер Ubuntu хочет выдать клиенту адрес из своего пула в первой подсети, но клиент находится во второй подсети 172.16.10.0/24. Пакет до клиента доходит через MikroTik, который выступает как DHCP Relay. Маршрутизатор подставляет в качестве источника свой локальный IP 172.16.10.1, чтобы пакет корректно дошёл до клиента, у которого нет прямого маршрута к серверу. Назначение пакета — IP 172.16.10.10, который сервер предлагает клиенту. В поле Next Server IP Address остаётся 192.168.10.2, показывая, что реальный DHCP-сервер находится в первой подсети. То есть пакет визуально идёт «от» MikroTik, но фактически это предложение от Ubuntu-сервера, и такой механизм позволяет клиенту в изолированной подсети получить IP-адрес и сетевые параметры.\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"3-как-пакеты-проходят-через-relay-разбор-по-шагам\">3. Как пакеты проходят через Relay (разбор по шагам)\u003C/h4>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>Шаг 1: Discover от клиента (PC2/PC3)\u003C/strong>\u003Cbr>\nКлиент из подсети 172.16.10.0/24 отправляет DHCP Discover широковещательно (\u003Ccode>ff:ff:ff:ff:ff:ff\u003C/code>). Он ищет любой DHCP-сервер. Но так как сервер находится в другой подсети, пакет не дойдёт напрямую.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Шаг 2: Перехват пакета MikroTik\u003C/strong>\u003Cbr>\nDHCP Relay на MikroTik «ловит» этот Discover на ether2. Relay читает пакет и подставляет в него новый IP-адрес назначения — IP DHCP-сервера (192.168.10.2). Пакет теперь отправляется как unicast от MikroTik к серверу.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Шаг 3: Сервер получает Discover\u003C/strong>\u003Cbr>\nDHCP-сервер Ubuntu получает пакет. Пока что сервер знает только пул для 192.168.10.0/24, поэтому он не может выдать адрес для 172.16.10.0/24. Relay при желании может добавить опцию 82 (Agent Information), чтобы сервер понял, из какой подсети пришёл клиент и какой пул использовать.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Шаг 4: Offer от сервера\u003C/strong>\u003Cbr>\nСервер формирует DHCP Offer для клиента. Если пул для 172.16.10.0/24 уже добавлен, сервер выбирает свободный IP из этого пула и отправляет пакет обратно на IP, с которого пришёл Discover (MikroTik).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Шаг 5: MikroTik доставляет Offer клиенту\u003C/strong>\u003Cbr>\nКогда пакет возвращается на MikroTik, он меняет IP-адрес источника на свой интерфейс в клиентской подсети (172.16.10.1), чтобы клиент мог принять ответ, и пересылает Offer клиенту.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Шаг 6: Request и ACK\u003C/strong>\u003Cbr>\nКлиент отвечает DHCP Request, сервер подтверждает DHCP ACK — весь процесс DORA полностью проходит через Relay. Клиент получает IP-адрес, шлюз и DNS, как будто сервер находится в его подсети.\u003C/p>\n\u003C/li>\n\u003C/ul>",{"headings":334,"localImagePaths":367,"remoteImagePaths":368,"frontmatter":369,"imagePaths":372},[335,336,339,342,345,346,347,348,349,352,355,358,361,364],{"depth":30,"slug":298,"text":299},{"depth":30,"slug":337,"text":338},"2-настройка-dhcp-на-mikrotik","2. Настройка DHCP на MikroTik",{"depth":30,"slug":340,"text":341},"3-анализ-dora","3. Анализ DORA",{"depth":30,"slug":343,"text":344},"4-анализ-дополнительных-сообщений-dhcp","4. Анализ дополнительных сообщений DHCP",{"depth":209,"slug":250,"text":251},{"depth":209,"slug":253,"text":254},{"depth":209,"slug":256,"text":257},{"depth":209,"slug":259,"text":260},{"depth":30,"slug":350,"text":351},"5-статическая-привязка-ip","5. Статическая привязка IP",{"depth":30,"slug":353,"text":354},"6-настройка-dhcp-на-ubuntu","6. Настройка DHCP на Ubuntu",{"depth":30,"slug":356,"text":357},"7-настройка-dhcp-relay","7. Настройка DHCP Relay",{"depth":209,"slug":359,"text":360},"1-настройка-маршрутизации-на-mikrotik","1. Настройка маршрутизации на MikroTik",{"depth":209,"slug":362,"text":363},"2-настройка-dhcp-relay-на-mikrotik","2. Настройка DHCP Relay на MikroTik",{"depth":209,"slug":365,"text":366},"3-как-пакеты-проходят-через-relay-разбор-по-шагам","3. Как пакеты проходят через Relay (разбор по шагам)",[],[],{"title":327,"description":370,"image":283,"date":371},"В этой работе мы подробно разберём, как работает DHCP, от процесса обмена сообщениями DORA (Discover, Offer, Request, Acknowledge), через анализ сетевого трафика в Wireshark","6 февраля 2026",[],"ru/ssh",{"id":373,"data":375,"body":377,"filePath":378,"digest":379,"rendered":380},{"title":376},"Межсетевой SSH-доступ в сети Cisco и MikroTik","В любой сети рано или поздно возникает необходимость управлять оборудованием удалённо. Бегать к каждому маршрутизатору с консольным кабелем, идея так себе, особенно если устройства находятся в разных офисах или сегментах сети. Именно поэтому для администрирования обычно используют **SSH**, протокол, который позволяет подключаться к устройствам по сети и делать это безопасно.\n\nSSH нужен для того, чтобы можно было зайти на маршрутизатор или сервер, посмотреть конфигурацию, внести изменения или проверить, что вообще происходит в сети. В отличие от Telnet, который передаёт данные в открытом виде, SSH шифрует весь трафик, включая логин и пароль, поэтому его и используют в нормальных, рабочих сетях.\n\nНа практике сеть почти никогда не ограничивается одной подсетью. Обычно есть несколько сегментов, соединённых между собой маршрутизаторами. В такой ситуации важно не только включить SSH, но и правильно настроить маршрутизацию между сетями, чтобы устройства могли друг друга видеть. А ещё, ограничить доступ, чтобы по SSH можно было подключаться только с нужных адресов, а не откуда попало.\n\nВ этой работе мы на практике разберём настройку SSH-доступа в такой многосегментной сети. В схеме используются маршрутизаторы Cisco и MikroTik, а также машины с Windows 10 и Kali Linux. По ходу работы настроим IP-адреса, пропишем маршруты между подсетями, проверим связность и организуем безопасное подключение к сетевым устройствам по SSH, включая ограничение доступа на MikroTik по IP.\n\n* * *\n\n### 1. Построить топологию\n\n![topology](/images/ssh_net/topology.png)\n\nТопология следующая: в первом офисе клиент Windows 10 подключается напрямую к интерфейсу G0/0 маршрутизатора Cisco, а сам маршрутизатор Cisco своим интерфейсом G1/0 соединяется с MikroTik по выделённой магистрали, эмулируя связь между двумя разными сегментами сети. С другой стороны MikroTik подключен ко второму офису, где находится Kali Linux.\n\nВ дальнейших шагах будет настроена IP-адресация: Windows получит адрес 192.168.10.10, а Cisco — 192.168.10.1 в подсети 192.168.10.0/24, которая используется в первом офисе. Для связи между маршрутизаторами в сети 10.10.10.0/30 будут назначены адреса 10.10.10.1 у Cisco и 10.10.10.2 у MikroTik. Во втором офисе планируется использовать подсеть 172.16.10.0/24, где MikroTik получит адрес 172.16.10.1, а Kali Linux — 172.16.10.10.\n\n* * *\n\n### 2. Настроить IP-адреса на Cisco R1\n\n![set_ip_cisco](/images/ssh_net/set_ip_cisco.png)\n\nПосле сборки топологии следующим этапом является настройка IP-адресов на маршрутизаторе Cisco, чтобы обеспечить работу локальной сети первого офиса и соединение между офисами. В нашей схеме маршрутизатор Cisco имеет два интерфейса — первый интерфейс G0/0 подключён к локальной сети, где находится клиент Windows 10, а второй интерфейс G0/1 используется для связи с маршрутизатором MikroTik, который находится во втором офисе. Таким образом, Cisco выполняет роль шлюза для устройств внутри первого офиса и одновременно обеспечивает межсетевое соединение.\n\nДля локальной сети офиса мы используем подсеть 192.168.10.0/24, что даёт нам 256 возможных адресов, из которых 254 доступны для использования устройствами. Маска подсети 255.255.255.0 (или префикс /24) указывает, что первые 24 бита адреса — это часть сети, а оставшиеся 8 бит — для адресации устройств. В такой схеме адрес 192.168.10.0 является сетевым, то есть служебным и не назначается устройствам, а адрес 192.168.10.255 является широковещательным (broadcast) — его используют для отправки пакетов сразу всем участникам сети.\n\nПоэтому для маршрутизатора Cisco на интерфейсе G0/0 мы назначаем адрес 192.168.10.1 — это удобное и привычное решение, когда именно первый доступный адрес отдают шлюзу. Этот адрес будет использоваться в качестве точки выхода из сети для всех устройств локального сегмента, включая клиентский компьютер с Windows 10, который в дальнейшем получит адрес 192.168.10.10.\n\nСледующий интерфейс G0/1 маршрутизатора Cisco предназначен для соединения с MikroTik. Здесь мы используем сеть 10.10.10.0/30. Маска 255.255.255.252 (или префикс /30) позволяет создать очень компактную сеть из четырёх адресов. Это типичная практика для соединения \"точка-точка\", когда требуется минимизировать расход IP-адресов, поскольку такой линк соединяет только два устройства — роутеры Cisco и MikroTik. В этой подсети:\n\n- 10.10.10.0 - сетевой адрес (служебный, не используется).\n- 10.10.10.1 - адрес Cisco.\n- 10.10.10.2 - адрес MikroTik.\n- 10.10.10.3 - широковещательный адрес.\n\nИспользование сети /30 подходит для соединения двух устройств напрямую, обеспечивая экономию адресного пространства и упрощая конфигурацию.\n\nВ результате маршрутизатор Cisco получает два адреса:\n\n- На интерфейсе G0/0 - 192.168.10.1 для взаимодействия с локальной сетью.\n- На интерфейсе G0/1 - 10.10.10.1 для связи с MikroTik.\n\n* * *\n\n### 3. Настроить IP-адреса на MikroTik R2\n\n![set_ip_mikrotik](/images/ssh_net/set_ip_mikrotik.png)\n\nПри первом запуске MikroTik RouterOS через консоль (например, в GNS3) устройство запрашивает логин и пароль для входа. По умолчанию логин - **admin**, а пароль отсутствует (просто нажимаем Enter). Однако при первой настройке система обязательно требует задать новый пароль, так как пустой пароль оставить нельзя - это связано с тем, что новый пароль не может совпадать с текущим (пустым) для безопасности доступа. Поэтому при вводе пустого пароля появится ошибка, и потребуется ввести пароль для последующего входа.\n\nДалее мы приступаем к назначению IP-адресов на интерфейсы MikroTik, что необходимо для правильной работы сети и межсетевого взаимодействия.\n\nВ нашей топологии MikroTik имеет два интерфейса:\n\n- Интерфейс, соединённый с Cisco (внутренний линк) - IP из сети 10.10.10.0/30\n- Интерфейс, подключённый ко второму офису (локальная сеть) - IP из сети 172.16.10.0/24\n\nДля удобства работы и лучшей читаемости конфигурации я переименовал интерфейсы MikroTik (ether1, ether2 и т.д.) в более понятные имена, соответствующие их назначению, *To_Cisco*, *To_Kali* .\n\n* * * \n\n### 4. Назначить IP-адреса Windows 10 и Kali Linux в соответствующих подсетях\n\n#### Windows 10\n\n![set_ip_windows](/images/ssh_net/set_ip_windows.png)\n\nНазначаем IP-адреса на клиентских машинах - Windows 10 и Kali Linux, чтобы они могли корректно взаимодействовать с роутерами и друг с другом внутри своих подсетей.\n\nВ Windows 10 это делается через настройки сетевого адаптера. Нужно открыть «Центр управления сетями и общим доступом», выбрать активное подключение, перейти в «Свойства», затем выбрать «Протокол Интернета версии 4 (TCP/IPv4)» и нажать «Свойства». Здесь вручную прописывается IP-адрес, маска подсети и шлюз по умолчанию. Например, для первого офиса это будет IP 192.168.10.10 с маской 255.255.255.0 и шлюзом 192.168.10.1 (адрес Cisco).\n\n![share_options_windows](/images/ssh_net/share_options_windows.png)\n\nКроме того, в Windows 10 стоит обратить внимание на настройки брандмауэра и параметры общего доступа (Share Options). По умолчанию, чтобы повысить безопасность, система блокирует входящие ICMP-запросы (ping) и некоторые виды трафика. Чтобы пинг с других устройств успешно проходил, необходимо либо временно отключить брандмауэр, либо настроить правила для разрешения входящих ping-запросов и других нужных протоколов. Без этой настройки пинг может просто не доходить до Windows, несмотря на правильные IP и маршруты.\n\n----\n\n#### Kali Linux\n\n![set_ip_kali](/images/ssh_net/set_ip_kali.png)\n\nВ Kali Linux IP-адрес назначается через терминал командой ip addr add, например: sudo ip addr add 172.16.10.10/24 dev eth0, где 172.16.10.10 — IP-адрес, /24 — маска подсети, а eth0 — имя сетевого интерфейса. Для настройки шлюза по умолчанию используется команда sudo ip route add default via 172.16.10.1.\n\nРучное назначение IP-адресов необходимо, так как автоматическое получение IP (DHCP-серверы) в нашей топологии отсутствует, что помогает лучше разобраться с основами IP-адресации и как устройства общаются в сети.\n\n* * *\n\n### 5. Проверить локальную связность (ping) внутри Office 1 и Office 2\n\n#### На Windows 10 (Office 1)\n\n![ping_from_win_to_routers](/images/ssh_net/ping_from_win_to_routers.png)\n\nДля проверки правильности настройки IP-адресов и базовой сетевой связности внутри каждого офиса мы используем команду ping с рабочих станций — Windows 10 в Office 1 и Kali Linux в Office 2. Ping — это простой инструмент, позволяющий проверить, достигает ли отправляемый пакет целевого устройства и получает ли ответ.\n\nНачинаем с Office 1: с Windows 10 выполняем ping адреса интерфейса Cisco маршрутизатора в подсети 192.168.10.0/24, например 192.168.10.1. Как видно на скриншоте, ping проходит успешно, поскольку оба устройства находятся в одной подсети, и маршрутизатор отвечает на запросы. Это подтверждает, что IP-адреса назначены корректно и физическое соединение работает.\n\nТакже с Windows 10 выполняем ping на адрес 10.10.10.1 - локальный интерфейс Cisco в канале между роутерами. Этот ping успешно проходит, и ответ приходит, так как этот IP напрямую принадлежит Cisco и находится в его интерфейсе. Cisco может корректно обработать пакет и отправить ответ, поскольку устройство знает о своих локальных интерфейсах и соответствующих сетях.\n\nДалее с Windows 10 пробуем отправить ping на адрес 10.10.10.2 — это IP интерфейса MikroTik на канале точка-точка между роутерами. Запрос покидает локальную подсеть и доходит до MikroTik, однако ответа не приходит. Это происходит потому, что MikroTik не знает, как вернуть ответ обратно в сеть Windows, поскольку маршрутизация между роутерами ещё не настроена. Без маршрута обратно пакеты с MikroTik не доходят до Windows, и ping не получает ответа.\n\n---\n\n#### На Kali Linux (Office 2)\n\n![ping_from_kalito_routers](/images/ssh_net/ping_from_kalito_routers.png)\n\nАналогичная проверка на стороне Office 2 проводится с Kali Linux, где также выполняем ping на IP MikroTik 172.16.10.1 — он успешно проходит, подтверждая корректность настройки локальной сети второго офиса. Таким образом, мы видим, что локальная связность внутри каждого офиса функционирует корректно, а для межсетевого взаимодействия требуется дополнительная настройка маршрутизации.\n\n* * *\n\n### 6. Настроить маршрутизацию на Cisco и MikroTik для обеспечения связи между подсетями офисов\n\n#### На Cisco\n\n![ip_route_cisco](/images/ssh_net/ip_route_cisco.png)\n\nДля того чтобы устройства из разных подсетей смогли обмениваться данными, необходимо настроить маршрутизацию на обоих маршрутизаторах — Cisco и MikroTik. Без неё пакеты, отправленные из одной подсети, не смогут правильно добраться до другой, так как устройства просто не знают, куда пересылать трафик за пределами своей локальной сети.\n\nВ нашем случае есть три подсети: 192.168.10.0/24 (Office 1), 10.10.10.0/30 (канал между маршрутизаторами) и 172.16.10.0/24 (Office 2). Каждый маршрутизатор знает о своих локальных сетях, но чтобы обеспечить связь между офисами, нужно добавить статические маршруты, которые укажут, куда отправлять пакеты для другой подсети.\n\nНа Cisco мы настроим маршрут к сети 172.16.10.0/24 через следующий хоп — интерфейс MikroTik с IP 10.10.10.2. Это скажет Cisco, что для доставки пакетов в офис 2 нужно отправлять трафик через линк с MikroTik. Команда: ```ip route 172.16.10.0 255.255.255.0 10.10.10.2```\n\n---\n\n#### На Mikrotik\n\n![ip_route_mikrotik](/images/ssh_net/ip_route_mikrotik.png)\n\nАналогично, на MikroTik нужно добавить маршрут к сети 192.168.10.0/24 через Cisco — IP 10.10.10.1. Это позволит MikroTik пересылать пакеты в офис 1, направляя их на Cisco:\n```/ip route add dst-address=192.168.10.0/24 gateway=10.10.10.1```\n\nПосле добавления маршрутов оба маршрутизатора будут знать, как доставлять пакеты между сетями офисов. Теперь, когда Windows в Office 1 отправляет пакеты на Kali в Office 2, они проходят через Cisco, затем по точка-точка каналу к MikroTik и далее в локальную сеть второго офиса. И наоборот, пакеты от Kali к Windows идут по обратному пути.\n\nВажно отметить, что статические маршруты — это простой и надёжный способ в небольших сетях. В более крупных и динамичных инфраструктурах используют протоколы динамической маршрутизации (например, OSPF или EIGRP), которые автоматически обновляют маршруты.\n\n* * *\n\n### 7. Проверить межсетевую связность (ping) между Windows 10 и Kali Linux\n\n#### На Windows 10\n\n![ping_from_win_to_routers2](/images/ssh_net/ping_from_win_to_routers2.png)\n\nПосле того как мы настроили маршрутизацию, нужно проверить, что компьютеры из разных офисов действительно могут «видеть» друг друга и обмениваться данными без проблем.\n\nНа скриншоте видно, что с Windows 10 мы сначала отправляем пинг на адрес 10.10.10.2 — это интерфейс MikroTik, который соединяет два роутера. Получая ответы от MikroTik, мы видим, что связь с соседним роутером установлена и работает нормально. Затем делаем пинг на конечный адрес в другой сети — 172.16.10.10, где находится Kali Linux. Ответы от Kali показывают, что маршрутизация настроена правильно, и пакеты доходят до нужного устройства во втором офисе.\n\n---\n\n#### На Kali Linux\n\n![ping_from_kali_to_routers2](/images/ssh_net/ping_from_kali_to_routers2.png)\n\nС Kali ситуация аналогичная: сначала отправляем пинг на 10.10.10.1 - интерфейс Cisco, и получаем ответы, подтверждающие, что связь с первым роутером есть. Потом пингуем Windows 10 по адресу 192.168.10.10, и успешные ответы показывают, что устройства в разных офисах могут обмениваться данными.\n\n* * *\n\n### 8. Настроить SSH на Cisco\n\n![ssh_on_cisco](/images/ssh_net/ssh_on_cisco.png)\n\nНастройка SSH на Cisco — важный шаг для безопасного удалённого доступа к маршрутизатору. По умолчанию Cisco использует Telnet, который передаёт данные в открытом виде, что небезопасно и уязвимо для перехвата. Поэтому в конфигурации vty-линий необходимо отключить Telnet и включить только SSH для повышения безопасности.\n\nПервым делом задаём имя хоста и доменное имя, так как именно эти параметры используются при генерации криптографических ключей RSA. Доменное имя нужно для создания уникального идентификатора устройства, который входит в состав ключей шифрования.\n\nДалее генерируем RSA-ключи для SSH. Минимально рекомендуемый размер ключа — 1024 бита, что уже обеспечивает приемлемый уровень защиты. Однако, если важна повышенная безопасность и соответствие современным стандартам, лучше использовать ключ длиной 2048 бит — это значительно усложняет взлом ключа и защищает соединение от атак. RSA-ключи создают пару — публичный и приватный, которые необходимы для шифрования и аутентификации SSH-сессий.\n\nПосле этого создаём локальный пользовательский аккаунт, в моём случае с логином admin и паролем test123, который будет использоваться для аутентификации при подключении по SSH. Это обеспечивает контроль доступа и предотвращает неавторизованный вход.\n\nПри настройке vty-линий используем команду login local — она указывает, что для аутентификации используется локальная база пользователей (то есть аккаунты, созданные на самом устройстве).\n\nТакже хочу упомянуть, так как могут возникнуть вопросы насчёт vty-линий — почему диапазон от 0 до 4? Потому что на маршрутизаторах обычно доступно 5 vty-линий с номерами от 0 до 4, что позволяет одновременно поддерживать до 5 удалённых подключений по SSH или Telnet. На коммутаторах же чаще используется диапазон от 0 до 15, то есть 16 линий, так как свитчи могут обслуживать большее число одновременных сессий.\n\nВ настройках vty-линий мы указываем аутентификацию через локальную базу пользователей, включаем только протокол SSH и запрещаем Telnet.\n\nПроверку доступа по SSH с клиентской машины оставляем для следующих шагов, где будем тестировать удалённые подключения. Переходим к настройке SSH на MikroTik.\n\n* * *\n\n### 9. Настроить SSH на Mikrotik\n\n![ssh_on_mikrotik](/images/ssh_net/ssh_on_mtik.png)\n\nТеперь переходим к включению и настройке SSH-сервиса на MikroTik. С помощью команды ```/ip service enable``` ssh активируем SSH-сервер, что позволяет принимать SSH-подключения. Далее командой ```/ip ssh set strong-crypto=yes``` мы включаем использование более сильных алгоритмов шифрования, повышая безопасность соединений. Опция ```allow-none-crypto=no``` запрещает небезопасные варианты шифрования, которые могут ослабить защиту.\n\nВ текущей настройке мы разрешаем аутентификацию по паролю — команда ```/ip ssh set always-allow-password-login=yes``` позволяет входить с использованием пароля. В дальнейшем ограничим доступ только по IP-адресам, чтобы повысить безопасность и ограничить круг лиц, которые могут подключаться по SSH. Эти ограничения мы настроим позже через firewall и дополнительные правила безопасности.\n\nХочу отметить, что пароль для подключения по SSH — это тот, который мы задали при первом запуске MikroTik в пункте 3 при настройке роутера и назначении IP-адресов. Помимо этого, при необходимости можно создать дополнительных пользователей с новыми логинами и паролями для более гибкого управления доступом.\n\n---\n\n### 10. С помощью SSH подключиться с Windows 10 к Cisco и MikroTik, а также с Kali Linux к Cisco и MikroTik\n\n#### На Kali Linux\n\n![kali_to_cisco](/images/ssh_net/kali_to_cisco.png)\n\nНа Kali Linux у меня установлен OpenSSH версии 8.0p1 (Debian 4) с OpenSSL 1.1.1c. В новых версиях OpenSSH по умолчанию используются более современные и безопасные алгоритмы шифрования и ключи для SSH-сессий. Однако Cisco, особенно на старых версиях IOS, поддерживает ограниченный набор шифров — в основном более старые алгоритмы типа aes192-cbc или aes256-cbc.\n\nПоэтому, при попытке просто выполнить команду ssh admin@192.168.10.1 Kali пытается использовать современные алгоритмы, которые Cisco не понимает, и соединение не устанавливается. Чтобы это исправить, нужно явно указать совместимый с Cisco алгоритм шифрования, например:\n\n```ssh -c aes192-cbc admin@192.168.10.1``` или ```ssh -c aes256-cbc admin@192.168.10.1```\n\nТак мы заставляем SSH-клиент использовать именно те алгоритмы, которые принимает Cisco.\n\n![kali_to_mikrotik](/images/ssh_net/kali_to_mikrotik.png)\n\nВ случае с MikroTik таких ограничений нет, так как MikroTik поддерживает современные алгоритмы по умолчанию. Поэтому для подключения к MikroTik достаточно просто: ```ssh admin@172.16.10.1```\n\n---\n\n#### На Windows 10\n\n![win_to_cisco](/images/ssh_net/win_to_cisco.png)\n\nАналогично, при подключении с Windows с помощью встроенного SSH-клиента в командной строке (CMD), также нужно учитывать поддержку шифров, особенно при подключении к Cisco. По умолчанию Windows SSH-клиент использует современные алгоритмы шифрования, которые могут не поддерживаться Cisco, особенно на старых версиях IOS. Поэтому простая команда ```ssh admin@192.168.10.1``` не сработает из-за несовместимости алгоритмов шифрования. Чтобы установить соединение, нужно указать совместимый с Cisco шифр, ```ssh -c aes256-cbc admin@192.168.10.1```\n\nТак как у меня нет под рукой специализированных эмуляторов терминала, таких как PuTTY или SecureCRT, я использую встроенный CMD для выполнения SSH-подключений.\n\n![win_to_mikrotik](/images/ssh_net/win_to_mikrotik.png)\n\nВ случае с MikroTik такая дополнительная настройка не требуется, так как он поддерживает современные алгоритмы шифрования из коробки. Поэтому для подключения достаточно просто ```ssh admin@172.16.10.1```\n\n* * *\n\n### 11. На MikroTik разрешить SSH-подключение только с Kali Linux(172.16.10.10), остальные IP заблокировать\n\n![allow_on_mikrotik](/images/ssh_net/allow_on_mikrotik.png)\n\nТеперь перейдём к настройке безопасности на MikroTik - ограничим доступ по SSH только с компьютера Kali Linux (IP 172.16.10.10). Для этого настроим правила в firewall, которые разрешат подключаться по SSH только с этого IP, а все остальные подключения заблокируют.\n\nЭто позволит нам повысить безопасность, чтобы никто посторонний не смог подключиться к MikroTik по SSH. Такая практика часто используется в реальных сетях для ограничения доступа к важному оборудованию.\n\nВ результате мы создадим два правила: первое — разрешить SSH с Kali Linux, второе — блокировать SSH со всех остальных адресов.\n\n![allow_demo](/images/ssh_net/allow_demo.png)\n\nКак видно на скриншотах, Kali без проблем подключается по SSH к MikroTik, а попытки подключения с Windows 10 не проходят, значит ограничение доступа работает правильно.","src/content/articles/ru/ssh.md","29ec1c4da5c1fb38",{"html":381,"metadata":382},"\u003Cp>В любой сети рано или поздно возникает необходимость управлять оборудованием удалённо. Бегать к каждому маршрутизатору с консольным кабелем, идея так себе, особенно если устройства находятся в разных офисах или сегментах сети. Именно поэтому для администрирования обычно используют \u003Cstrong>SSH\u003C/strong>, протокол, который позволяет подключаться к устройствам по сети и делать это безопасно.\u003C/p>\n\u003Cp>SSH нужен для того, чтобы можно было зайти на маршрутизатор или сервер, посмотреть конфигурацию, внести изменения или проверить, что вообще происходит в сети. В отличие от Telnet, который передаёт данные в открытом виде, SSH шифрует весь трафик, включая логин и пароль, поэтому его и используют в нормальных, рабочих сетях.\u003C/p>\n\u003Cp>На практике сеть почти никогда не ограничивается одной подсетью. Обычно есть несколько сегментов, соединённых между собой маршрутизаторами. В такой ситуации важно не только включить SSH, но и правильно настроить маршрутизацию между сетями, чтобы устройства могли друг друга видеть. А ещё, ограничить доступ, чтобы по SSH можно было подключаться только с нужных адресов, а не откуда попало.\u003C/p>\n\u003Cp>В этой работе мы на практике разберём настройку SSH-доступа в такой многосегментной сети. В схеме используются маршрутизаторы Cisco и MikroTik, а также машины с Windows 10 и Kali Linux. По ходу работы настроим IP-адреса, пропишем маршруты между подсетями, проверим связность и организуем безопасное подключение к сетевым устройствам по SSH, включая ограничение доступа на MikroTik по IP.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"1-построить-топологию\">1. Построить топологию\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/topology.png\" alt=\"topology\">\u003C/p>\n\u003Cp>Топология следующая: в первом офисе клиент Windows 10 подключается напрямую к интерфейсу G0/0 маршрутизатора Cisco, а сам маршрутизатор Cisco своим интерфейсом G1/0 соединяется с MikroTik по выделённой магистрали, эмулируя связь между двумя разными сегментами сети. С другой стороны MikroTik подключен ко второму офису, где находится Kali Linux.\u003C/p>\n\u003Cp>В дальнейших шагах будет настроена IP-адресация: Windows получит адрес 192.168.10.10, а Cisco — 192.168.10.1 в подсети 192.168.10.0/24, которая используется в первом офисе. Для связи между маршрутизаторами в сети 10.10.10.0/30 будут назначены адреса 10.10.10.1 у Cisco и 10.10.10.2 у MikroTik. Во втором офисе планируется использовать подсеть 172.16.10.0/24, где MikroTik получит адрес 172.16.10.1, а Kali Linux — 172.16.10.10.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"2-настроить-ip-адреса-на-cisco-r1\">2. Настроить IP-адреса на Cisco R1\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/set_ip_cisco.png\" alt=\"set_ip_cisco\">\u003C/p>\n\u003Cp>После сборки топологии следующим этапом является настройка IP-адресов на маршрутизаторе Cisco, чтобы обеспечить работу локальной сети первого офиса и соединение между офисами. В нашей схеме маршрутизатор Cisco имеет два интерфейса — первый интерфейс G0/0 подключён к локальной сети, где находится клиент Windows 10, а второй интерфейс G0/1 используется для связи с маршрутизатором MikroTik, который находится во втором офисе. Таким образом, Cisco выполняет роль шлюза для устройств внутри первого офиса и одновременно обеспечивает межсетевое соединение.\u003C/p>\n\u003Cp>Для локальной сети офиса мы используем подсеть 192.168.10.0/24, что даёт нам 256 возможных адресов, из которых 254 доступны для использования устройствами. Маска подсети 255.255.255.0 (или префикс /24) указывает, что первые 24 бита адреса — это часть сети, а оставшиеся 8 бит — для адресации устройств. В такой схеме адрес 192.168.10.0 является сетевым, то есть служебным и не назначается устройствам, а адрес 192.168.10.255 является широковещательным (broadcast) — его используют для отправки пакетов сразу всем участникам сети.\u003C/p>\n\u003Cp>Поэтому для маршрутизатора Cisco на интерфейсе G0/0 мы назначаем адрес 192.168.10.1 — это удобное и привычное решение, когда именно первый доступный адрес отдают шлюзу. Этот адрес будет использоваться в качестве точки выхода из сети для всех устройств локального сегмента, включая клиентский компьютер с Windows 10, который в дальнейшем получит адрес 192.168.10.10.\u003C/p>\n\u003Cp>Следующий интерфейс G0/1 маршрутизатора Cisco предназначен для соединения с MikroTik. Здесь мы используем сеть 10.10.10.0/30. Маска 255.255.255.252 (или префикс /30) позволяет создать очень компактную сеть из четырёх адресов. Это типичная практика для соединения “точка-точка”, когда требуется минимизировать расход IP-адресов, поскольку такой линк соединяет только два устройства — роутеры Cisco и MikroTik. В этой подсети:\u003C/p>\n\u003Cul>\n\u003Cli>10.10.10.0 - сетевой адрес (служебный, не используется).\u003C/li>\n\u003Cli>10.10.10.1 - адрес Cisco.\u003C/li>\n\u003Cli>10.10.10.2 - адрес MikroTik.\u003C/li>\n\u003Cli>10.10.10.3 - широковещательный адрес.\u003C/li>\n\u003C/ul>\n\u003Cp>Использование сети /30 подходит для соединения двух устройств напрямую, обеспечивая экономию адресного пространства и упрощая конфигурацию.\u003C/p>\n\u003Cp>В результате маршрутизатор Cisco получает два адреса:\u003C/p>\n\u003Cul>\n\u003Cli>На интерфейсе G0/0 - 192.168.10.1 для взаимодействия с локальной сетью.\u003C/li>\n\u003Cli>На интерфейсе G0/1 - 10.10.10.1 для связи с MikroTik.\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch3 id=\"3-настроить-ip-адреса-на-mikrotik-r2\">3. Настроить IP-адреса на MikroTik R2\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/set_ip_mikrotik.png\" alt=\"set_ip_mikrotik\">\u003C/p>\n\u003Cp>При первом запуске MikroTik RouterOS через консоль (например, в GNS3) устройство запрашивает логин и пароль для входа. По умолчанию логин - \u003Cstrong>admin\u003C/strong>, а пароль отсутствует (просто нажимаем Enter). Однако при первой настройке система обязательно требует задать новый пароль, так как пустой пароль оставить нельзя - это связано с тем, что новый пароль не может совпадать с текущим (пустым) для безопасности доступа. Поэтому при вводе пустого пароля появится ошибка, и потребуется ввести пароль для последующего входа.\u003C/p>\n\u003Cp>Далее мы приступаем к назначению IP-адресов на интерфейсы MikroTik, что необходимо для правильной работы сети и межсетевого взаимодействия.\u003C/p>\n\u003Cp>В нашей топологии MikroTik имеет два интерфейса:\u003C/p>\n\u003Cul>\n\u003Cli>Интерфейс, соединённый с Cisco (внутренний линк) - IP из сети 10.10.10.0/30\u003C/li>\n\u003Cli>Интерфейс, подключённый ко второму офису (локальная сеть) - IP из сети 172.16.10.0/24\u003C/li>\n\u003C/ul>\n\u003Cp>Для удобства работы и лучшей читаемости конфигурации я переименовал интерфейсы MikroTik (ether1, ether2 и т.д.) в более понятные имена, соответствующие их назначению, \u003Cem>To_Cisco\u003C/em>, \u003Cem>To_Kali\u003C/em> .\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"4-назначить-ip-адреса-windows-10-и-kali-linux-в-соответствующих-подсетях\">4. Назначить IP-адреса Windows 10 и Kali Linux в соответствующих подсетях\u003C/h3>\n\u003Ch4 id=\"windows-10\">Windows 10\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/set_ip_windows.png\" alt=\"set_ip_windows\">\u003C/p>\n\u003Cp>Назначаем IP-адреса на клиентских машинах - Windows 10 и Kali Linux, чтобы они могли корректно взаимодействовать с роутерами и друг с другом внутри своих подсетей.\u003C/p>\n\u003Cp>В Windows 10 это делается через настройки сетевого адаптера. Нужно открыть «Центр управления сетями и общим доступом», выбрать активное подключение, перейти в «Свойства», затем выбрать «Протокол Интернета версии 4 (TCP/IPv4)» и нажать «Свойства». Здесь вручную прописывается IP-адрес, маска подсети и шлюз по умолчанию. Например, для первого офиса это будет IP 192.168.10.10 с маской 255.255.255.0 и шлюзом 192.168.10.1 (адрес Cisco).\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/share_options_windows.png\" alt=\"share_options_windows\">\u003C/p>\n\u003Cp>Кроме того, в Windows 10 стоит обратить внимание на настройки брандмауэра и параметры общего доступа (Share Options). По умолчанию, чтобы повысить безопасность, система блокирует входящие ICMP-запросы (ping) и некоторые виды трафика. Чтобы пинг с других устройств успешно проходил, необходимо либо временно отключить брандмауэр, либо настроить правила для разрешения входящих ping-запросов и других нужных протоколов. Без этой настройки пинг может просто не доходить до Windows, несмотря на правильные IP и маршруты.\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"kali-linux\">Kali Linux\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/set_ip_kali.png\" alt=\"set_ip_kali\">\u003C/p>\n\u003Cp>В Kali Linux IP-адрес назначается через терминал командой ip addr add, например: sudo ip addr add 172.16.10.10/24 dev eth0, где 172.16.10.10 — IP-адрес, /24 — маска подсети, а eth0 — имя сетевого интерфейса. Для настройки шлюза по умолчанию используется команда sudo ip route add default via 172.16.10.1.\u003C/p>\n\u003Cp>Ручное назначение IP-адресов необходимо, так как автоматическое получение IP (DHCP-серверы) в нашей топологии отсутствует, что помогает лучше разобраться с основами IP-адресации и как устройства общаются в сети.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"5-проверить-локальную-связность-ping-внутри-office-1-и-office-2\">5. Проверить локальную связность (ping) внутри Office 1 и Office 2\u003C/h3>\n\u003Ch4 id=\"на-windows-10-office-1\">На Windows 10 (Office 1)\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/ping_from_win_to_routers.png\" alt=\"ping_from_win_to_routers\">\u003C/p>\n\u003Cp>Для проверки правильности настройки IP-адресов и базовой сетевой связности внутри каждого офиса мы используем команду ping с рабочих станций — Windows 10 в Office 1 и Kali Linux в Office 2. Ping — это простой инструмент, позволяющий проверить, достигает ли отправляемый пакет целевого устройства и получает ли ответ.\u003C/p>\n\u003Cp>Начинаем с Office 1: с Windows 10 выполняем ping адреса интерфейса Cisco маршрутизатора в подсети 192.168.10.0/24, например 192.168.10.1. Как видно на скриншоте, ping проходит успешно, поскольку оба устройства находятся в одной подсети, и маршрутизатор отвечает на запросы. Это подтверждает, что IP-адреса назначены корректно и физическое соединение работает.\u003C/p>\n\u003Cp>Также с Windows 10 выполняем ping на адрес 10.10.10.1 - локальный интерфейс Cisco в канале между роутерами. Этот ping успешно проходит, и ответ приходит, так как этот IP напрямую принадлежит Cisco и находится в его интерфейсе. Cisco может корректно обработать пакет и отправить ответ, поскольку устройство знает о своих локальных интерфейсах и соответствующих сетях.\u003C/p>\n\u003Cp>Далее с Windows 10 пробуем отправить ping на адрес 10.10.10.2 — это IP интерфейса MikroTik на канале точка-точка между роутерами. Запрос покидает локальную подсеть и доходит до MikroTik, однако ответа не приходит. Это происходит потому, что MikroTik не знает, как вернуть ответ обратно в сеть Windows, поскольку маршрутизация между роутерами ещё не настроена. Без маршрута обратно пакеты с MikroTik не доходят до Windows, и ping не получает ответа.\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"на-kali-linux-office-2\">На Kali Linux (Office 2)\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/ping_from_kalito_routers.png\" alt=\"ping_from_kalito_routers\">\u003C/p>\n\u003Cp>Аналогичная проверка на стороне Office 2 проводится с Kali Linux, где также выполняем ping на IP MikroTik 172.16.10.1 — он успешно проходит, подтверждая корректность настройки локальной сети второго офиса. Таким образом, мы видим, что локальная связность внутри каждого офиса функционирует корректно, а для межсетевого взаимодействия требуется дополнительная настройка маршрутизации.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"6-настроить-маршрутизацию-на-cisco-и-mikrotik-для-обеспечения-связи-между-подсетями-офисов\">6. Настроить маршрутизацию на Cisco и MikroTik для обеспечения связи между подсетями офисов\u003C/h3>\n\u003Ch4 id=\"на-cisco\">На Cisco\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/ip_route_cisco.png\" alt=\"ip_route_cisco\">\u003C/p>\n\u003Cp>Для того чтобы устройства из разных подсетей смогли обмениваться данными, необходимо настроить маршрутизацию на обоих маршрутизаторах — Cisco и MikroTik. Без неё пакеты, отправленные из одной подсети, не смогут правильно добраться до другой, так как устройства просто не знают, куда пересылать трафик за пределами своей локальной сети.\u003C/p>\n\u003Cp>В нашем случае есть три подсети: 192.168.10.0/24 (Office 1), 10.10.10.0/30 (канал между маршрутизаторами) и 172.16.10.0/24 (Office 2). Каждый маршрутизатор знает о своих локальных сетях, но чтобы обеспечить связь между офисами, нужно добавить статические маршруты, которые укажут, куда отправлять пакеты для другой подсети.\u003C/p>\n\u003Cp>На Cisco мы настроим маршрут к сети 172.16.10.0/24 через следующий хоп — интерфейс MikroTik с IP 10.10.10.2. Это скажет Cisco, что для доставки пакетов в офис 2 нужно отправлять трафик через линк с MikroTik. Команда: \u003Ccode>ip route 172.16.10.0 255.255.255.0 10.10.10.2\u003C/code>\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"на-mikrotik\">На Mikrotik\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/ip_route_mikrotik.png\" alt=\"ip_route_mikrotik\">\u003C/p>\n\u003Cp>Аналогично, на MikroTik нужно добавить маршрут к сети 192.168.10.0/24 через Cisco — IP 10.10.10.1. Это позволит MikroTik пересылать пакеты в офис 1, направляя их на Cisco:\n\u003Ccode>/ip route add dst-address=192.168.10.0/24 gateway=10.10.10.1\u003C/code>\u003C/p>\n\u003Cp>После добавления маршрутов оба маршрутизатора будут знать, как доставлять пакеты между сетями офисов. Теперь, когда Windows в Office 1 отправляет пакеты на Kali в Office 2, они проходят через Cisco, затем по точка-точка каналу к MikroTik и далее в локальную сеть второго офиса. И наоборот, пакеты от Kali к Windows идут по обратному пути.\u003C/p>\n\u003Cp>Важно отметить, что статические маршруты — это простой и надёжный способ в небольших сетях. В более крупных и динамичных инфраструктурах используют протоколы динамической маршрутизации (например, OSPF или EIGRP), которые автоматически обновляют маршруты.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"7-проверить-межсетевую-связность-ping-между-windows-10-и-kali-linux\">7. Проверить межсетевую связность (ping) между Windows 10 и Kali Linux\u003C/h3>\n\u003Ch4 id=\"на-windows-10\">На Windows 10\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/ping_from_win_to_routers2.png\" alt=\"ping_from_win_to_routers2\">\u003C/p>\n\u003Cp>После того как мы настроили маршрутизацию, нужно проверить, что компьютеры из разных офисов действительно могут «видеть» друг друга и обмениваться данными без проблем.\u003C/p>\n\u003Cp>На скриншоте видно, что с Windows 10 мы сначала отправляем пинг на адрес 10.10.10.2 — это интерфейс MikroTik, который соединяет два роутера. Получая ответы от MikroTik, мы видим, что связь с соседним роутером установлена и работает нормально. Затем делаем пинг на конечный адрес в другой сети — 172.16.10.10, где находится Kali Linux. Ответы от Kali показывают, что маршрутизация настроена правильно, и пакеты доходят до нужного устройства во втором офисе.\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"на-kali-linux\">На Kali Linux\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/ping_from_kali_to_routers2.png\" alt=\"ping_from_kali_to_routers2\">\u003C/p>\n\u003Cp>С Kali ситуация аналогичная: сначала отправляем пинг на 10.10.10.1 - интерфейс Cisco, и получаем ответы, подтверждающие, что связь с первым роутером есть. Потом пингуем Windows 10 по адресу 192.168.10.10, и успешные ответы показывают, что устройства в разных офисах могут обмениваться данными.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"8-настроить-ssh-на-cisco\">8. Настроить SSH на Cisco\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/ssh_on_cisco.png\" alt=\"ssh_on_cisco\">\u003C/p>\n\u003Cp>Настройка SSH на Cisco — важный шаг для безопасного удалённого доступа к маршрутизатору. По умолчанию Cisco использует Telnet, который передаёт данные в открытом виде, что небезопасно и уязвимо для перехвата. Поэтому в конфигурации vty-линий необходимо отключить Telnet и включить только SSH для повышения безопасности.\u003C/p>\n\u003Cp>Первым делом задаём имя хоста и доменное имя, так как именно эти параметры используются при генерации криптографических ключей RSA. Доменное имя нужно для создания уникального идентификатора устройства, который входит в состав ключей шифрования.\u003C/p>\n\u003Cp>Далее генерируем RSA-ключи для SSH. Минимально рекомендуемый размер ключа — 1024 бита, что уже обеспечивает приемлемый уровень защиты. Однако, если важна повышенная безопасность и соответствие современным стандартам, лучше использовать ключ длиной 2048 бит — это значительно усложняет взлом ключа и защищает соединение от атак. RSA-ключи создают пару — публичный и приватный, которые необходимы для шифрования и аутентификации SSH-сессий.\u003C/p>\n\u003Cp>После этого создаём локальный пользовательский аккаунт, в моём случае с логином admin и паролем test123, который будет использоваться для аутентификации при подключении по SSH. Это обеспечивает контроль доступа и предотвращает неавторизованный вход.\u003C/p>\n\u003Cp>При настройке vty-линий используем команду login local — она указывает, что для аутентификации используется локальная база пользователей (то есть аккаунты, созданные на самом устройстве).\u003C/p>\n\u003Cp>Также хочу упомянуть, так как могут возникнуть вопросы насчёт vty-линий — почему диапазон от 0 до 4? Потому что на маршрутизаторах обычно доступно 5 vty-линий с номерами от 0 до 4, что позволяет одновременно поддерживать до 5 удалённых подключений по SSH или Telnet. На коммутаторах же чаще используется диапазон от 0 до 15, то есть 16 линий, так как свитчи могут обслуживать большее число одновременных сессий.\u003C/p>\n\u003Cp>В настройках vty-линий мы указываем аутентификацию через локальную базу пользователей, включаем только протокол SSH и запрещаем Telnet.\u003C/p>\n\u003Cp>Проверку доступа по SSH с клиентской машины оставляем для следующих шагов, где будем тестировать удалённые подключения. Переходим к настройке SSH на MikroTik.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"9-настроить-ssh-на-mikrotik\">9. Настроить SSH на Mikrotik\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/ssh_on_mtik.png\" alt=\"ssh_on_mikrotik\">\u003C/p>\n\u003Cp>Теперь переходим к включению и настройке SSH-сервиса на MikroTik. С помощью команды \u003Ccode>/ip service enable\u003C/code> ssh активируем SSH-сервер, что позволяет принимать SSH-подключения. Далее командой \u003Ccode>/ip ssh set strong-crypto=yes\u003C/code> мы включаем использование более сильных алгоритмов шифрования, повышая безопасность соединений. Опция \u003Ccode>allow-none-crypto=no\u003C/code> запрещает небезопасные варианты шифрования, которые могут ослабить защиту.\u003C/p>\n\u003Cp>В текущей настройке мы разрешаем аутентификацию по паролю — команда \u003Ccode>/ip ssh set always-allow-password-login=yes\u003C/code> позволяет входить с использованием пароля. В дальнейшем ограничим доступ только по IP-адресам, чтобы повысить безопасность и ограничить круг лиц, которые могут подключаться по SSH. Эти ограничения мы настроим позже через firewall и дополнительные правила безопасности.\u003C/p>\n\u003Cp>Хочу отметить, что пароль для подключения по SSH — это тот, который мы задали при первом запуске MikroTik в пункте 3 при настройке роутера и назначении IP-адресов. Помимо этого, при необходимости можно создать дополнительных пользователей с новыми логинами и паролями для более гибкого управления доступом.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"10-с-помощью-ssh-подключиться-с-windows-10-к-cisco-и-mikrotik-а-также-с-kali-linux-к-cisco-и-mikrotik\">10. С помощью SSH подключиться с Windows 10 к Cisco и MikroTik, а также с Kali Linux к Cisco и MikroTik\u003C/h3>\n\u003Ch4 id=\"на-kali-linux-1\">На Kali Linux\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/kali_to_cisco.png\" alt=\"kali_to_cisco\">\u003C/p>\n\u003Cp>На Kali Linux у меня установлен OpenSSH версии 8.0p1 (Debian 4) с OpenSSL 1.1.1c. В новых версиях OpenSSH по умолчанию используются более современные и безопасные алгоритмы шифрования и ключи для SSH-сессий. Однако Cisco, особенно на старых версиях IOS, поддерживает ограниченный набор шифров — в основном более старые алгоритмы типа aes192-cbc или aes256-cbc.\u003C/p>\n\u003Cp>Поэтому, при попытке просто выполнить команду ssh admin@192.168.10.1 Kali пытается использовать современные алгоритмы, которые Cisco не понимает, и соединение не устанавливается. Чтобы это исправить, нужно явно указать совместимый с Cisco алгоритм шифрования, например:\u003C/p>\n\u003Cp>\u003Ccode>ssh -c aes192-cbc admin@192.168.10.1\u003C/code> или \u003Ccode>ssh -c aes256-cbc admin@192.168.10.1\u003C/code>\u003C/p>\n\u003Cp>Так мы заставляем SSH-клиент использовать именно те алгоритмы, которые принимает Cisco.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/kali_to_mikrotik.png\" alt=\"kali_to_mikrotik\">\u003C/p>\n\u003Cp>В случае с MikroTik таких ограничений нет, так как MikroTik поддерживает современные алгоритмы по умолчанию. Поэтому для подключения к MikroTik достаточно просто: \u003Ccode>ssh admin@172.16.10.1\u003C/code>\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"на-windows-10-1\">На Windows 10\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/win_to_cisco.png\" alt=\"win_to_cisco\">\u003C/p>\n\u003Cp>Аналогично, при подключении с Windows с помощью встроенного SSH-клиента в командной строке (CMD), также нужно учитывать поддержку шифров, особенно при подключении к Cisco. По умолчанию Windows SSH-клиент использует современные алгоритмы шифрования, которые могут не поддерживаться Cisco, особенно на старых версиях IOS. Поэтому простая команда \u003Ccode>ssh admin@192.168.10.1\u003C/code> не сработает из-за несовместимости алгоритмов шифрования. Чтобы установить соединение, нужно указать совместимый с Cisco шифр, \u003Ccode>ssh -c aes256-cbc admin@192.168.10.1\u003C/code>\u003C/p>\n\u003Cp>Так как у меня нет под рукой специализированных эмуляторов терминала, таких как PuTTY или SecureCRT, я использую встроенный CMD для выполнения SSH-подключений.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/win_to_mikrotik.png\" alt=\"win_to_mikrotik\">\u003C/p>\n\u003Cp>В случае с MikroTik такая дополнительная настройка не требуется, так как он поддерживает современные алгоритмы шифрования из коробки. Поэтому для подключения достаточно просто \u003Ccode>ssh admin@172.16.10.1\u003C/code>\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"11-на-mikrotik-разрешить-ssh-подключение-только-с-kali-linux172161010-остальные-ip-заблокировать\">11. На MikroTik разрешить SSH-подключение только с Kali Linux(172.16.10.10), остальные IP заблокировать\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/allow_on_mikrotik.png\" alt=\"allow_on_mikrotik\">\u003C/p>\n\u003Cp>Теперь перейдём к настройке безопасности на MikroTik - ограничим доступ по SSH только с компьютера Kali Linux (IP 172.16.10.10). Для этого настроим правила в firewall, которые разрешат подключаться по SSH только с этого IP, а все остальные подключения заблокируют.\u003C/p>\n\u003Cp>Это позволит нам повысить безопасность, чтобы никто посторонний не смог подключиться к MikroTik по SSH. Такая практика часто используется в реальных сетях для ограничения доступа к важному оборудованию.\u003C/p>\n\u003Cp>В результате мы создадим два правила: первое — разрешить SSH с Kali Linux, второе — блокировать SSH со всех остальных адресов.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/allow_demo.png\" alt=\"allow_demo\">\u003C/p>\n\u003Cp>Как видно на скриншотах, Kali без проблем подключается по SSH к MikroTik, а попытки подключения с Windows 10 не проходят, значит ограничение доступа работает правильно.\u003C/p>",{"headings":383,"localImagePaths":443,"remoteImagePaths":444,"frontmatter":445,"imagePaths":449},[384,385,388,391,394,397,400,403,406,409,412,415,418,421,424,427,430,433,436,438,440],{"depth":30,"slug":298,"text":299},{"depth":30,"slug":386,"text":387},"2-настроить-ip-адреса-на-cisco-r1","2. Настроить IP-адреса на Cisco R1",{"depth":30,"slug":389,"text":390},"3-настроить-ip-адреса-на-mikrotik-r2","3. Настроить IP-адреса на MikroTik R2",{"depth":30,"slug":392,"text":393},"4-назначить-ip-адреса-windows-10-и-kali-linux-в-соответствующих-подсетях","4. Назначить IP-адреса Windows 10 и Kali Linux в соответствующих подсетях",{"depth":209,"slug":395,"text":396},"windows-10","Windows 10",{"depth":209,"slug":398,"text":399},"kali-linux","Kali Linux",{"depth":30,"slug":401,"text":402},"5-проверить-локальную-связность-ping-внутри-office-1-и-office-2","5. Проверить локальную связность (ping) внутри Office 1 и Office 2",{"depth":209,"slug":404,"text":405},"на-windows-10-office-1","На Windows 10 (Office 1)",{"depth":209,"slug":407,"text":408},"на-kali-linux-office-2","На Kali Linux (Office 2)",{"depth":30,"slug":410,"text":411},"6-настроить-маршрутизацию-на-cisco-и-mikrotik-для-обеспечения-связи-между-подсетями-офисов","6. Настроить маршрутизацию на Cisco и MikroTik для обеспечения связи между подсетями офисов",{"depth":209,"slug":413,"text":414},"на-cisco","На Cisco",{"depth":209,"slug":416,"text":417},"на-mikrotik","На Mikrotik",{"depth":30,"slug":419,"text":420},"7-проверить-межсетевую-связность-ping-между-windows-10-и-kali-linux","7. Проверить межсетевую связность (ping) между Windows 10 и Kali Linux",{"depth":209,"slug":422,"text":423},"на-windows-10","На Windows 10",{"depth":209,"slug":425,"text":426},"на-kali-linux","На Kali Linux",{"depth":30,"slug":428,"text":429},"8-настроить-ssh-на-cisco","8. Настроить SSH на Cisco",{"depth":30,"slug":431,"text":432},"9-настроить-ssh-на-mikrotik","9. Настроить SSH на Mikrotik",{"depth":30,"slug":434,"text":435},"10-с-помощью-ssh-подключиться-с-windows-10-к-cisco-и-mikrotik-а-также-с-kali-linux-к-cisco-и-mikrotik","10. С помощью SSH подключиться с Windows 10 к Cisco и MikroTik, а также с Kali Linux к Cisco и MikroTik",{"depth":209,"slug":437,"text":426},"на-kali-linux-1",{"depth":209,"slug":439,"text":423},"на-windows-10-1",{"depth":30,"slug":441,"text":442},"11-на-mikrotik-разрешить-ssh-подключение-только-с-kali-linux172161010-остальные-ip-заблокировать","11. На MikroTik разрешить SSH-подключение только с Kali Linux(172.16.10.10), остальные IP заблокировать",[],[],{"title":376,"description":446,"image":447,"date":448},"В данной работе рассматривается процесс настройки межсетевого SSH-доступа в многосегментной сети Cisco и MikroTik, включая маршрутизацию, правила доступа и проверку соединения","/images/ssh_net/ssh.jpg","8 февраля 2026",[],"en/ssh",{"id":450,"data":452,"body":454,"filePath":455,"digest":456,"rendered":457},{"title":453},"Inter-Network SSH Access in Cisco and MikroTik Networks","In any network, sooner or later there comes a need to manage equipment remotely. Running to each router with a console cable is not a great idea, especially if the devices are located in different offices or network segments. That's exactly why **SSH** is typically used for administration - a protocol that allows you to connect to devices over the network and do it securely.\n\nSSH is needed so you can access a router or server, check the configuration, make changes, or see what's going on in the network. Unlike Telnet, which transmits data in plain text, SSH encrypts all traffic, including login and password, which is why it's used in normal, working networks.\n\nIn practice, a network is almost never limited to one subnet. Usually there are several segments connected to each other by routers. In such a situation, it's important not only to enable SSH, but also to properly configure routing between networks so devices can see each other. And also, restrict access so that SSH connections can only be made from needed addresses, not from just anywhere.\n\nIn this work, we'll practically walk through setting up SSH access in such a multi-segment network. The scheme uses Cisco and MikroTik routers, as well as machines with Windows 10 and Kali Linux. Throughout the work, we'll configure IP addresses, set up routes between subnets, verify connectivity, and organize secure connection to network devices via SSH, including restricting access on MikroTik by IP.\n\n* * *\n\n### 1. Build the Topology\n\n![topology](/images/ssh_net/topology.png)\n\nThe topology is as follows: in the first office, a Windows 10 client connects directly to the G0/0 interface of the Cisco router, and the Cisco router itself connects with its G1/0 interface to MikroTik via a dedicated trunk, emulating a connection between two different network segments. On the other side, MikroTik is connected to the second office where Kali Linux is located.\n\nIn the following steps, IP addressing will be configured: Windows will get address 192.168.10.10, and Cisco — 192.168.10.1 in subnet 192.168.10.0/24, which is used in the first office. For the connection between routers in network 10.10.10.0/30, addresses 10.10.10.1 will be assigned to Cisco and 10.10.10.2 to MikroTik. In the second office, subnet 172.16.10.0/24 will be used, where MikroTik will get address 172.16.10.1, and Kali Linux — 172.16.10.10.\n\n* * *\n\n### 2. Configure IP Addresses on Cisco R1\n\n![set_ip_cisco](/images/ssh_net/set_ip_cisco.png)\n\nAfter building the topology, the next stage is configuring IP addresses on the Cisco router to ensure operation of the first office's local network and connection between offices. In our scheme, the Cisco router has two interfaces — the first interface G0/0 is connected to the local network where the Windows 10 client is located, and the second interface G0/1 is used for connection with the MikroTik router, which is in the second office. Thus, Cisco performs the role of gateway for devices inside the first office and simultaneously provides inter-network connection.\n\nFor the office's local network, we use subnet 192.168.10.0/24, which gives us 256 possible addresses, of which 254 are available for use by devices. The subnet mask 255.255.255.0 (or prefix /24) indicates that the first 24 bits of the address are the network portion, and the remaining 8 bits are for device addressing. In such a scheme, address 192.168.10.0 is the network address, meaning it's a service address and not assigned to devices, and address 192.168.10.255 is the broadcast address — it's used for sending packets to all network participants at once.\n\nTherefore, for the Cisco router on interface G0/0, we assign address 192.168.10.1 — this is a convenient and familiar solution, when exactly the first available address is given to the gateway. This address will be used as the exit point from the network for all devices in the local segment, including the client computer with Windows 10, which will later get address 192.168.10.10.\n\nThe next interface G0/1 of the Cisco router is intended for connection with MikroTik. Here we use network 10.10.10.0/30. Mask 255.255.255.252 (or prefix /30) allows creating a very compact network of four addresses. This is typical practice for a \"point-to-point\" connection, when you need to minimize IP address waste, since such a link connects only two devices — Cisco and MikroTik routers. In this subnet:\n\n- 10.10.10.0 - network address (service, not used).\n- 10.10.10.1 - Cisco address.\n- 10.10.10.2 - MikroTik address.\n- 10.10.10.3 - broadcast address.\n\nUsing a /30 network is suitable for connecting two devices directly, ensuring address space economy and simplifying configuration.\n\nAs a result, the Cisco router gets two addresses:\n\n- On interface G0/0 - 192.168.10.1 for interaction with the local network.\n- On interface G0/1 - 10.10.10.1 for connection with MikroTik.\n\n* * *\n\n### 3. Configure IP Addresses on MikroTik R2\n\n![set_ip_mikrotik](/images/ssh_net/set_ip_mikrotik.png)\n\nWhen first starting MikroTik RouterOS through the console (for example, in GNS3), the device asks for login and password to enter. By default, the login is **admin**, and the password is absent (just press Enter). However, on first setup, the system mandatorily requires setting a new password, since you can't leave an empty password - this is because the new password cannot match the current (empty) one for access security. Therefore, when entering an empty password, an error will appear, and you'll need to enter a password for subsequent login.\n\nNext, we proceed to assigning IP addresses on MikroTik interfaces, which is necessary for proper network operation and inter-network interaction.\n\nIn our topology, MikroTik has two interfaces:\n\n- Interface connected to Cisco (internal link) - IP from network 10.10.10.0/30\n- Interface connected to the second office (local network) - IP from network 172.16.10.0/24\n\nFor convenience and better configuration readability, I renamed the MikroTik interfaces (ether1, ether2, etc.) to more understandable names corresponding to their purpose, *To_Cisco*, *To_Kali* .\n\n* * * \n\n### 4. Assign IP Addresses to Windows 10 and Kali Linux in Respective Subnets\n\n#### Windows 10\n\n![set_ip_windows](/images/ssh_net/set_ip_windows.png)\n\nWe assign IP addresses on client machines - Windows 10 and Kali Linux, so they can correctly interact with routers and each other within their subnets.\n\nIn Windows 10, this is done through network adapter settings. You need to open \"Network and Sharing Center\", select the active connection, go to \"Properties\", then select \"Internet Protocol Version 4 (TCP/IPv4)\" and click \"Properties\". Here you manually enter the IP address, subnet mask, and default gateway. For example, for the first office this will be IP 192.168.10.10 with mask 255.255.255.0 and gateway 192.168.10.1 (Cisco address).\n\n![share_options_windows](/images/ssh_net/share_options_windows.png)\n\nAdditionally, in Windows 10 it's worth paying attention to firewall settings and sharing parameters (Share Options). By default, to increase security, the system blocks incoming ICMP requests (ping) and some types of traffic. For ping from other devices to successfully go through, you need to either temporarily disable the firewall, or configure rules to allow incoming ping requests and other needed protocols. Without this setting, ping may simply not reach Windows, despite correct IP and routes.\n\n----\n\n#### Kali Linux\n\n![set_ip_kali](/images/ssh_net/set_ip_kali.png)\n\nIn Kali Linux, the IP address is assigned through the terminal with the ip addr add command, for example: sudo ip addr add 172.16.10.10/24 dev eth0, where 172.16.10.10 is the IP address, /24 is the subnet mask, and eth0 is the network interface name. To configure the default gateway, the command sudo ip route add default via 172.16.10.1 is used.\n\nManual IP address assignment is necessary since automatic IP acquisition (DHCP servers) are absent in our topology, which helps better understand the basics of IP addressing and how devices communicate on the network.\n\n* * *\n\n### 5. Configure Routing on Cisco\n\n![routing_cisco](/images/ssh_net/routing_cisco.png)\n\nAfter assigning IP addresses on interfaces, we need to configure routing so devices from different subnets can reach each other. On the Cisco router, we add a static route to the second office's subnet 172.16.10.0/24, which is located behind MikroTik.\n\nWe use the command: ```ip route 172.16.10.0 255.255.255.0 10.10.10.2```\n\nThis tells Cisco: \"If you need to reach network 172.16.10.0/24, send packets through the next hop 10.10.10.2\" — which is MikroTik's address on the link between routers.\n\nThanks to this route, when Windows 10 wants to ping Kali Linux (172.16.10.10), the packet goes to Cisco, Cisco sees the route to 172.16.10.0/24 and forwards the packet to MikroTik, which then delivers it to Kali.\n\n* * *\n\n### 6. Configure Routing on MikroTik\n\n![routing_mikrotik](/images/ssh_net/routing_mikrotik.png)\n\nSimilarly, on MikroTik we need to add a route to the first office's network so Kali Linux can reach Windows 10. We add a static route using the command:\n\n```/ip route add dst-address=192.168.10.0/24 gateway=10.10.10.1```\n\nThis tells MikroTik: \"To reach network 192.168.10.0/24, forward packets through 10.10.10.1\" — the Cisco address.\n\nNow the routers know how to reach each other's subnets, and devices in different offices can exchange data.\n\n* * *\n\n### 7. Verify Connectivity Between All Devices\n\n#### From Windows 10\n\n![ping_from_windows_to_routers](/images/ssh_net/ping_from_windows_to_routers.png)\n\nNow it's time to verify that everything is configured correctly. To do this, we'll send ping from both client machines to router interfaces and to each other.\n\n![ping_from_windows_to_routers2](/images/ssh_net/ping_from_windows_to_routers2.png)\n\nThe screenshot shows that from Windows 10 we first send ping to address 10.10.10.2 — this is the MikroTik interface that connects the two routers. Getting responses from MikroTik, we see that the connection with the neighboring router is established and working normally. Then we ping the final address in the other network — 172.16.10.10, where Kali Linux is located. Responses from Kali show that routing is configured correctly, and packets reach the needed device in the second office.\n\n---\n\n#### From Kali Linux\n\n![ping_from_kali_to_routers2](/images/ssh_net/ping_from_kali_to_routers2.png)\n\nFrom Kali the situation is similar: first we send ping to 10.10.10.1 - the Cisco interface, and get responses confirming that there's connection with the first router. Then we ping Windows 10 at address 192.168.10.10, and successful responses show that devices in different offices can exchange data.\n\n* * *\n\n### 8. Configure SSH on Cisco\n\n![ssh_on_cisco](/images/ssh_net/ssh_on_cisco.png)\n\nConfiguring SSH on Cisco is an important step for secure remote access to the router. By default, Cisco uses Telnet, which transmits data in plain text, which is insecure and vulnerable to interception. Therefore, in the vty line configuration, it's necessary to disable Telnet and enable only SSH to increase security.\n\nFirst thing, we set the hostname and domain name, since exactly these parameters are used when generating RSA cryptographic keys. The domain name is needed to create a unique device identifier that's part of the encryption keys.\n\nNext, we generate RSA keys for SSH. The minimum recommended key size is 1024 bits, which already provides an acceptable level of protection. However, if increased security and compliance with modern standards is important, it's better to use a 2048-bit key — this significantly complicates key cracking and protects the connection from attacks. RSA keys create a pair — public and private, which are necessary for encryption and authentication of SSH sessions.\n\nAfter this, we create a local user account, in my case with login admin and password test123, which will be used for authentication when connecting via SSH. This ensures access control and prevents unauthorized entry.\n\nWhen configuring vty lines, we use the login local command — it indicates that local user database is used for authentication (meaning accounts created on the device itself).\n\nAlso, I want to mention, since questions may arise about vty lines — why the range from 0 to 4? Because routers usually have 5 vty lines available numbered from 0 to 4, which allows simultaneously supporting up to 5 remote connections via SSH or Telnet. On switches, the range 0 to 15 is more commonly used, meaning 16 lines, since switches can handle a larger number of simultaneous sessions.\n\nIn vty line settings, we specify authentication through local user database, enable only SSH protocol and prohibit Telnet.\n\nWe'll leave SSH access verification from the client machine for the following steps, where we'll test remote connections. Let's move on to configuring SSH on MikroTik.\n\n* * *\n\n### 9. Configure SSH on Mikrotik\n\n![ssh_on_mikrotik](/images/ssh_net/ssh_on_mtik.png)\n\nNow let's move on to enabling and configuring SSH service on MikroTik. With the command ```/ip service enable ssh``` we activate the SSH server, which allows accepting SSH connections. Next, with the command ```/ip ssh set strong-crypto=yes``` we enable the use of stronger encryption algorithms, increasing connection security. The option ```allow-none-crypto=no``` prohibits insecure encryption variants that could weaken protection.\n\nIn the current setup, we allow password authentication — the command ```/ip ssh set always-allow-password-login=yes``` allows logging in using a password. Later we'll restrict access only by IP addresses to increase security and limit the circle of people who can connect via SSH. We'll configure these restrictions later through firewall and additional security rules.\n\nI want to note that the password for SSH connection is the one we set when first starting MikroTik in section 3 when configuring the router and assigning IP addresses. Besides this, if necessary, you can create additional users with new logins and passwords for more flexible access management.\n\n---\n\n### 10. Using SSH, Connect from Windows 10 to Cisco and MikroTik, and also from Kali Linux to Cisco and MikroTik\n\n#### On Kali Linux\n\n![kali_to_cisco](/images/ssh_net/kali_to_cisco.png)\n\nOn Kali Linux I have OpenSSH version 8.0p1 (Debian 4) with OpenSSL 1.1.1c installed. In new versions of OpenSSH, more modern and secure encryption algorithms and keys are used by default for SSH sessions. However, Cisco, especially on older IOS versions, supports a limited set of ciphers — mainly older algorithms like aes192-cbc or aes256-cbc.\n\nTherefore, when simply trying to execute the command ssh admin@192.168.10.1, Kali tries to use modern algorithms that Cisco doesn't understand, and the connection isn't established. To fix this, you need to explicitly specify an encryption algorithm compatible with Cisco, for example:\n\n```ssh -c aes192-cbc admin@192.168.10.1``` or ```ssh -c aes256-cbc admin@192.168.10.1```\n\nThis way we force the SSH client to use exactly those algorithms that Cisco accepts.\n\n![kali_to_mikrotik](/images/ssh_net/kali_to_mikrotik.png)\n\nIn the case of MikroTik, there are no such limitations, since MikroTik supports modern algorithms by default. Therefore, to connect to MikroTik, it's simply enough: ```ssh admin@172.16.10.1```\n\n---\n\n#### On Windows 10\n\n![win_to_cisco](/images/ssh_net/win_to_cisco.png)\n\nSimilarly, when connecting from Windows using the built-in SSH client in command prompt (CMD), you also need to consider cipher support, especially when connecting to Cisco. By default, the Windows SSH client uses modern encryption algorithms that may not be supported by Cisco, especially on older IOS versions. Therefore, the simple command ```ssh admin@192.168.10.1``` won't work due to encryption algorithm incompatibility. To establish a connection, you need to specify a Cisco-compatible cipher, ```ssh -c aes256-cbc admin@192.168.10.1```\n\nSince I don't have specialized terminal emulators at hand, such as PuTTY or SecureCRT, I use the built-in CMD to perform SSH connections.\n\n![win_to_mikrotik](/images/ssh_net/win_to_mikrotik.png)\n\nIn the case of MikroTik, such additional configuration is not required, since it supports modern encryption algorithms out of the box. Therefore, to connect it's simply enough ```ssh admin@172.16.10.1```\n\n* * *\n\n### 11. On MikroTik, Allow SSH Connection Only from Kali Linux(172.16.10.10), Block All Other IPs\n\n![allow_on_mikrotik](/images/ssh_net/allow_on_mikrotik.png)\n\nNow let's move on to configuring security on MikroTik - we'll restrict SSH access only from the Kali Linux computer (IP 172.16.10.10). For this, we'll configure firewall rules that will allow SSH connections only from this IP, and block all other connections.\n\nThis will allow us to increase security so that no outsider can connect to MikroTik via SSH. Such practice is often used in real networks to restrict access to important equipment.\n\nAs a result, we'll create two rules: the first — allow SSH from Kali Linux, the second — block SSH from all other addresses.\n\n![allow_demo](/images/ssh_net/allow_demo.png)\n\nAs can be seen in the screenshots, Kali connects to MikroTik via SSH without problems, while connection attempts from Windows 10 don't go through, meaning the access restriction is working correctly.","src/content/articles/en/ssh.md","03787f3cd2e9cd7b",{"html":458,"metadata":459},"\u003Cp>In any network, sooner or later there comes a need to manage equipment remotely. Running to each router with a console cable is not a great idea, especially if the devices are located in different offices or network segments. That’s exactly why \u003Cstrong>SSH\u003C/strong> is typically used for administration - a protocol that allows you to connect to devices over the network and do it securely.\u003C/p>\n\u003Cp>SSH is needed so you can access a router or server, check the configuration, make changes, or see what’s going on in the network. Unlike Telnet, which transmits data in plain text, SSH encrypts all traffic, including login and password, which is why it’s used in normal, working networks.\u003C/p>\n\u003Cp>In practice, a network is almost never limited to one subnet. Usually there are several segments connected to each other by routers. In such a situation, it’s important not only to enable SSH, but also to properly configure routing between networks so devices can see each other. And also, restrict access so that SSH connections can only be made from needed addresses, not from just anywhere.\u003C/p>\n\u003Cp>In this work, we’ll practically walk through setting up SSH access in such a multi-segment network. The scheme uses Cisco and MikroTik routers, as well as machines with Windows 10 and Kali Linux. Throughout the work, we’ll configure IP addresses, set up routes between subnets, verify connectivity, and organize secure connection to network devices via SSH, including restricting access on MikroTik by IP.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"1-build-the-topology\">1. Build the Topology\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/topology.png\" alt=\"topology\">\u003C/p>\n\u003Cp>The topology is as follows: in the first office, a Windows 10 client connects directly to the G0/0 interface of the Cisco router, and the Cisco router itself connects with its G1/0 interface to MikroTik via a dedicated trunk, emulating a connection between two different network segments. On the other side, MikroTik is connected to the second office where Kali Linux is located.\u003C/p>\n\u003Cp>In the following steps, IP addressing will be configured: Windows will get address 192.168.10.10, and Cisco — 192.168.10.1 in subnet 192.168.10.0/24, which is used in the first office. For the connection between routers in network 10.10.10.0/30, addresses 10.10.10.1 will be assigned to Cisco and 10.10.10.2 to MikroTik. In the second office, subnet 172.16.10.0/24 will be used, where MikroTik will get address 172.16.10.1, and Kali Linux — 172.16.10.10.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"2-configure-ip-addresses-on-cisco-r1\">2. Configure IP Addresses on Cisco R1\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/set_ip_cisco.png\" alt=\"set_ip_cisco\">\u003C/p>\n\u003Cp>After building the topology, the next stage is configuring IP addresses on the Cisco router to ensure operation of the first office’s local network and connection between offices. In our scheme, the Cisco router has two interfaces — the first interface G0/0 is connected to the local network where the Windows 10 client is located, and the second interface G0/1 is used for connection with the MikroTik router, which is in the second office. Thus, Cisco performs the role of gateway for devices inside the first office and simultaneously provides inter-network connection.\u003C/p>\n\u003Cp>For the office’s local network, we use subnet 192.168.10.0/24, which gives us 256 possible addresses, of which 254 are available for use by devices. The subnet mask 255.255.255.0 (or prefix /24) indicates that the first 24 bits of the address are the network portion, and the remaining 8 bits are for device addressing. In such a scheme, address 192.168.10.0 is the network address, meaning it’s a service address and not assigned to devices, and address 192.168.10.255 is the broadcast address — it’s used for sending packets to all network participants at once.\u003C/p>\n\u003Cp>Therefore, for the Cisco router on interface G0/0, we assign address 192.168.10.1 — this is a convenient and familiar solution, when exactly the first available address is given to the gateway. This address will be used as the exit point from the network for all devices in the local segment, including the client computer with Windows 10, which will later get address 192.168.10.10.\u003C/p>\n\u003Cp>The next interface G0/1 of the Cisco router is intended for connection with MikroTik. Here we use network 10.10.10.0/30. Mask 255.255.255.252 (or prefix /30) allows creating a very compact network of four addresses. This is typical practice for a “point-to-point” connection, when you need to minimize IP address waste, since such a link connects only two devices — Cisco and MikroTik routers. In this subnet:\u003C/p>\n\u003Cul>\n\u003Cli>10.10.10.0 - network address (service, not used).\u003C/li>\n\u003Cli>10.10.10.1 - Cisco address.\u003C/li>\n\u003Cli>10.10.10.2 - MikroTik address.\u003C/li>\n\u003Cli>10.10.10.3 - broadcast address.\u003C/li>\n\u003C/ul>\n\u003Cp>Using a /30 network is suitable for connecting two devices directly, ensuring address space economy and simplifying configuration.\u003C/p>\n\u003Cp>As a result, the Cisco router gets two addresses:\u003C/p>\n\u003Cul>\n\u003Cli>On interface G0/0 - 192.168.10.1 for interaction with the local network.\u003C/li>\n\u003Cli>On interface G0/1 - 10.10.10.1 for connection with MikroTik.\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch3 id=\"3-configure-ip-addresses-on-mikrotik-r2\">3. Configure IP Addresses on MikroTik R2\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/set_ip_mikrotik.png\" alt=\"set_ip_mikrotik\">\u003C/p>\n\u003Cp>When first starting MikroTik RouterOS through the console (for example, in GNS3), the device asks for login and password to enter. By default, the login is \u003Cstrong>admin\u003C/strong>, and the password is absent (just press Enter). However, on first setup, the system mandatorily requires setting a new password, since you can’t leave an empty password - this is because the new password cannot match the current (empty) one for access security. Therefore, when entering an empty password, an error will appear, and you’ll need to enter a password for subsequent login.\u003C/p>\n\u003Cp>Next, we proceed to assigning IP addresses on MikroTik interfaces, which is necessary for proper network operation and inter-network interaction.\u003C/p>\n\u003Cp>In our topology, MikroTik has two interfaces:\u003C/p>\n\u003Cul>\n\u003Cli>Interface connected to Cisco (internal link) - IP from network 10.10.10.0/30\u003C/li>\n\u003Cli>Interface connected to the second office (local network) - IP from network 172.16.10.0/24\u003C/li>\n\u003C/ul>\n\u003Cp>For convenience and better configuration readability, I renamed the MikroTik interfaces (ether1, ether2, etc.) to more understandable names corresponding to their purpose, \u003Cem>To_Cisco\u003C/em>, \u003Cem>To_Kali\u003C/em> .\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"4-assign-ip-addresses-to-windows-10-and-kali-linux-in-respective-subnets\">4. Assign IP Addresses to Windows 10 and Kali Linux in Respective Subnets\u003C/h3>\n\u003Ch4 id=\"windows-10\">Windows 10\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/set_ip_windows.png\" alt=\"set_ip_windows\">\u003C/p>\n\u003Cp>We assign IP addresses on client machines - Windows 10 and Kali Linux, so they can correctly interact with routers and each other within their subnets.\u003C/p>\n\u003Cp>In Windows 10, this is done through network adapter settings. You need to open “Network and Sharing Center”, select the active connection, go to “Properties”, then select “Internet Protocol Version 4 (TCP/IPv4)” and click “Properties”. Here you manually enter the IP address, subnet mask, and default gateway. For example, for the first office this will be IP 192.168.10.10 with mask 255.255.255.0 and gateway 192.168.10.1 (Cisco address).\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/share_options_windows.png\" alt=\"share_options_windows\">\u003C/p>\n\u003Cp>Additionally, in Windows 10 it’s worth paying attention to firewall settings and sharing parameters (Share Options). By default, to increase security, the system blocks incoming ICMP requests (ping) and some types of traffic. For ping from other devices to successfully go through, you need to either temporarily disable the firewall, or configure rules to allow incoming ping requests and other needed protocols. Without this setting, ping may simply not reach Windows, despite correct IP and routes.\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"kali-linux\">Kali Linux\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/set_ip_kali.png\" alt=\"set_ip_kali\">\u003C/p>\n\u003Cp>In Kali Linux, the IP address is assigned through the terminal with the ip addr add command, for example: sudo ip addr add 172.16.10.10/24 dev eth0, where 172.16.10.10 is the IP address, /24 is the subnet mask, and eth0 is the network interface name. To configure the default gateway, the command sudo ip route add default via 172.16.10.1 is used.\u003C/p>\n\u003Cp>Manual IP address assignment is necessary since automatic IP acquisition (DHCP servers) are absent in our topology, which helps better understand the basics of IP addressing and how devices communicate on the network.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"5-configure-routing-on-cisco\">5. Configure Routing on Cisco\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/routing_cisco.png\" alt=\"routing_cisco\">\u003C/p>\n\u003Cp>After assigning IP addresses on interfaces, we need to configure routing so devices from different subnets can reach each other. On the Cisco router, we add a static route to the second office’s subnet 172.16.10.0/24, which is located behind MikroTik.\u003C/p>\n\u003Cp>We use the command: \u003Ccode>ip route 172.16.10.0 255.255.255.0 10.10.10.2\u003C/code>\u003C/p>\n\u003Cp>This tells Cisco: “If you need to reach network 172.16.10.0/24, send packets through the next hop 10.10.10.2” — which is MikroTik’s address on the link between routers.\u003C/p>\n\u003Cp>Thanks to this route, when Windows 10 wants to ping Kali Linux (172.16.10.10), the packet goes to Cisco, Cisco sees the route to 172.16.10.0/24 and forwards the packet to MikroTik, which then delivers it to Kali.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"6-configure-routing-on-mikrotik\">6. Configure Routing on MikroTik\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/routing_mikrotik.png\" alt=\"routing_mikrotik\">\u003C/p>\n\u003Cp>Similarly, on MikroTik we need to add a route to the first office’s network so Kali Linux can reach Windows 10. We add a static route using the command:\u003C/p>\n\u003Cp>\u003Ccode>/ip route add dst-address=192.168.10.0/24 gateway=10.10.10.1\u003C/code>\u003C/p>\n\u003Cp>This tells MikroTik: “To reach network 192.168.10.0/24, forward packets through 10.10.10.1” — the Cisco address.\u003C/p>\n\u003Cp>Now the routers know how to reach each other’s subnets, and devices in different offices can exchange data.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"7-verify-connectivity-between-all-devices\">7. Verify Connectivity Between All Devices\u003C/h3>\n\u003Ch4 id=\"from-windows-10\">From Windows 10\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/ping_from_windows_to_routers.png\" alt=\"ping_from_windows_to_routers\">\u003C/p>\n\u003Cp>Now it’s time to verify that everything is configured correctly. To do this, we’ll send ping from both client machines to router interfaces and to each other.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/ping_from_windows_to_routers2.png\" alt=\"ping_from_windows_to_routers2\">\u003C/p>\n\u003Cp>The screenshot shows that from Windows 10 we first send ping to address 10.10.10.2 — this is the MikroTik interface that connects the two routers. Getting responses from MikroTik, we see that the connection with the neighboring router is established and working normally. Then we ping the final address in the other network — 172.16.10.10, where Kali Linux is located. Responses from Kali show that routing is configured correctly, and packets reach the needed device in the second office.\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"from-kali-linux\">From Kali Linux\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/ping_from_kali_to_routers2.png\" alt=\"ping_from_kali_to_routers2\">\u003C/p>\n\u003Cp>From Kali the situation is similar: first we send ping to 10.10.10.1 - the Cisco interface, and get responses confirming that there’s connection with the first router. Then we ping Windows 10 at address 192.168.10.10, and successful responses show that devices in different offices can exchange data.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"8-configure-ssh-on-cisco\">8. Configure SSH on Cisco\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/ssh_on_cisco.png\" alt=\"ssh_on_cisco\">\u003C/p>\n\u003Cp>Configuring SSH on Cisco is an important step for secure remote access to the router. By default, Cisco uses Telnet, which transmits data in plain text, which is insecure and vulnerable to interception. Therefore, in the vty line configuration, it’s necessary to disable Telnet and enable only SSH to increase security.\u003C/p>\n\u003Cp>First thing, we set the hostname and domain name, since exactly these parameters are used when generating RSA cryptographic keys. The domain name is needed to create a unique device identifier that’s part of the encryption keys.\u003C/p>\n\u003Cp>Next, we generate RSA keys for SSH. The minimum recommended key size is 1024 bits, which already provides an acceptable level of protection. However, if increased security and compliance with modern standards is important, it’s better to use a 2048-bit key — this significantly complicates key cracking and protects the connection from attacks. RSA keys create a pair — public and private, which are necessary for encryption and authentication of SSH sessions.\u003C/p>\n\u003Cp>After this, we create a local user account, in my case with login admin and password test123, which will be used for authentication when connecting via SSH. This ensures access control and prevents unauthorized entry.\u003C/p>\n\u003Cp>When configuring vty lines, we use the login local command — it indicates that local user database is used for authentication (meaning accounts created on the device itself).\u003C/p>\n\u003Cp>Also, I want to mention, since questions may arise about vty lines — why the range from 0 to 4? Because routers usually have 5 vty lines available numbered from 0 to 4, which allows simultaneously supporting up to 5 remote connections via SSH or Telnet. On switches, the range 0 to 15 is more commonly used, meaning 16 lines, since switches can handle a larger number of simultaneous sessions.\u003C/p>\n\u003Cp>In vty line settings, we specify authentication through local user database, enable only SSH protocol and prohibit Telnet.\u003C/p>\n\u003Cp>We’ll leave SSH access verification from the client machine for the following steps, where we’ll test remote connections. Let’s move on to configuring SSH on MikroTik.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"9-configure-ssh-on-mikrotik\">9. Configure SSH on Mikrotik\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/ssh_on_mtik.png\" alt=\"ssh_on_mikrotik\">\u003C/p>\n\u003Cp>Now let’s move on to enabling and configuring SSH service on MikroTik. With the command \u003Ccode>/ip service enable ssh\u003C/code> we activate the SSH server, which allows accepting SSH connections. Next, with the command \u003Ccode>/ip ssh set strong-crypto=yes\u003C/code> we enable the use of stronger encryption algorithms, increasing connection security. The option \u003Ccode>allow-none-crypto=no\u003C/code> prohibits insecure encryption variants that could weaken protection.\u003C/p>\n\u003Cp>In the current setup, we allow password authentication — the command \u003Ccode>/ip ssh set always-allow-password-login=yes\u003C/code> allows logging in using a password. Later we’ll restrict access only by IP addresses to increase security and limit the circle of people who can connect via SSH. We’ll configure these restrictions later through firewall and additional security rules.\u003C/p>\n\u003Cp>I want to note that the password for SSH connection is the one we set when first starting MikroTik in section 3 when configuring the router and assigning IP addresses. Besides this, if necessary, you can create additional users with new logins and passwords for more flexible access management.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"10-using-ssh-connect-from-windows-10-to-cisco-and-mikrotik-and-also-from-kali-linux-to-cisco-and-mikrotik\">10. Using SSH, Connect from Windows 10 to Cisco and MikroTik, and also from Kali Linux to Cisco and MikroTik\u003C/h3>\n\u003Ch4 id=\"on-kali-linux\">On Kali Linux\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/kali_to_cisco.png\" alt=\"kali_to_cisco\">\u003C/p>\n\u003Cp>On Kali Linux I have OpenSSH version 8.0p1 (Debian 4) with OpenSSL 1.1.1c installed. In new versions of OpenSSH, more modern and secure encryption algorithms and keys are used by default for SSH sessions. However, Cisco, especially on older IOS versions, supports a limited set of ciphers — mainly older algorithms like aes192-cbc or aes256-cbc.\u003C/p>\n\u003Cp>Therefore, when simply trying to execute the command ssh admin@192.168.10.1, Kali tries to use modern algorithms that Cisco doesn’t understand, and the connection isn’t established. To fix this, you need to explicitly specify an encryption algorithm compatible with Cisco, for example:\u003C/p>\n\u003Cp>\u003Ccode>ssh -c aes192-cbc admin@192.168.10.1\u003C/code> or \u003Ccode>ssh -c aes256-cbc admin@192.168.10.1\u003C/code>\u003C/p>\n\u003Cp>This way we force the SSH client to use exactly those algorithms that Cisco accepts.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/kali_to_mikrotik.png\" alt=\"kali_to_mikrotik\">\u003C/p>\n\u003Cp>In the case of MikroTik, there are no such limitations, since MikroTik supports modern algorithms by default. Therefore, to connect to MikroTik, it’s simply enough: \u003Ccode>ssh admin@172.16.10.1\u003C/code>\u003C/p>\n\u003Chr>\n\u003Ch4 id=\"on-windows-10\">On Windows 10\u003C/h4>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/win_to_cisco.png\" alt=\"win_to_cisco\">\u003C/p>\n\u003Cp>Similarly, when connecting from Windows using the built-in SSH client in command prompt (CMD), you also need to consider cipher support, especially when connecting to Cisco. By default, the Windows SSH client uses modern encryption algorithms that may not be supported by Cisco, especially on older IOS versions. Therefore, the simple command \u003Ccode>ssh admin@192.168.10.1\u003C/code> won’t work due to encryption algorithm incompatibility. To establish a connection, you need to specify a Cisco-compatible cipher, \u003Ccode>ssh -c aes256-cbc admin@192.168.10.1\u003C/code>\u003C/p>\n\u003Cp>Since I don’t have specialized terminal emulators at hand, such as PuTTY or SecureCRT, I use the built-in CMD to perform SSH connections.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/win_to_mikrotik.png\" alt=\"win_to_mikrotik\">\u003C/p>\n\u003Cp>In the case of MikroTik, such additional configuration is not required, since it supports modern encryption algorithms out of the box. Therefore, to connect it’s simply enough \u003Ccode>ssh admin@172.16.10.1\u003C/code>\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"11-on-mikrotik-allow-ssh-connection-only-from-kali-linux172161010-block-all-other-ips\">11. On MikroTik, Allow SSH Connection Only from Kali Linux(172.16.10.10), Block All Other IPs\u003C/h3>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/allow_on_mikrotik.png\" alt=\"allow_on_mikrotik\">\u003C/p>\n\u003Cp>Now let’s move on to configuring security on MikroTik - we’ll restrict SSH access only from the Kali Linux computer (IP 172.16.10.10). For this, we’ll configure firewall rules that will allow SSH connections only from this IP, and block all other connections.\u003C/p>\n\u003Cp>This will allow us to increase security so that no outsider can connect to MikroTik via SSH. Such practice is often used in real networks to restrict access to important equipment.\u003C/p>\n\u003Cp>As a result, we’ll create two rules: the first — allow SSH from Kali Linux, the second — block SSH from all other addresses.\u003C/p>\n\u003Cp>\u003Cimg src=\"/images/ssh_net/allow_demo.png\" alt=\"allow_demo\">\u003C/p>\n\u003Cp>As can be seen in the screenshots, Kali connects to MikroTik via SSH without problems, while connection attempts from Windows 10 don’t go through, meaning the access restriction is working correctly.\u003C/p>",{"headings":460,"localImagePaths":506,"remoteImagePaths":507,"frontmatter":508,"imagePaths":511},[461,462,465,468,471,472,473,476,479,482,485,488,491,494,497,500,503],{"depth":30,"slug":200,"text":201},{"depth":30,"slug":463,"text":464},"2-configure-ip-addresses-on-cisco-r1","2. Configure IP Addresses on Cisco R1",{"depth":30,"slug":466,"text":467},"3-configure-ip-addresses-on-mikrotik-r2","3. Configure IP Addresses on MikroTik R2",{"depth":30,"slug":469,"text":470},"4-assign-ip-addresses-to-windows-10-and-kali-linux-in-respective-subnets","4. Assign IP Addresses to Windows 10 and Kali Linux in Respective Subnets",{"depth":209,"slug":395,"text":396},{"depth":209,"slug":398,"text":399},{"depth":30,"slug":474,"text":475},"5-configure-routing-on-cisco","5. Configure Routing on Cisco",{"depth":30,"slug":477,"text":478},"6-configure-routing-on-mikrotik","6. Configure Routing on MikroTik",{"depth":30,"slug":480,"text":481},"7-verify-connectivity-between-all-devices","7. Verify Connectivity Between All Devices",{"depth":209,"slug":483,"text":484},"from-windows-10","From Windows 10",{"depth":209,"slug":486,"text":487},"from-kali-linux","From Kali Linux",{"depth":30,"slug":489,"text":490},"8-configure-ssh-on-cisco","8. Configure SSH on Cisco",{"depth":30,"slug":492,"text":493},"9-configure-ssh-on-mikrotik","9. Configure SSH on Mikrotik",{"depth":30,"slug":495,"text":496},"10-using-ssh-connect-from-windows-10-to-cisco-and-mikrotik-and-also-from-kali-linux-to-cisco-and-mikrotik","10. Using SSH, Connect from Windows 10 to Cisco and MikroTik, and also from Kali Linux to Cisco and MikroTik",{"depth":209,"slug":498,"text":499},"on-kali-linux","On Kali Linux",{"depth":209,"slug":501,"text":502},"on-windows-10","On Windows 10",{"depth":30,"slug":504,"text":505},"11-on-mikrotik-allow-ssh-connection-only-from-kali-linux172161010-block-all-other-ips","11. On MikroTik, Allow SSH Connection Only from Kali Linux(172.16.10.10), Block All Other IPs",[],[],{"title":453,"description":509,"image":447,"date":510},"This work examines the process of configuring inter-network SSH access in a multi-segment Cisco and MikroTik network, including routing, access rules, and connection verification","February 8, 2026",[]]