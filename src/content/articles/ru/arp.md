---
title: "Протокол ARP и обмен данными в локальной сети"
description: "В этой работе мы подробно разберём, как работает ARP, от принципов обмена ARP-запросами и ответами, через анализ сетевого трафика с помощью Wireshark"
image: "/images/arp_net/arp.jpg"
date: "9 февраля 2026"
---
**ARP (Address Resolution Protocol)** - это протокол, который помогает устройствам в локальной сети находить друг друга.

Обычно мы работаем с IP-адресами или доменными именами (которые через DNS превращаются в IP). Но внутри локальной сети данные передаются не по IP, а по MAC-адресам. Коммутаторы видят только MAC-адреса и понятия не имеют, что такое IP.

Поэтому перед отправкой данных устройство должно узнать: какому MAC-адресу соответствует нужный IP. Этим и занимается ARP.

Он рассылает запрос в сети, получает ответ от нужного устройства и запоминает соответствие IP ↔ MAC. Благодаря этому устройства могут нормально обмениваться данными, даже если физический адрес получателя был неизвестен заранее.


### 1. Построить топологию

![01_topology](/handson/images/arp_net/01_topology.png)

Для лабораторного стенда в GNS3 мы создадим простую сеть с маршрутизатором Cisco, коммутатором и двумя виртуальными машинами. На маршрутизаторе будет настроен интерфейс FastEthernet0/0 с адресом *192.168.1.1/24*, который будет выполнять роль шлюза для всех устройств сети. Коммутатор объединяет все узлы в одной подсети, обеспечивая передачу данных на канальном уровне.

* * *

### 2. Настройка IP-адресов на роутере и клиентских ПК

![02_set_router](/images/arp_net/02_set_router.png)

Переходим к настройке маршрутизатора Cisco. Сначала выбираем нужный интерфейс, в моем случае FastEthernet0/0, и задаём ему IP-адрес и маску подсети. Для интерфейса в нашей сети назначаем *192.168.1.1/24*. После этого интерфейс необходимо активировать командой **no shutdown**, чтобы он начал работать и пропускать трафик. Теперь маршрутизатор готов обмениваться данными с устройствами в локальной сети.

* * *

![03_set_windows](/images/arp_net/03_set_windows.png)

Теперь настроим IP-адрес на клиентской машине с Windows 10. Для этого открываем параметры сетевого адаптера, выбираем нужное подключение и вручную указываем IP-адрес, маску подсети и шлюз. В нашем примере для Windows задаём IP *192.168.1.10*, маску подсети *255.255.255.0*, а в качестве шлюза указываем адрес маршрутизатора - *192.168.1.1*. После сохранения настроек компьютер сможет обмениваться данными с другими устройствами сети и выходить в локальную подсеть.

* * *

![04_set_route](/images/arp_net/04_set_route.png)

На Linux настройку IP-адреса будем выполнять вручную через терминал. В нашем случае сетевой интерфейс называется **enp2s0**. Чтобы назначить статический IP, используем команду **sudo ip addr add 192.168.1.11/24 dev enp2s0**. Далее необходимо указать шлюз по умолчанию, через который устройство будет выходить в сеть **sudo ip route add default via 192.168.1.1**. После этих действий интерфейс enp2s0 получает IP-адрес *192.168.1.11* с маской подсети *255.255.255.0*, а маршрутизатор *192.168.1.1* выступает в роли шлюза. Теперь Ubuntu-машина может корректно обмениваться данными с другими устройствами сети и взаимодействовать с маршрутизатором.

* * *

### 3. Разбор стандартного обмена ARP-сообщениями

![05_empty_arp](/images/arp_net/05_empty_arp.png)

Переходим к захвату сетевого трафика с помощью Wireshark. Для удобства фильтруем пакеты по протоколу ARP, чтобы видеть только сообщения ARP. В начале захвата ARP-таблицы на обоих хостах пусты, поэтому все запросы и ответы будут фиксироваться с нуля.

* * *

![06_arp_d_win](/images/arp_net/06_arp_d_win.png)

Перед началом эксперимента будем очищать ARP-кэш на обоих хостах, чтобы все записи создавались заново и наблюдать процесс в реальном времени.

На Windows это делается через командную строку командой **arp -d**. Эта команда удаляет все существующие записи ARP. Затем можно проверить состояние таблицы с помощью **arp -a**.

В начале таблица пустая, но после выполнения команды ping на другой хост появятся новые записи, отражающие недавно разрешённые MAC-адреса

* * *

![07_arp_d_linux](/images/arp_net/07_arp_d_linux.png)

На Linux очистка ARP-кэша выполняется командой **sudo ip neigh flush all**. Эта команда удаляет все текущие записи ARP для всех интерфейсов, включая enp2s0 в нашем случае. После её выполнения система забывает, какие MAC-адреса соответствуют каким IP, и все последующие обращения к другим устройствам сети будут инициировать новые ARP-запросы.

Чтобы убедиться, что таблица действительно пуста, можно командой **ip neigh show**. В начале вывод будет пустым, так как записи удалены. После того как хост попытается отправить данные другому устройству, в таблице появятся новые записи, отражающие только что разрешённые MAC-адреса.

* * *

![08_ping](/images/arp_net/08_ping.png)

Выполняем отправку ICMP-запросов на Linux-машину с IP-адресом *192.168.1.11*, после чего переходим к анализу сетевого трафика в программе Wireshark.

* * *

![09_wireshark](/images/arp_net/09_wireshark.png)

В Wireshark появились записи ARP-запросов и ARP-ответов.

* * *

#### ARP Запрос

![10_arp_request](/images/arp_net/10_arp_request.png)

Когда устройство в локальной сети хочет отправить данные другому устройству, оно должно знать MAC-адрес получателя. Если в ARP-кэше записи для этого IP нет, система выполняет следующие шаги:

- **Шаг 1:** Проверка ARP-кэша. Компьютер сначала проверяет свою таблицу ARP. Если запись для нужного IP отсутствует, нужно узнать MAC-адрес устройства с этим IP.

- **Шаг 2:** Формирование ARP-запроса. Устройство создаёт ARP-пакет, в котором указывает:

    - Свой MAC и IP, чтобы получатель знал, кто спрашивает.
    - IP-адрес цели - адрес, чей MAC нужно узнать.
    - MAC-адрес цели оставляется пустым (00:00:00:00:00:00), так как его ещё нет.

- **Шаг 3:**. Отправка запроса всем устройствам сети (broadcast)
Пакет отправляется на адрес ff:ff:ff:ff:ff:ff, то есть на все компьютеры в локальной сети, чтобы нужное устройство его точно получило.

- **Шаг 4:**. Обработка запроса другими устройствами. Каждый компьютер проверяет, совпадает ли его IP с целевым: Если совпадает то устройство формирует ARP-ответ и отправляет обратно отправителю. Если не совпадает то игнорирует пакет.

- **Шаг 5**. Обновление ARP-кэша. После получения ответа отправитель сохраняет в ARP-кэше соответствие IP ↔ MAC. Теперь последующие передачи данных можно делать напрямую, без нового запроса.

**Поля ARP-запроса**

| Поле                  | Пример значения       | Описание                                                      |
|-----------------------|---------------------|---------------------------------------------------------------|
| **Hardware Type**      | Ethernet (1)         | Тип канального уровня (Ethernet).                             |
| **Protocol Type**      | IPv4 (0x0800)        | Протокол верхнего уровня, для которого ищем MAC (IPv4).      |
| **Hardware Size**      | 6                    | Длина MAC-адреса в байтах.                                   |
| **Protocol Size**      | 4                    | Длина IP-адреса в байтах.                                    |
| **Opcode**             | Request (1)          | Тип ARP-сообщения: 1 — запрос.                               |
| **Sender MAC Address** | 0c:e5:1d:02:00:00   | MAC-адрес отправителя запроса.                                |
| **Sender IP Address**  | 192.168.1.10         | IP-адрес отправителя.                                        |
| **Target MAC Address** | 00:00:00:00:00:00    | MAC-адрес цели (ещё неизвестен).                             |
| **Target IP Address**  | 192.168.1.11         | IP-адрес устройства, MAC-адрес которого нужно узнать.        |

* * *

#### ARP Ответ

![11_arp_reply](/images/arp_net/11_arp_reply.png)

Когда устройство получает ARP-запрос и обнаруживает, что IP в запросе совпадает с его собственным, оно формирует ARP-ответ. Это сообщение сообщает отправителю запроса, какой MAC-адрес соответствует запрашиваемому IP.

-   **Шаг 1:** Получение ARP-запроса. Устройство получает ARP-запрос и проверяет, совпадает ли его IP с IP-адресом в запросе. Если совпадает, готовится ответ.
    
-   **Шаг 2:** Формирование ARP-ответа. Устройство создаёт ARP-пакет, в котором указывает:
    
    -   Свой MAC и IP — это адрес и IP устройства, которое отвечает.
    -   MAC и IP отправителя запроса — чтобы ответ дошёл точно до него.
        
-   **Шаг 3:** Отправка ответа напрямую(unicast). ARP Reply отправляется на MAC-адрес отправителя запроса, а не на broadcast. Пакет идёт только нужному устройству.
    
-   **Шаг 4:** Обновление ARP-кэша у получателя. Компьютер, который отправил запрос, получает ответ и записывает соответствие IP ↔ MAC в свой ARP-кэш.
    
-   **Шаг 5:** Дальнейшая передача данных. После записи в кэш устройство может отправлять данные напрямую, без необходимости нового ARP-запроса.

**Поля ARP-ответа**

| Поле                  | Пример значения       | Описание                                                      |
|-----------------------|---------------------|---------------------------------------------------------------|
| **Hardware Type**      | Ethernet (1)         | Тип канального уровня (Ethernet).                             |
| **Protocol Type**      | IPv4 (0x0800)        | Протокол верхнего уровня (IPv4).                              |
| **Hardware Size**      | 6                    | Длина MAC-адреса в байтах.                                   |
| **Protocol Size**      | 4                    | Длина IP-адреса в байтах.                                    |
| **Opcode**             | Reply (2)            | Тип ARP-сообщения: 2 — ответ.                                 |
| **Sender MAC Address** | 0c:ef:f7:15:00:00   | MAC-адрес устройства, которое отвечает на запрос.             |
| **Sender IP Address**  | 192.168.1.11         | IP-адрес устройства, которое отвечает.                        |
| **Target MAC Address** | 0c:e5:1d:02:00:00   | MAC-адрес устройства, которому предназначен ответ.           |
| **Target IP Address**  | 192.168.1.10         | IP-адрес устройства, которому предназначен ответ.            |


* * *

### Разбор стандартного обмена Gratuitous ARP (G-ARP) в сети

![12_arping_linux_grad](/images/arp_net/12_arping_linux_grad.png)

Gratuitous ARP — это особый вид ARP-сообщений, который устройство отправляет о себе, без того чтобы кто-то делал запрос. Иными словами, компьютер или сервер сам сообщает сети: «Вот мой IP и MAC-адрес». Такие пакеты не требуют ответа от других устройств — они рассылаются широковещательно, чтобы все компьютеры и сетевое оборудование в локальной сети обновили свои ARP-кэши.

Основные цели использования G-ARP следующие:

1. Обновление ARP-кэшей других устройств. Если на устройстве поменялся MAC-адрес или IP, отправка G-ARP позволяет всем узлам сети узнать актуальные данные.

2. Проверка занятости IP-адреса. Устройство может отправить G-ARP для того, чтобы убедиться, что данный IP не используется другим устройством.

3. Информирование сети при запуске устройства. Когда компьютер или сервер только включился, G-ARP помогает маршрутизаторам, коммутаторам и другим хостам быстро узнать правильный MAC для его IP.

В Linux отправка G-ARP легко выполняется с помощью утилиты **arping**. При этом устройство посылает ARP Reply на широковещательный адрес, но не ждёт ответа. Такой подход отличается от стандартного ARP-запроса, когда компьютер ищет MAC-адрес другого хоста и ждёт ответа.

Например, если Ubuntu отправляет G-ARP для IP 192.168.1.11, она рассылает сообщение по сети, сообщая свой MAC-адрес. Все устройства в локальной сети, которые получают этот пакет, обновляют свои ARP-кэши, даже если они не запрашивали этот адрес. Благодаря этому последующие передачи данных можно выполнять напрямую, без лишних запросов.

![13_g_arp](/images/arp_net/13_g_arp.png)

**Поля ARP-ответа**

| Поле                  | Пример значения       | Описание                                                      |
|-----------------------|---------------------|---------------------------------------------------------------|
| **Hardware Type**      | Ethernet (1)         | Тип канального уровня (Ethernet).                             |
| **Protocol Type**      | IPv4 (0x0800)        | Протокол верхнего уровня (IPv4).                              |
| **Hardware Size**      | 6                    | Длина MAC-адреса в байтах.                                   |
| **Protocol Size**      | 4                    | Длина IP-адреса в байтах.                                    |
| **Opcode**             | Reply (2)            | Тип ARP-сообщения: 2 — ответ. В G-ARP используется ARP Reply, но без запроса. |
| **Sender MAC Address** | 0c:ef:f7:15:00:00   | MAC-адрес устройства, которое рассылает информацию о себе.   |
| **Sender IP Address**  | 192.168.1.11         | IP-адрес устройства, которое рассылает информацию о себе.    |
| **Target MAC Address** | ff:ff:ff:ff:ff:ff    | Широковещательный MAC-адрес, пакет рассылается всем в сети.  |
| **Target IP Address**  | 192.168.1.11         | IP-адрес устройства, о котором рассылается информация.       |


* * *

![14_arp_windows](/images/arp_net/14_arp_windows.png)

После того как Ubuntu отправила Gratuitous ARP (G-ARP) с указанием своего IP и MAC-адреса, Windows получила этот пакет и автоматически обновила свой ARP-кэш.

* * * 

### 4. Динамический и статический ARP

**Динамический ARP** - это записи, которые устройство создаёт само, автоматически, когда нужно узнать MAC-адрес другого устройства по его IP. Такие записи добавляются в ARP-таблицу сами и через некоторое время могут удаляться, если адрес больше не используется.

В нашей работе пример динамического ARP был, когда Ubuntu отправила Gratuitous ARP для своего IP 192.168.1.11. Windows получила этот пакет и автоматически добавила запись.

---

**Статический ARP** - это записи, которые создаётся вручную и которые остаются в таблице пока их специально не удалят. Они полезны для устройств, с которыми всегда нужен стабильный контакт, например, серверы, маршрутизаторы или принтеры в сети.

Например, если бы мы вручную добавили на Windows запись для Ubuntu: **arp -s 192.168.1.11 0c:ef:f7:15:00:00**. то эта запись стала бы статической. Она не исчезнет сама и всегда будет использовать этот MAC для указанного IP, даже если Ubuntu не отправляет пакеты или G-ARP.
